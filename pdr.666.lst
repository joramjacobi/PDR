
ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 1




               1 ; PWM code for PDR
               2 ; written by Jojo
               3 
               4 processor t1005
               5 include regs.asm
              1a 
              2a  IF ((defined _ASM_CODEPAGE) || (defined _ASM_CHASM))
              3a 
              4a ;
              5a ; Register definitions for the Synaptics T1004, T1005, and T1006 CPUs.
              6a ; Last updated: 5/3/2005.
              7a ;
              8a ; Copyright (C) 1997-2005  Synaptics, Inc.
              9a ;
             10a 
             11a ; $Id: pdr.666.lst,v 1.1 2006/05/16 00:04:53 kirk Exp $
             12a 
             13a 
             14a  if !defined _ASM_CHASM
             15a         LIBFILE
             16a  endif
             17a 
             18a ;
             19a ; Definitions for MASKREV field and _ASM_PROCESSOR symbol.
             20a ;
             21a ; NOTE:  If the including source file contains a PROCESSOR directive,
             22a ; this directive must appear *before* the INCLUDE REGS.ASM line.
             23a ;
             24a 
0000         25a MASKREV_T1004A  EQU     $00
0001         26a MASKREV_T1004AA EQU     $01
0002         27a MASKREV_T1004AB EQU     $02
0003         28a MASKREV_T1004AC EQU     $03
0008         29a MASKREV_T1004B  EQU     $08                                                           [Ref: 62a]
0009         30a MASKREV_T1004BA EQU     $09
000A         31a MASKREV_T1004BB EQU     $0A
000A         32a MASKREV_T1004BC EQU     $0A   ; Same as T1004BB
000B         33a MASKREV_T1004BD EQU     $0B
000C         34a MASKREV_T1004BE EQU     $0C
000F         35a MASKREV_T1004C  EQU     $0F                                                           [Ref: 63a]
0010         36a MASKREV_T1005A1 EQU     $10                                                           [Ref: 64a]
0011         37a MASKREV_T1005   EQU     $11
0011         38a MASKREV_T1005A2 EQU     $11
0012         39a MASKREV_T1005A3 EQU     $12
0013         40a MASKREV_T1005A4 EQU     $13                                                           [Ref: 65a]
0020         41a MASKREV_T1006   EQU     $20                                                           [Ref: 66a]
0020         42a MASKREV_T1006A0 EQU     $20
0021         43a MASKREV_T1006A2 EQU     $21
0022         44a MASKREV_T1006A3 EQU     $22
0023         45a MASKREV_T1006A4 EQU     $23                                                           [Ref: 67a]
0028         46a MASKREV_T1006B  EQU     $28                                                           [Ref: 68a]
0028         47a MASKREV_T1006B0 EQU     $28
0028         48a MASKREV_T1006B1 EQU     $28
0030         49a MASKREV_T1007   EQU     $30   ; TBD
             50a 
             51a 
             52a ;
             53a ; General processor types.
             54a ;
             55a ; The T1004 and T1006 are similar in that they use the 14-bit
             56a ; instruction set (with 32-register banks).
             57a ;
             58a ; The T1005 and T1006 are similar in that they have many
             59a ; analog bits and other features in common.
             60a ;
             61a 
0001         62a SINCE_T1004B    EQU     _ASM_PROCESSOR >= MASKREV_T1004B                          [Ref: 71a 72a]
0001         63a SINCE_T1004C    EQU     _ASM_PROCESSOR >= MASKREV_T1004C                        [Ref: 706a 716a]
0001         64a SINCE_T1005     EQU     _ASM_PROCESSOR >= MASKREV_T1005A1
                                                                          [Ref: 70a 73a 536a 571a 677a 682a 687a]
0000         65a SINCE_T1005A4   EQU     _ASM_PROCESSOR >= MASKREV_T1005A4
0000         66a SINCE_T1006     EQU     _ASM_PROCESSOR >= MASKREV_T1006                       [Ref: 73a 74a 75a]
0000         67a SINCE_T1006A4   EQU     _ASM_PROCESSOR >= MASKREV_T1006A4

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 2




0000         68a SINCE_T1006B    EQU     _ASM_PROCESSOR >= MASKREV_T1006B      [Ref: 75a 76a 709a 711a 719a 721a]
             69a 
0000         70a IS_T1004        EQU     !SINCE_T1005         [Ref: 71a 72a 78a 90a* 150a* 423a* 525a* 538a* ...]
0000         71a IS_T1004A       EQU     IS_T1004 && !SINCE_T1004B
0000         72a IS_T1004B       EQU     IS_T1004 && SINCE_T1004B
0001         73a IS_T1005        EQU     SINCE_T1005 && !SINCE_T1006
                                                               [Ref: 79a 101a* 148a 411a 419a 434a 521a 560a ...]
0000         74a IS_T1006        EQU     SINCE_T1006       [Ref: 78a 79a 115a* 142a 415a 487a 513a 551a 588a ...]
0000         75a IS_T1006A       EQU     SINCE_T1006 && !SINCE_T1006B                   [Ref*: 517a* 555a* 603a*]
0000         76a IS_T1006B       EQU     SINCE_T1006B                   [Ref: 143a* 489a* 515a* 553a* 601a* 757a]
             77a 
0000         78a IS_T1004_6      EQU     IS_T1004 || IS_T1006
0001         79a IS_T1005_6      EQU     IS_T1005 || IS_T1006
             80a 
             81a 
             82a   if defined _ASM_CHASM
             83a*;
             84a*; Chasm does not define the segments internally, which provides additional
             85a*; flexibility for experimentation; however, do NOT change this unless you
             86a*; know what you are doing.
             87a*
             88a*equf      textequ textequ     ; Heinous hack to turn asmt4's EQUF into TEXTEQU
             89a*
             90a*    if IS_T1004
             91a*ZERO      segdef minaddr:$0000, maxaddr:$07FF, order:0       ; 0 is the lowest order so it WILL\
 come first
             92a*DATA0     segdef minaddr:$0000, maxaddr:$07FF, order:10
             93a*SUBR0     segdef minaddr:$0000, maxaddr:$07FF, order:20                            [Ref*: 133a*]
             94a*CODE0     segdef minaddr:$0000, maxaddr:$07FF, order:50                            [Ref*: 132a*]
             95a*LAST0     segdef minaddr:$0000, maxaddr:$07FF, order:90
             96a*DATA1     segdef minaddr:$0000, maxaddr:$07FF, order:15
             97a*SUBR1     segdef minaddr:$0000, maxaddr:$07FF, order:25
             98a*CODE1     segdef minaddr:$0000, maxaddr:$07FF, order:55
             99a*LAST1     segdef minaddr:$0000, maxaddr:$07FF, order:195
            100a*
            101a*    elseif IS_T1005
            102a*
            103a*ZERO      segdef minaddr:$0000, maxaddr:$07FF, order:0       ; 0 is the lowest order so it WILL\
 come first
            104a*DATA0     segdef minaddr:$0000, maxaddr:$07FF, order:10
            105a*SUBR0     segdef minaddr:$0000, maxaddr:$07FF, order:20                            [Ref*: 133a*]
            106a*CODE0     segdef minaddr:$0000, maxaddr:$07FF, order:50                            [Ref*: 132a*]
            107a*LAST0     segdef minaddr:$0000, maxaddr:$07FF, order:90
            108a*DATA1     segdef minaddr:$0800, maxaddr:$0FFF, order:110
            109a*SUBR1     segdef minaddr:$0800, maxaddr:$0FFF, order:120
            110a*CODE1     segdef minaddr:$0800, maxaddr:$0FFF, order:150
            111a*LAST1     segdef minaddr:$0800, maxaddr:$0FFF, order:190
            112a*INFO0     segdef minaddr:$1000, maxaddr:$103F, order:1
            113a*INFO1     segdef minaddr:$1800, maxaddr:$183F, order:2
            114a*
            115a*    elseif IS_T1006
            116a*
            117a*ZERO      segdef minaddr:$0000, maxaddr:$07FF, order:0       ; 0 is the lowest order so it WILL\
 come first
            118a*DATA0     segdef minaddr:$0000, maxaddr:$07FF, order:10
            119a*SUBR0     segdef minaddr:$0000, maxaddr:$07FF, order:20                            [Ref*: 133a*]
            120a*CODE0     segdef minaddr:$0000, maxaddr:$07FF, order:50                            [Ref*: 132a*]
            121a*LAST0     segdef minaddr:$0000, maxaddr:$07FF, order:90
            122a*DATA1     segdef minaddr:$0800, maxaddr:$0FFF, order:110
            123a*SUBR1     segdef minaddr:$0800, maxaddr:$0FFF, order:120
            124a*CODE1     segdef minaddr:$0C00, maxaddr:$13FF, order:100    ; Technically this should be at 0x0\
800..0x0FFF,
            125a*                                                            ; but Chasm uses the fact that the \
minaddr is
            126a*                                                            ; >= 0x0C00 to handle the odd T1006\
 ROM map.
            127a*LAST1     segdef minaddr:$0800, maxaddr:$0FFF, order:190
            128a*INFO0     segdef minaddr:$0BC0, maxaddr:$0BFE, order:1
            129a*SECURITY  segdef minaddr:$0BFF, maxaddr:$0BFF, order:2
            130a*    endif
            131a*
            132a*code      textequ code0
            133a*subr      textequ subr0

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 3

T1005 standard register definitions


            134a*
            135a   endif ; _ASM_CHASM
            136a 
            137a 
            138a ;
            139a ; Page heading for listing files.
            140a ;
            141a 
            142a   IF IS_T1006
            143a*   IF IS_T1006B
            144a*        SUBTITLE "T1006B standard register definitions"
            145a*   ELSE
            146a*        SUBTITLE "T1006 standard register definitions"
            147a*   ENDIF
            148a   ELSEIF IS_T1005
            149a         SUBTITLE "T1005 standard register definitions"
            150a   ELSE IS_T1004
            151a*        SUBTITLE "T1004 standard register definitions"
            152a   ENDIF
            153a 
            154a 
            155a ;
            156a ; Some basic definitions.
            157a ;
            158a 
            159a ;TRUE           EQU     1   ; Now built-in to asmt4.
            160a ;FALSE          EQU     0
            161a 
            162a 
            163a ;
            164a ; Macro for defining X/Y pairs of registers.
            165a ;
            166a ; The statement
            167a ;
            168a ;    XYLCTL XYEQU REG $F8
            169a ;
            170a ; generates three equates:
            171a ;
            172a ;    XLCTL  EQU REG $F8
            173a ;    YLCTL  EQU XLCTL + 1
            174a ;    XYLCTL EQU XLCTL ALT YLCTL
            175a ;
            176a 
            177a 
            178a   IFDEF _ASM_CHASM
            179a*;;;
            180a*;;; This was modified from the original reg.asm version because Chasm can't
            181a*;;; handle ++ inside of REPLSTR so we created theVar and theValue as temps.
            182a*;;;
            183a*XYEQU   MACRO   VAR:LABEL:REQ, VALUE:REQ      [Ref: 444a 445a 446a 447a 448a 449a 450a 451a ...]
            184a*        local theVar, theValue
            185a*
            186a*        ASSERT (VAL ALTBASE(VALUE) AND $0001) == $0000
            187a*
            188a*theVar    textequ ++VAR                              [Ref*: 184a* 191a* 192a* 192a* 193a* 193a*]
            189a*theValue  textequ ++VALUE                                                    [Ref*: 184a* 191a*]
            190a*
            191a*REPLSTR(theVar,"XY","X") EQU REPLSTR(theValue,"XY","X")
            192a*REPLSTR(theVar,"XY","Y") EQU REPLSTR(theVar,"XY","X") + 1
            193a*VAR     EQU     REPLSTR(theVar,"XY","X") ALT REPLSTR(theVar,"XY","Y")
                                                            [Ref*: 183a* 188a* 194a* 202a* 206a* 208a* 211a* ...]
            194a*        LABELM  VAR
            195a*XYEQU   ENDM                                  [Ref: 444a 445a 446a 447a 448a 449a 450a 451a ...]
            196a*
            197a*;
            198a*; For now, Chasm can't handle the 'NAMED' macro argument qualifier or the
            199a*; NOEXPAND operator. So we using a modified version of the macro.
            200a*;
            201a*
            202a*XYALLOC MACRO   VAR:LABEL:REQ, ADDR:REQ, OPTS:VARARG
            203a*        ASSERT (VAL ALTBASE(ADDR) AND $0001) == $0000
            204a*
            205a*    if exists(OPTS)

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 4

T1005 standard register definitions


            206a*REPLSTR(VAR,"XY","X") ALLOC REPLSTR(ADDR,"XY","X"), COUNT:2, ++OPTS
            207a*    else
            208a*REPLSTR(VAR,"XY","X") ALLOC REPLSTR(ADDR,"XY","X"), COUNT:2
            209a*    endif ; exists(OPTS)
            210a*
            211a*REPLSTR(VAR,"XY","Y") EQU REPLSTR(VAR,"XY","X") + 1
            212a*VAR     EQU     REPLSTR(VAR,"XY","X") ALT REPLSTR(VAR,"XY","Y")
                                                            [Ref*: 183a* 188a* 194a* 202a* 206a* 208a* 211a* ...]
            213a*        LABELM  VAR
            214a*XYALLOC ENDM
            215a*
            216a   ELSE ; !_ASM_CHASM
            217a 
            218a XYEQU MACRO VAR:LABEL:REQ, VALUE:REQ          [Ref: 444a 445a 446a 447a 448a 449a 450a 451a ...]
            219a   ASSERT (VAL ALTBASE(VALUE) AND $0001) == $0000
            220a REPLSTR(++VAR,"XY","X") EQU REPLSTR(++VALUE,"XY","X")
            221a REPLSTR(++VAR,"XY","Y") EQU REPLSTR(++VAR,"XY","X") + 1
            222a VAR EQU REPLSTR(++VAR,"XY","X") ALT REPLSTR(++VAR,"XY","Y")
            223a   LABELM  VAR
            224a XYEQU ENDM
            225a 
            226a 
            227a XYALLOC MACRO   VAR:LABEL:REQ, ADDR:NAMED:POS, ALIGN:NUM:=1, OPTS:VARARG
            228a         ASSERT (VAL ALTBASE(ADDR) AND $0001) == $0000
            229a REPLSTR(++VAR,"XY","X") ALLOC REPLSTR(++ADDR,"XY","X"),  \
            230a             NOEXPAND("ALIGN"):ALIGN * ((ALIGN AND 1) + 1), COUNT:2, OPTS
            231a REPLSTR(++VAR,"XY","Y") EQU REPLSTR(++VAR,"XY","X") + 1
            232a VAR     EQU     REPLSTR(++VAR,"XY","X") ALT REPLSTR(++VAR,"XY","Y")
            233a         LABELM  VAR
            234a XYALLOC ENDM
            235a   ENDIF ; _ASM_CHASM
            236a 
            237a 
            238a ;
            239a ; Macro for defining general indexable pairs of registers.
            240a ;
            241a ; The statement
            242a ;
            243a ;    AB PAIREQU A, B
            244a ;
            245a ; defines a symbol AB which can be used with "IND" addressing
            246a ; to access either register A or register B depending on the
            247a ; state of the X register.  After the instruction
            248a ;
            249a ;     BANK A
            250a ;
            251a ; the following IND expressions work as follows:
            252a ;
            253a ;     IND A   addresses register A,
            254a ;     IND B   addresses register B, and
            255a ;     IND AB  addresses register A.
            256a ;
            257a ; If one then executes the instruction
            258a ;
            259a ;     ADD X, #B - A
            260a ;
            261a ; then these expressions work instead as follows:
            262a ;
            263a ;     IND A   addresses register B (with an error during simt4),
            264a ;     IND B   addresses register B, and
            265a ;     IND AB  addresses register B.
            266a ;
            267a ; The simt4 error for "IND A" is caused by the implicit
            268a ; assertion on [X] that is generated by the assembler.
            269a ;
            270a ; The PAIREQU macro requires A and B to have a certain
            271a ; address relationship:  Address B must be the same as
            272a ; address A except that one or more `0' bits in address A
            273a ; are `1' bits in address B.  Also, if A and B are bit-fields,
            274a ; they must refer to identical fields within their respective
            275a ; registers.
            276a ;
            277a ; Note that the XYEQU and XYALLOC macros above generate pairs of

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 5

T1005 standard register definitions


            278a ; variables which are compatible with PAIREQU.  In other words,
            279a ; the macro "XYFOO XYEQU ..." generates symbols XFOO, YFOO, and
            280a ; XYFOO with the property that XYFOO is defined the same as it
            281a ; would be by the statement "XYFOO PAIREQU XFOO, YFOO".  In this
            282a ; case, address XFOO and YFOO differ in that the former has a `0'
            283a ; in its least significant bit, while the latter has a `1' in
            284a ; that bit.
            285a ;
            286a ; *Several* register pairs each generated by PAIREQU may be
            287a ; accessed by the same indexing loop if the ALTSPANs of all the
            288a ; pairs are the same; this can be verified with an assertion
            289a ; like
            290a ;
            291a ;     ASSERT ALTSPAN(AB1) == ALTSPAN(AB2)
            292a ;
            293a 
            294a PAIREQU MACRO AB:LABEL:REQ, A:REQ, B:REQ
            295a         ASSERT (VAL ALTBASE(A) AND NOT VAL ALTBASE(B)) == $0000
            296a         ASSERT BITMASK(A) == BITMASK(B)
            297a         ASSERT ALTSPAN(A) == ALTSPAN(B)
            298a         ASSERT ((VAL ALTBASE(B) AND NOT VAL ALTBASE(A)) AND ALTSPAN(A)) == $0000
            299a AB      EQU (A) ALT (B)
            300a         LABELM AB
            301a PAIREQU ENDM
            302a 
            303a 
            304a ;
            305a ; Macros that act like EQU, EQUF, and TEXTEQU but defer to an earlier
            306a ; definition if present.
            307a ;
            308a 
            309a   IFNDEF _ASM_CHASM
            310a EQUDEF  MACRO SYM:LABEL, VAL:VAL
            311a         IFNDEF SYM
            312a SYM      EQU ALIAS VAL
            313a          LABELM SYM
            314a         ENDIF
            315a EQUDEF  ENDM
            316a 
            317a EQUFDEF MACRO SYM:LABEL, VAL:VAL
            318a         IFNDEF SYM
            319a SYM      EQUF ALIAS VAL
            320a          LABELM SYM
            321a         ENDIF
            322a EQUFDEF ENDM
            323a 
            324a TEXTEQUDEF MACRO SYM:LABEL, VAL:TEXT
            325a         IFNDEF SYM
            326a SYM      TEXTEQU ++VAL
            327a         ENDIF
            328a TEXTEQUDEF ENDM
            329a   ENDIF
            330a 
            331a 
            332a ;
            333a ; Macro for defining condition names.
            334a ;
            335a ; This defines a bit name, an "if..." instruction, a "skp..."
            336a ; instruction, and a "j..." instruction.
            337a ;
            338a 
            339a   IFDEF _ASM_CHASM
            340a*;
            341a*; For now Chasm doesn't handle the use of ++ that the real regs.asm
            342a*; wants to use...
            343a*
            344a*DEFCONDNAME     MACRO   NAME:LABEL, TheBIT:REQ
                                                               [Ref: 468a 469a 470a 471a 472a 866a 867a 868a ...]
            345a*                LOCAL   UNAME
            346a*NAME            EQU     TheBIT                 [Ref*: 344a* 347a* 348a* 349a* 351a* 356a* 358a*]
            347a*UNAME           TEXTEQU SUBSTSTR(NAME,_,)                                    [Ref*: 345a* 357a*]
            348a*IF##UNAME       TEXTEQU IFSET NAME
            349a*SKP##UNAME      TEXTEQU IFCLR NAME

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 6

T1005 standard register definitions


            350a*J##UNAME        MACRO   DEST:REQ
            351a*                IFSET   NAME
            352a*                 JMP    DEST
            353a*                ENDM
            354a*DEFCONDNAME     ENDM                          [Ref: 468a 469a 470a 471a 472a 866a 867a 868a ...]
            355a*
            356a*DEFCONDNAME_B   MACRO   NAME:LABEL, TheBIT:REQ
                                                               [Ref: 877a 878a 920a 921a 922a 923a 925a 926a ...]
            357a*                LOCAL   UNAME
            358a*UNAME           TEXTEQU SUBSTSTR(NAME,_,)                                    [Ref*: 345a* 357a*]
            359a*IF##UNAME       TEXTEQU IF##TheBIT
            360a*SKP##UNAME      TEXTEQU SKP##TheBIT
            361a*J##UNAME        MACRO   REG_:REQ, DEST:REQ
            362a*                IF##TheBIT REG_
            363a*                 JMP    DEST
            364a*                ENDM
            365a*DEFCONDNAME_B   ENDM                          [Ref: 877a 878a 920a 921a 922a 923a 925a 926a ...]
            366a*
            367a   ELSE ; !_ASM_CHASM
            368a 
            369a DEFCONDNAME     MACRO   NAME:LABEL, TheBIT:REQ
                                                               [Ref: 468a 469a 470a 471a 472a 866a 867a 868a ...]
            370a                 LOCAL   UNAME
            371a NAME            EQU     TheBIT
            372a UNAME           TEXTEQU ++REPLSTR(++NAME,"_","")
            373a IF##UNAME       TEXTEQU "IFSET " ++ NAME
            374a SKP##UNAME      TEXTEQU "IFCLR " ++ NAME
            375a SET##UNAME      TEXTEQU "BSET " ++ NAME
            376a CLR##UNAME      TEXTEQU "BCLR " ++ NAME
            377a J##UNAME        MACRO   DEST:REQ
            378a                 IFSET   NAME
            379a                  JMP    DEST
            380a J##UNAME        ENDM
            381a DEFCONDNAME     ENDM
            382a 
            383a DEFCONDNAME_B   MACRO   NAME:LABEL, TheBIT:REQ
                                                               [Ref: 877a 878a 920a 921a 922a 923a 925a 926a ...]
            384a                 LOCAL   UNAME
            385a UNAME           TEXTEQU ++REPLSTR(++NAME,"_","")
            386a IF##UNAME       TEXTEQU "IF" ++ TheBIT
            387a SKP##UNAME      TEXTEQU "SKP" ++ TheBIT
            388a J##UNAME        MACRO   REG:REQ, DEST:REQ
            389a                 IF##TheBIT REG
            390a                  JMP    DEST
            391a J##UNAME        ENDM
            392a DEFCONDNAME_B   ENDM
            393a 
            394a   ENDIF ; _ASM_CHASM
            395a 
            396a ;
            397a ; Special registers.
            398a ;
            399a 
0000        400a STATX           EQU     REG $00                 [Ref: 464a 465a 468a.1 469a.1 470a.1 471a.1 ...]
0001        401a A               EQU     REG $01             [Ref: 1618a* 39b 74b 75b 409b 57c 67c 240c 244c ...]
0002        402a PC              EQU     REG $02                                        [Ref: 479a 480a 80b 161d]
0003        403a LINK            EQU     REG $03
0004        404a PCTL            EQU     REG $04                                             [Ref: 31b 293c 267d]
0005        405a PIE             EQU     REG $05               [Ref: 488a* 491a* 492a* 296c 61d 66d 70d 71d 270d]
0006        406a PDIR            EQU     REG $06                             [Ref: 490a* 213 288c 290c 262d 264d]
0007        407a POUT            EQU     REG $07           [Ref: 215 216 217 227 50c 61c 252c 254c 299c 301c ...]
0008        408a PIN             EQU     REG $08                               [Ref: 493a* 494a* 212 224 225 226]
0009        409a CCTL            EQU     REG $09               [Ref: 503a 505a 506a 507a 508a 509a 510a 511a ...]
000A        410a CTIME           EQU     REG $0A                            [Ref: 499a 500a 67d 74d 76d 99d 101d]
            411a   IF IS_T1005
000B        412a SPITX           EQU     REG $0B                                                 [Ref: 129d 205d]
            413a   ENDIF
            414a 
            415a   IF IS_T1006
            416a*FIRST_RAM       EQU     REG $0B                                          [Ref: 417a* 425a* 783a]
            417a*LAST_RAM        EQU     FIRST_RAM + 191   ; REG $CA                              [Ref: 784a 35b]
            418a*RAM_BANK_SIZE   EQU     32                                                           [Ref: 785a]
            419a   ELSEIF IS_T1005

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 7

T1005 standard register definitions


000C        420a FIRST_RAM       EQU     REG $0C                                          [Ref: 417a* 425a* 783a]
00DF        421a LAST_RAM        EQU     REG $DF                                                  [Ref: 784a 35b]
0040        422a RAM_BANK_SIZE   EQU     64                                                           [Ref: 785a]
            423a   ELSE IS_T1004
            424a*FIRST_RAM       EQU     REG $0B                                          [Ref: 417a* 425a* 783a]
            425a*LAST_RAM        EQU     FIRST_RAM + 127   ; REG $8A                              [Ref: 784a 35b]
            426a*RAM_BANK_SIZE   EQU     32                                                           [Ref: 785a]
            427a   ENDIF
            428a 
00E2        429a TPC1            EQU     REG $E2
00E3        430a TPC2            EQU     REG $E3                                                       [Ref: 57b]
00E6        431a TPC3            EQU     REG $E6                                                       [Ref: 62b]
00EA        432a PORTB           EQU     REG $EA         ; Not used in current chips.
00EB        433a PORTC           EQU     REG $EB         ; Not used in current chips.
            434a   IF IS_T1005
00EE        435a SPIRX           EQU     REG $EE                                                  [Ref: 79d 109d]
00EF        436a PAUX            EQU     REG $EF                                         [Ref: 51d 52d 104d 125d]
            437a   ENDIF
00FE        438a RCOND           EQU     REG $FE                             [Ref: 731a 732a 736a 737a 738a 739a]
            439a   IFNDEF _ASM_CHASM
00FF        440a RESET           EQU     REG $FF         ; This name may become obsolete
            441a   ENDIF  ; _ASM_CHASM
00FF        442a RESET_REG       EQU     REG $FF                                                   [Ref*: 1583a*]
            443a 
00E0        444a XYREGS          XYEQU   REG $E0
00E0        445a XYCH            XYEQU   REG $E0
00E0        446a XYCH0           XYEQU   REG $E0
00E4        447a XYCH4           XYEQU   REG $E4
00E8        448a XYCH8           XYEQU   REG $E8
00EC        449a XYCH12          XYEQU   REG $EC
00F0        450a XYCH16          XYEQU   REG $F0         ; Note: YCH16 is really DDAC!
00F8        451a XYLCTL          XYEQU   REG $F8
00FC        452a XYHCTL          XYEQU   REG $FC
            453a 
00F1        454a DDAC            EQU     YCH16
00F4        455a OCTL            EQU     REG $F4               [Ref: 550a 552a* 554a* 556a* 557a* 559a* 561a ...]
00F5        456a TCTL            EQU     REG $F5                        [Ref: 578a 579a 580a 581a 582a 583a 416b]
            457a 
            458a 
            459a ;
            460a ; Register bits.
            461a ;
            462a 
            463a ; Fields of STATX.
0000        464a STATUS          EQU     HIGH STATX
0000        465a X               EQU     LOW STATX                            [Ref: 38b 287b 301b 307b 189d 195d]
            466a ;               EQU     STATX BIT 15
            467a ;               EQU     STATX BIT 14
            468a Z               DEFCONDNAME STATX BIT 13
            469a ZL              DEFCONDNAME STATX BIT 12
            470a C               DEFCONDNAME STATX BIT 11
            471a CL              DEFCONDNAME STATX BIT 10
            472a CNZ             DEFCONDNAME STATX BIT 9
            473a ;               EQU     STATX BIT 8
            474a 
            475a ; Masks for STATX.
C100        476a STATX_RESERVED  EQU     $C100
            477a 
            478a ; Fields of PC.
0002        479a PC_GUARD        EQU     PC BITS 15:12                                                [Ref: 484a]
0002        480a PC_PAGE         EQU     PC BIT 11
            481a 
            482a ; Masks for PC.
A000        483a PC_GUARD_VAL    EQU     $A000
F000        484a PC_RESERVED     EQU     BITMASK(PC_GUARD)
            485a 
            486a ; Masks for I/O port registers.
            487a   IF IS_T1006
            488a*I2C_INT_ENABLE  EQU     PIE BIT 15
            489a*   IF IS_T1006B
            490a*I2C_CLAMPBITS   EQU     PDIR BIT 15     ; Clamp on every SCL falling edge
            491a*I2C_INTONCLAMP  EQU     PIE BIT 15      ; Clamp on SCL low after START, interrupt on clamp
            492a*I2C_INTONSTOP   EQU     PIE BIT 14      ; Interrupt immediately on STOP or START

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 8

T1005 standard register definitions


            493a*I2C_DATALATCH   EQU     PIN BIT 15
            494a*I2C_SAWSTART    EQU     PIN BIT 14
            495a*   ENDIF
            496a   ENDIF
            497a 
            498a ; Fields of CTIME.
000A        499a TRDY3           EQU     CTIME BIT 15                                                  [Ref: 63b]
000A        500a CTIME_COUNT     EQU     CTIME BITS 14:0
            501a 
            502a ; Fields of CCTL.
0009        503a CCTL_GUARD      EQU     CCTL BITS 15:14                                        [Ref: 537a 539a*]
            504a ; CCTL bit 15 is also PTEST (and FLSO on T1006).
0009        505a TRDY1           EQU     CCTL BIT 13
0009        506a TEN3            EQU     CCTL BIT 12                                                   [Ref: 64b]
0009        507a TEN2            EQU     CCTL BIT 11                                                   [Ref: 59b]
0009        508a TRDY2           EQU     CCTL BIT 10                                                   [Ref: 58b]
0009        509a TGL             EQU     CCTL BIT 9
0009        510a SCHECK          EQU     CCTL BIT 8
0009        511a TPRI            EQU     CCTL BIT 7                                                    [Ref: 53b]
0009        512a TALT            EQU     CCTL BIT 6                                                    [Ref: 52b]
            513a   IF IS_T1006
            514a*CCLK            EQU     CCTL BITS 5:4
            515a*   IF IS_T1006B
            516a*ENSHLD          EQU     CCTL BIT 3
            517a*   ELSE IS_T1006A
            518a*;               EQU     CCTL BIT 3
            519a*   ENDIF
            520a*XRES            EQU     CCTL BIT 2
            521a   ELSEIF IS_T1005
0009        522a CCLK            EQU     CCTL BITS 5:4
0009        523a CDIV            EQU     CCTL BIT 3
0009        524a XRES            EQU     CCTL BIT 2
            525a   ELSE IS_T1004
            526a*CCLK            EQU     CCTL BIT 5
            527a*XTSLP           EQU     CCTL BIT 4
            528a*WDTO            EQU     CCTL BIT 3      ; T1004B and later
            529a*ESDTO           EQU     CCTL BIT 3      ; T1004A
            530a*;               EQU     CCTL BIT 2
            531a   ENDIF
0009        532a THR             EQU     CCTL BITS 1:0                    [Ref: 541a 542a 543a 280b 281b 77c 95d]
            533a 
            534a ; Masks for CCTL.
8000        535a CCTL_GUARD_VAL  EQU     $8000
            536a   IF SINCE_T1005
C000        537a CCTL_RESERVED   EQU     BITMASK(CCTL_GUARD)
            538a   ELSE IS_T1004
            539a*CCTL_RESERVED   EQU     BITMASK(CCTL_GUARD) OR $0004
            540a   ENDIF
0000        541a THR_1           EQU     BITBASE(THR, 00b)
0001        542a THR_2           EQU     BITBASE(THR, 01b)
0002        543a THR_3           EQU     BITBASE(THR, 10b)
            544a ;               EQU     BITBASE(THR, 11b)
            545a 
            546a ; Masks for analog registers.
FC00        547a ANACTL_RESERVED EQU     $FC00                         [Ref: 572a 574a* 586a 725a 726a 727a 728a]
            548a 
            549a ; Fields of OCTL.
00F4        550a AEN             EQU     OCTL BIT 9                                                    [Ref: 271]
            551a   IF IS_T1006
            552a*DHOLD           EQU     OCTL BIT 8
            553a*   IF IS_T1006B
            554a*GUARDLO         EQU     OCTL BITS 7:6
            555a*   ELSE IS_T1006A
            556a*OCTL_GUARD      EQU     OCTL BIT 7                                                 [Ref*: 574a*]
            557a*EN3V            EQU     OCTL BIT 6
            558a*   ENDIF
            559a*OSC             EQU     OCTL BITS 5:0
            560a   ELSEIF IS_T1005
00F4        561a BGCAL           EQU     OCTL BITS 8:6
00F4        562a OSC             EQU     OCTL BITS 5:0
            563a   ELSE IS_T1004
            564a*RCOEN           EQU     OCTL BIT 8      ; Guard bit for T1004A
            565a*OCTL_GUARD      EQU     OCTL BIT 7      ; 8:6 for T1004A                           [Ref*: 574a*]

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 9

T1005 standard register definitions


            566a*OSC             EQU     OCTL BITS 6:0   ; Only six bits for T1004A
            567a   ENDIF
            568a 
            569a ; Masks for OCTL.
0000        570a OCTL_GUARD_VAL  EQU     $0000
            571a   IF SINCE_T1005
FC00        572a OCTL_RESERVED   EQU     ANACTL_RESERVED
            573a   ELSE IS_T1004
            574a*OCTL_RESERVED   EQU     ANACTL_RESERVED OR BITMASK(OCTL_GUARD)
            575a   ENDIF
            576a 
            577a ; Fields of TCTL.
00F5        578a CHN             EQU     TCTL BITS 9:8
00F5        579a DCMP            EQU     TCTL BIT 7
00F5        580a DDRV            EQU     TCTL BIT 6
00F5        581a PSTR            EQU     TCTL BIT 5                                                   [Ref: 415b]
00F5        582a PSEL            EQU     TCTL BITS 4:0       [Ref: 590a* 591a* 592a* 593a* 594a* 595a* 596a* ...]
00F5        583a PAXIS           EQU     TCTL BIT 0
            584a 
            585a ; Masks for TCTL.
FC00        586a TCTL_RESERVED   EQU     ANACTL_RESERVED
            587a 
            588a   IF IS_T1006
            589a*; Working map of probe tap encodings (T1006 spec v1.10)
            590a*PSEL_XVG1       EQU     BITBASE(PSEL, 00000b)
            591a*PSEL_YVG1       EQU     BITBASE(PSEL, 00001b)
            592a*PSEL_XVGSET     EQU     BITBASE(PSEL, 00010b)
            593a*PSEL_YVGSET     EQU     BITBASE(PSEL, 00011b)
            594a*PSEL_DSHIELDH   EQU     BITBASE(PSEL, 00100b)
            595a*PSEL_CHGVG      EQU     BITBASE(PSEL, 00101b)
            596a*PSEL_YCHGVG     EQU     BITBASE(PSEL, 00101b)    ; T1005-style synonym.
            597a*PSEL_XREFHI     EQU     BITBASE(PSEL, 00110b)
            598a*PSEL_YREFHI     EQU     BITBASE(PSEL, 00111b)
            599a*PSEL_XREFLO     EQU     BITBASE(PSEL, 01000b)
            600a*PSEL_YREFLO     EQU     BITBASE(PSEL, 01001b)
            601a*   IF IS_T1006B
            602a*PSEL_MINREF     EQU     BITBASE(PSEL, 01010b)
            603a*   ELSE IS_T1006A
            604a*PSEL_DSHIELDL   EQU     BITBASE(PSEL, 01010b)
            605a*   ENDIF
            606a*PSEL_SAMPLE     EQU     BITBASE(PSEL, 01011b)
            607a*PSEL_ASHIELDL   EQU     BITBASE(PSEL, 01100b)
            608a*PSEL_LSO        EQU     BITBASE(PSEL, 01101b)
            609a*PSEL_GROUND     EQU     BITBASE(PSEL, 01110b)                                        [Ref: 415b]
            610a*PSEL_VDD        EQU     BITBASE(PSEL, 01111b)
            611a*PSEL_HICAP      EQU     BITBASE(PSEL, 10000b)
            612a*PSEL_OSCTRIP    EQU     BITBASE(PSEL, 10001b)
            613a*PSEL_LOCAP      EQU     BITBASE(PSEL, 10010b)
            614a*PSEL_IPB        EQU     BITBASE(PSEL, 10011b)
            615a*PSEL_FLOAT      EQU     BITBASE(PSEL, 11111b)
            616a   ELSEIF IS_T1005
0000        617a PSEL_DSHIELDH   EQU     BITBASE(PSEL, 00000b)
0000        618a PSEL_SHIELDH    EQU     BITBASE(PSEL, 00000b)    ; Old name.
0001        619a PSEL_SAMPLE     EQU     BITBASE(PSEL, 00001b)
0002        620a PSEL_XIREFLO    EQU     BITBASE(PSEL, 00010b)
0003        621a PSEL_YIREFLO    EQU     BITBASE(PSEL, 00011b)
0004        622a PSEL_XCHGVG     EQU     BITBASE(PSEL, 00100b)
0005        623a PSEL_YCHGVG     EQU     BITBASE(PSEL, 00101b)
0006        624a PSEL_XREFHI     EQU     BITBASE(PSEL, 00110b)
0007        625a PSEL_YREFHI     EQU     BITBASE(PSEL, 00111b)
0008        626a PSEL_XREFLO     EQU     BITBASE(PSEL, 01000b)
0009        627a PSEL_YREFLO     EQU     BITBASE(PSEL, 01001b)
000A        628a PSEL_XMINREF    EQU     BITBASE(PSEL, 01010b)
000B        629a PSEL_YMINREF    EQU     BITBASE(PSEL, 01011b)
000C        630a PSEL_ASHIELDL   EQU     BITBASE(PSEL, 01100b)
000C        631a PSEL_SHIELDL    EQU     BITBASE(PSEL, 01100b)    ; Old name.
000D        632a PSEL_LSO        EQU     BITBASE(PSEL, 01101b)    ; T1006-style synonym.
000D        633a PSEL_BGCLOCK    EQU     BITBASE(PSEL, 01101b)
000E        634a PSEL_GROUND     EQU     BITBASE(PSEL, 01110b)                                        [Ref: 415b]
000F        635a PSEL_VDD        EQU     BITBASE(PSEL, 01111b)
0010        636a PSEL_HICAP      EQU     BITBASE(PSEL, 10000b)
0011        637a PSEL_OSCTRIP    EQU     BITBASE(PSEL, 10001b)
0012        638a PSEL_LOCAP      EQU     BITBASE(PSEL, 10010b)

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 10

T1005 standard register definitions


0013        639a PSEL_IPB        EQU     BITBASE(PSEL, 10011b)
001F        640a PSEL_FLOAT      EQU     BITBASE(PSEL, 11111b)
            641a   ELSE IS_T1004
            642a*PSEL_XVG1       EQU     BITBASE(PSEL, 00000b)
            643a*PSEL_YVG1       EQU     BITBASE(PSEL, 00001b)
            644a*PSEL_XVGSET     EQU     BITBASE(PSEL, 00010b)
            645a*PSEL_YVGSET     EQU     BITBASE(PSEL, 00011b)
            646a*PSEL_XCHGVG     EQU     BITBASE(PSEL, 00100b)
            647a*PSEL_YCHGVG     EQU     BITBASE(PSEL, 00101b)
            648a*PSEL_XREFHI     EQU     BITBASE(PSEL, 00110b)
            649a*PSEL_YREFHI     EQU     BITBASE(PSEL, 00111b)
            650a*PSEL_XREFLO     EQU     BITBASE(PSEL, 01000b)
            651a*PSEL_YREFLO     EQU     BITBASE(PSEL, 01001b)
            652a*PSEL_XBIASCMP   EQU     BITBASE(PSEL, 01010b)
            653a*PSEL_YBIASCMP   EQU     BITBASE(PSEL, 01011b)
            654a*PSEL_EPROM      EQU     BITBASE(PSEL, 01101b)
            655a*PSEL_GROUND     EQU     BITBASE(PSEL, 01110b)                                        [Ref: 415b]
            656a*PSEL_VDD        EQU     BITBASE(PSEL, 01111b)
            657a*PSEL_HICAP      EQU     BITBASE(PSEL, 10000b)
            658a*PSEL_OSCTRIP    EQU     BITBASE(PSEL, 10001b)
            659a*PSEL_LOCAP      EQU     BITBASE(PSEL, 10010b)
            660a*PSEL_IPB        EQU     BITBASE(PSEL, 10011b)
            661a*PSEL_FLOAT      EQU     BITBASE(PSEL, 11111b)
            662a   ENDIF
            663a 
            664a ; Fields of XLCTL and YLCTL.
00F8        665a XYSENSE         XYEQU   XYLCTL BIT 9
00F8        666a XYREFEN         XYEQU   XYLCTL BIT 8
00F8        667a XYADCEN         XYEQU   XYLCTL BIT 7
            668a   IF IS_T1004
            669a*XYBCMP          XYEQU   XYLCTL BIT 6
            670a   ENDIF
00F8        671a XYREFLO         XYEQU   XYLCTL BITS 5:0
            672a 
            673a ; Fields of XHCTL and YHCTL.
00FC        674a XYREFHI         XYEQU   XYHCTL BITS 5:0
            675a 
            676a ; Fields of XLCTL.
            677a   IF SINCE_T1005
00F8        678a ENBL9           EQU     XLCTL BIT 6
            679a   ENDIF
            680a 
            681a ; Fields of YLCTL.
            682a   IF SINCE_T1005
00F9        683a BIGREF          EQU     YLCTL BIT 6                                                   [Ref: 287]
            684a   ENDIF
            685a 
            686a ; Fields of XHCTL.
            687a   IF SINCE_T1005
00FC        688a NCHN            EQU     XHCTL BITS 9:8
00FC        689a OLDF            EQU     XHCTL BIT 7
00FC        690a MOIST           EQU     XHCTL BIT 6
            691a   ELSE IS_T1004
            692a*OLDF            EQU     XHCTL BIT 9
            693a*BIGREF          EQU     XHCTL BIT 8                                                   [Ref: 287]
            694a*EN5V            EQU     XHCTL BIT 7
            695a*MOIST           EQU     XHCTL BIT 6
            696a   ENDIF
            697a 
            698a ; Fields of YHCTL.
00FD        699a GS              EQU     YHCTL BITS 9:7       [Ref: 704a 705a 707a 710a* 712a 714a 715a 717a ...]
00FD        700a BOFF            EQU     YHCTL BIT 6                                                  [Ref: 701a]
00FD        701a BIASENB         EQU     BOFF
            702a 
            703a ; Masks for {X,Y}{L,H}CTL.
0000        704a GS_1_000        EQU     BITBASE(GS, 000b)       ; 1.000
0080        705a GS_1_006        EQU     BITBASE(GS, 001b)       ; 1.006
            706a   IF SINCE_T1004C
0100        707a GS_1_200        EQU     BITBASE(GS, 010b)       ; 1.200
            708a   ENDIF
            709a   IF SINCE_T1006B
            710a*GS_1_206        EQU     BITBASE(GS, 011b)       ; 1.206
            711a   ELSE !SINCE_T1006B

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 11

T1005 standard register definitions


0180        712a GS_1_012        EQU     BITBASE(GS, 011b)       ; 1.012
            713a   ENDIF
0200        714a GS_1_100        EQU     BITBASE(GS, 100b)       ; 1.100
0280        715a GS_1_106        EQU     BITBASE(GS, 101b)       ; 1.106
            716a   IF SINCE_T1004C
0300        717a GS_1_300        EQU     BITBASE(GS, 110b)       ; 1.300
            718a   ENDIF
            719a   IF SINCE_T1006B
            720a*GS_1_306        EQU     BITBASE(GS, 111b)       ; 1.306
            721a   ELSE !SINCE_T1006B
0380        722a GS_1_112        EQU     BITBASE(GS, 111b)       ; 1.112
            723a   ENDIF
            724a 
FC00        725a XLCTL_RESERVED  EQU     ANACTL_RESERVED
FC00        726a YLCTL_RESERVED  EQU     ANACTL_RESERVED
FC00        727a XHCTL_RESERVED  EQU     ANACTL_RESERVED
FC00        728a YHCTL_RESERVED  EQU     ANACTL_RESERVED
            729a 
            730a ; Fields of RCOND.
00FE        731a MASKREV         EQU     HIGH RCOND
00FE        732a RPOWER          EQU     RCOND BIT 7
            733a ;               EQU     RCOND BIT 6
            734a ;               EQU     RCOND BIT 5
            735a ;               EQU     RCOND BIT 4
00FE        736a RESD            EQU     RCOND BIT 3     ; T1004A
00FE        737a RWDT            EQU     RCOND BIT 3     ; T1004B and later
00FE        738a RCHECK          EQU     RCOND BIT 2
00FE        739a RSW             EQU     RCOND BIT 1
            740a ;               EQU     RCOND BIT 0
            741a 
            742a ; Masks for RCOND.
0071        743a RCOND_RESERVED  EQU     $0071
            744a 
            745a 
            746a ;
            747a ; Processor-specific names for special pins.
            748a ;
            749a 
            750a   IF IS_T1005
0006        751a SPI_SSB_PIN     EQU     6
0007        752a SPI_SDIN_PIN    EQU     7
000A        753a SPI_SCLK_PIN    EQU     10
000B        754a SPI_SDOUT_PIN   EQU     11
            755a   ENDIF
            756a 
            757a   IF IS_T1006B
            758a*DRIVENSHIELD_PIN EQU    0
            759a   ENDIF
            760a 
            761a 
            762a ;
            763a ; Processor description symbols.
            764a ;
            765a 
            766a   IF IS_T1005
0010        767a _PROC_ROMWIDTH  EQU     16
FFFF        768a _PROC_ROMBLANK  EQU     $FFFF
1000        769a _PROC_ROMSIZE   EQU     $1000
            770a   ELSE
            771a*_PROC_ROMWIDTH  EQU     14
            772a*_PROC_ROMBLANK  EQU     $0000
            773a*   IF IS_T1006
            774a*_PROC_ROMSIZE   EQU     $0C00
            775a*   ELSE IS_T1004
            776a*_PROC_ROMSIZE   EQU     $0800
            777a*   ENDIF
            778a   ENDIF
            779a 
A000        780a _PROC_ROMOFFSET EQU     $A000
10000       781a _PROC_CODESIZE  EQU     $10000
0010        782a _PROC_RAMWIDTH  EQU     16
000C        783a _PROC_FIRSTRAM  EQU     FIRST_RAM
00DF        784a _PROC_LASTRAM   EQU     LAST_RAM

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 12

T1005 standard register definitions


0040        785a _PROC_BANKSIZE  EQU     RAM_BANK_SIZE
0100        786a _PROC_DATASIZE  EQU     256
0000        787a _PROC_IS_T1004  EQU     IS_T1004
0001        788a _PROC_IS_T1005  EQU     IS_T1005
0000        789a _PROC_IS_T1006  EQU     IS_T1006
0001        790a _PROC_IS_T100X  EQU     TRUE                                                         [Ref: 792a]
0000        791a _PROC_IS_CHIMERA EQU    FALSE
0001        792a _PROC_OR_INDEX  EQU     _PROC_IS_T100X
            793a 
            794a         KEEPSYM -_PROC_*
            795a 
            796a 
            797a ;
            798a ; Thread masks.
            799a ;
            800a 
0001        801a _THR_1          EQU $0001                                                            [Ref: 804a]
0002        802a _THR_2          EQU $0002                                                            [Ref: 804a]
0004        803a _THR_3          EQU $0004                                                            [Ref: 804a]
0007        804a _THR_ANY        EQU _THR_1 OR _THR_2 OR _THR_3
            805a 
            806a 
            807a ;
            808a ; Fuse values (T1004 only).
            809a ;
            810a 
            811a   IF IS_T1004
            812a*FTEST_TEST      EQU     0
            813a*FTEST_RUN       EQU     1                                                          [Ref*: 814a*]
            814a*FTEST_NORMAL    EQU     FTEST_RUN
            815a*
            816a*FOFRC_EITHER    EQU     0                                                          [Ref*: 819a*]
            817a*FOFRC_RC        EQU     1
            818a*FOFRC_XTAL      EQU     1
            819a*FOFRC_NORMAL    EQU     FOFRC_EITHER
            820a*
            821a*FXTAL_EITHER    EQU     0                                                          [Ref*: 824a*]
            822a*FXTAL_RC        EQU     0
            823a*FXTAL_XTAL      EQU     1
            824a*FXTAL_NORMAL    EQU     FXTAL_EITHER
            825a*
            826a*FCDIV_SLOW      EQU     0
            827a*FCDIV_FAST      EQU     1                                                          [Ref*: 828a*]
            828a*FCDIV_NORMAL    EQU     FCDIV_FAST
            829a*
            830a*FPOR_INTERNAL   EQU     0                                                          [Ref*: 832a*]
            831a*FPOR_EXTERNAL   EQU     1
            832a*FPOR_NORMAL     EQU     FPOR_INTERNAL
            833a*
            834a*FESD_DISABLE    EQU     0               ; T1004A
            835a*FESD_ENABLE     EQU     1                                                          [Ref*: 836a*]
            836a*FESD_NORMAL     EQU     FESD_ENABLE
            837a*
            838a*FWDT_DISABLE    EQU     0               ; T1004B and later
            839a*FWDT_ENABLE     EQU     1                                                          [Ref*: 840a*]
            840a*FWDT_NORMAL     EQU     FWDT_ENABLE
            841a*
            842a*FRINT_INTERNAL  EQU     0
            843a*FRINT_EXTERNAL  EQU     1                                                          [Ref*: 844a*]
            844a*FRINT_NORMAL    EQU     FRINT_EXTERNAL
            845a   ENDIF
            846a 
            847a 
            848a ;
            849a ; Security word bits (T1006 only).
            850a ;
            851a 
            852a   IF IS_T1006
            853a*SECURITY_ADDR   EQU     $BFF
            854a*
            855a*SWPE            EQU     BIT 4
            856a*SWPS            EQU     BIT 2
            857a*SRUN            EQU     BIT 1

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 13

T1005 standard register definitions


            858a*SP32            EQU     BIT 0
            859a   ENDIF
            860a 
            861a 
            862a ;
            863a ; High-level status flag names.
            864a ;
            865a 
            866a NZ              DEFCONDNAME BITNOT Z
            867a NZL             DEFCONDNAME BITNOT ZL
            868a NC              DEFCONDNAME BITNOT C
            869a NCL             DEFCONDNAME BITNOT CL
            870a NCNZ            DEFCONDNAME BITNOT CNZ
            871a 
            872a BW              DEFCONDNAME NC
            873a NBW             DEFCONDNAME C
            874a BWL             DEFCONDNAME NCL
            875a NBWL            DEFCONDNAME CL
            876a 
            877a BWB             DEFCONDNAME_B NCB
            878a NBWB            DEFCONDNAME_B CB
            879a 
            880a A_EQ_R          DEFCONDNAME Z
            881a R_EQ_A          DEFCONDNAME Z
            882a A_EQ_I          DEFCONDNAME Z
            883a I_EQ_A          DEFCONDNAME Z
            884a 
            885a A_NE_R          DEFCONDNAME NZ
            886a R_NE_A          DEFCONDNAME NZ
            887a A_NE_I          DEFCONDNAME NZ
            888a I_NE_A          DEFCONDNAME NZ
            889a 
            890a A_EQ_RL         DEFCONDNAME ZL
            891a R_EQ_AL         DEFCONDNAME ZL
            892a A_EQ_IL         DEFCONDNAME ZL
            893a I_EQ_AL         DEFCONDNAME ZL
            894a 
            895a A_NE_RL         DEFCONDNAME NZL
            896a R_NE_AL         DEFCONDNAME NZL
            897a A_NE_IL         DEFCONDNAME NZL
            898a I_NE_AL         DEFCONDNAME NZL
            899a 
            900a A_LE_R          DEFCONDNAME C
            901a R_GE_A          DEFCONDNAME C
            902a A_GE_I          DEFCONDNAME C
            903a I_LE_A          DEFCONDNAME C
            904a 
            905a A_GT_R          DEFCONDNAME NC
            906a R_LT_A          DEFCONDNAME NC
            907a A_LT_I          DEFCONDNAME NC
            908a I_GT_A          DEFCONDNAME NC
            909a 
            910a A_LE_RL         DEFCONDNAME CL
            911a R_GE_AL         DEFCONDNAME CL
            912a A_GE_IL         DEFCONDNAME CL
            913a I_LE_AL         DEFCONDNAME CL
            914a 
            915a A_GT_RL         DEFCONDNAME NCL
            916a R_LT_AL         DEFCONDNAME NCL
            917a A_LT_IL         DEFCONDNAME NCL
            918a I_GT_AL         DEFCONDNAME NCL
            919a 
            920a A_LE_RB         DEFCONDNAME_B CB
            921a R_GE_AB         DEFCONDNAME_B CB
            922a A_GE_IB         DEFCONDNAME_B CB
            923a I_LE_AB         DEFCONDNAME_B CB
            924a 
            925a A_GT_RB         DEFCONDNAME_B NCB
            926a R_LT_AB         DEFCONDNAME_B NCB
            927a A_LT_IB         DEFCONDNAME_B NCB
            928a I_GT_AB         DEFCONDNAME_B NCB
            929a 
            930a A_LT_R          DEFCONDNAME CNZ

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 14

T1005 standard register definitions


            931a R_GT_A          DEFCONDNAME CNZ
            932a A_GT_I          DEFCONDNAME CNZ
            933a I_LT_A          DEFCONDNAME CNZ
            934a 
            935a A_GE_R          DEFCONDNAME NCNZ
            936a R_LE_A          DEFCONDNAME NCNZ
            937a A_LE_I          DEFCONDNAME NCNZ
            938a I_GE_A          DEFCONDNAME NCNZ
            939a 
            940a A_LT_RB         DEFCONDNAME_B CNZB
            941a R_GT_AB         DEFCONDNAME_B CNZB
            942a A_GT_IB         DEFCONDNAME_B CNZB
            943a I_LT_AB         DEFCONDNAME_B CNZB
            944a 
            945a A_GE_RB         DEFCONDNAME_B NCNZB
            946a R_LE_AB         DEFCONDNAME_B NCNZB
            947a A_LE_IB         DEFCONDNAME_B NCNZB
            948a I_GE_AB         DEFCONDNAME_B NCNZB
            949a 
            950a SKPCB           TEXTEQU "IFNCB"
            951a SKPNCB          TEXTEQU "IFCB"
            952a SKPCNZB         TEXTEQU "IFNCNZB"
            953a SKPNCNZB        TEXTEQU "IFCNZB"
            954a 
            955a 
            956a ;
            957a ; Useful macros.
            958a ;
            959a 
            960a ; Conditional jumps.
            961a JSET    MACRO   TheBIT:VAL, DEST:VAL
            962a         IFSET   TheBIT
            963a          JMP    DEST
            964a JSET    ENDM
            965a 
            966a JCLR    MACRO   TheBIT:VAL, DEST:VAL
            967a         IFCLR   TheBIT
            968a          JMP    DEST
            969a JCLR    ENDM
            970a 
            971a ; Shifts and rotates.
            972a SHL1    MACRO   TheREG:VAL, TheREG2:VAL:OPT
            973a         IF      EXISTS TheREG2
            974a          ASSERT TheREG == A
            975a          CLRC
            976a          RLC    A, TheREG2
            977a         ELSE
            978a          CLRC
            979a          RLC    TheREG
            980a         ENDIF
            981a SHL1    ENDM
            982a 
            983a SHR1    MACRO   TheREG:VAL, TheREG2:VAL:OPT
            984a         IF      EXISTS TheREG2
            985a          ASSERT TheREG == A
            986a          CLRC
            987a          RRC    A, TheREG2
            988a         ELSE
            989a          CLRC
            990a          RRC    TheREG
            991a         ENDIF
            992a SHR1    ENDM
            993a 
            994a SAR1    MACRO   TheREG:VAL, TheREG2:VAL:OPT
            995a         IF      EXISTS TheREG2
            996a          ASSERT TheREG == A
            997a          ASSERT TheREG2 != A
            998a          RLC    A, TheREG2
            999a          RRC    A, TheREG2
           1000a         ELSE
           1001a          ASSERT TheREG != A
           1002a          RLC    A, TheREG
           1003a          RRC    TheREG

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 15

T1005 standard register definitions


           1004a         ENDIF
           1005a SAR1    ENDM
           1006a 
           1007a ROL     MACRO   TheREG:VAL, TheREG2:VAL:OPT
           1008a         IF      EXISTS TheREG2
           1009a          ASSERT TheREG == A
           1010a          ASSERT TheREG2 != A
           1011a          RLC    A, TheREG2
           1012a          RLC    A, TheREG2
           1013a         ELSE
           1014a          ASSERT TheREG != A
           1015a          RLC    A, TheREG
           1016a          RLC    TheREG
           1017a         ENDIF
           1018a ROL     ENDM
           1019a 
           1020a ROR     MACRO   TheREG:VAL, TheREG2:VAL:OPT
           1021a         IF      EXISTS TheREG2
           1022a          ASSERT TheREG == A
           1023a          ASSERT TheREG2 != A
           1024a          RRC    A, TheREG2
           1025a          RRC    A, TheREG2
           1026a         ELSE
           1027a          ASSERT TheREG != A
           1028a          RRC    A, TheREG
           1029a          RRC    TheREG
           1030a         ENDIF
           1031a ROR     ENDM
           1032a 
           1033a ;
           1034a ; The old-style mutation macro.
           1035a ;
           1036a ; Change A from one 16-bit value to another using a single instruction
           1037a ; if at all possible.
           1038a ;
           1039a 
           1040a MUTATE_A MACRO  FROM:NUM, TO:NUM, MULTI_OK:NUM:=0
           1041a         IF (((TO) AND $FFFF) == ((FROM) AND $FFFF)) && MULTI_OK
           1042a          ; No instruction generated.
           1043a         ELSEIF ((TO) AND $FF00) == $0000
           1044a          MOVN   A, #TO
           1045a         ELSEIF ((TO) AND $FF00) == $FF00
           1046a          MOVN   A, #TO
           1047a         ELSEIF ((TO) AND $00FF) == $0000
           1048a          MOVN   A, #TO
           1049a         ELSEIF ((TO) AND $00FF) == $00FF
           1050a          MOVN   A, #TO
           1051a         ELSEIF (((TO) - (FROM) + $0080) AND $FF00) == $0000
           1052a         ;ELSEIF (TO) - (FROM) <= 127 && (TO) - (FROM) >= -128
           1053a          ADD    A, #(TO) - (FROM)
           1054a          ASSERT post,  [A] == ((TO) AND $FFFF)
           1055a         ELSEIF (((FROM) XOR (TO)) AND $FF00) == $0000
           1056a          XOR    A, #(FROM) XOR (TO)
           1057a          ASSERT post,  [A] == ((TO) AND $FFFF)
           1058a         ELSEIF (((FROM) XOR (TO)) AND $00FF) == $0000
           1059a          XOR    A, #(FROM) XOR (TO)
           1060a          ASSERT post,  [A] == ((TO) AND $FFFF)
           1061a         ELSEIF ((FROM) XOR (TO)) == $FFFF
           1062a          COM    A
           1063a          ASSERT post,  [A] == ((TO) AND $FFFF)
           1064a         ELSEIF (((FROM) SHL 1) AND $FFFF) == ((TO) AND $FFFF)
           1065a          ADD    A, A
           1066a          ASSERT post,  [A] == ((TO) AND $FFFF)
           1067a         ELSEIF (((FROM) SHL 4) AND $FFFF) == ((TO) AND $FFFF)
           1068a          SHL4   A
           1069a          ASSERT post,  [A] == ((TO) AND $FFFF)
           1070a         ELSEIF (((FROM) SHR 4) AND $FFFF) == ((TO) AND $FFFF)
           1071a          SHR4   A
           1072a          ASSERT post,  [A] == ((TO) AND $FFFF)
           1073a         ELSEIF ((FROM) AND $8000) != $0000 &&  \
           1074a                ((((FROM) SHL 1) + (FROM)) AND $FFFF) == ((TO) AND $FFFF)
           1075a          MSTEP  A, A
           1076a          ASSERT post,  [A] == ((TO) AND $FFFF)

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 16

T1005 standard register definitions


           1077a         ELSEIF MULTI_OK
           1078a          MOV    A, #TO
           1079a         ELSE
           1080a          ERROR  "MUTATE_A cannot adjust A in one instruction"
           1081a         ENDIF
           1082a MUTATE_A ENDM
           1083a 
           1084a 
           1085a ;
           1086a ; Helper macros for MUTATE.
           1087a ;
           1088a 
           1089a ; True if X is acceptable as an immediate MOV or AND operand.
           1090a DEFINE _MOV_OK(X:NUM)  ((((X) AND $FF00) == $0000) || (((X) AND $FF00) == $FF00) ||  \
           1091a                         (((X) AND $00FF) == $0000) || (((X) AND $00FF) == $00FF))
           1092a 
           1093a ; True if X is acceptable as an immediate OR or XOR operand.
           1094a DEFINE _OR_OK(X:NUM)   ((((X) AND $FF00) == $0000) || (((X) AND $00FF) == $0000))
           1095a 
           1096a ; True if X is acceptable as an immediate ADD A operand.
           1097a DEFINE _ADD_OK(X:NUM)  ((((X) + $0080) AND $FF00) == $0000)
           1098a 
           1099a ; True if X is an acceptable bitmask for an arithmetic register operand.
           1100a DEFINE _BW_OK(X:NUM)  (((X) == $FFFF) || ((X) == $00FF) || ((X) == $FF00))
           1101a 
           1102a ; Each byte is filled with $FF if that byte has any bits set.
           1103a DEFINE _BYTE_FILL(X:NUM)  ((IF (((X) AND $FF00) != 0) THEN $FF00 ELSE $0000) OR  \
           1104a                            (IF (((X) AND $00FF) != 0) THEN $00FF ELSE $0000))
                                                                                                   [Ref*: 1600a*]
           1105a 
           1106a ; Fill in don't-care bits to try make an efficient MOV operand.
           1107a ; MUST are bits that must be '1'; MAY are bits that may also be '1'.
           1108a DEFINE _MOV_FILL(MUST:NUM,MAY:NUM)  ((MUST) OR (_BYTE_FILL((MUST)) AND (MAY)))
           1109a 
           1110a ; Extract the least significant '1' bit of X.
           1111a DEFINE _LOW_BIT(X:NUM)    ((X) AND -(X))
           1112a 
           1113a ; Return X with its least significant '1' bit changed to '0'.
           1114a DEFINE _OTHER_BITS(X:NUM) ((X) AND ((X)-1))
           1115a 
           1116a ; Extract the most significant '1' bit of X.
           1117a DEFINE _HIGH_BIT(X:NUM)   (1 SHL LOG2((X)))
           1118a 
           1119a ; True if X has exactly two '1' bits.
           1120a DEFINE _TWO_BITS(X:NUM)   PO2(_OTHER_BITS((X)))
           1121a 
           1122a ; True if all '1' bits in X are adjacent.
           1123a DEFINE _ADJACENT_BITS(X:NUM)  ((((X) + _LOW_BIT((X))) AND (X)) == 0)
           1124a 
           1125a ; True if all '1' bits in X are adjacent and include bit 0.
           1126a DEFINE _ADJ_LOW_BITS(X:NUM)  ((((X) + 1) AND (X)) == 0)
           1127a 
           1128a 
           1129a ; Perform MUTATE when the register is A.
           1130a 
           1131a _MUTATE_A MACRO FROM:NUM, FROM_X:NUM, TO:NUM, TO_X:NUM, CHGM:VAL, SINGLE:VAL
           1132a         LOCAL MTEMP, KEEPSYM:FALSE
           1133a 
           1134a         ; Are any instructions needed at all?
           1135a 
           1136a         IF (((TO XOR FROM) OR FROM_X) AND CHGM) == 0 &&  \
           1137a            !SINGLE
           1138a          ; No instruction generated.
           1139a          EXITM
           1140a         ENDIF
           1141a 
           1142a         ; See if a single-instruction MOV will do the trick.
           1143a 
           1144a MTEMP   SET _MOV_FILL(TO, TO_X)
           1145a         IF _MOV_OK(MTEMP) && (CHGM OR TO_X) == $FFFF
           1146a          MOVN A, #MTEMP
           1147a          EXITM
           1148a         ENDIF

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 17

T1005 standard register definitions


           1149a 
           1150a         IF (((TO XOR FROM) OR FROM_X) AND CHGM) == 0
           1151a          ; No instruction generated; let wrapper fill in a NOP if needed.
           1152a          EXITM
           1153a         ENDIF
           1154a 
           1155a         ; Look for a single-instruction idiom to change FROM to TO.
           1156a 
           1157a         IF ((FROM OR TO) AND CHGM) == TO &&  \
           1158a            (FROM_X AND NOT TO AND CHGM) == 0 && _OR_OK(TO)
           1159a          OR A, #TO
           1160a          EXITM
           1161a         ENDIF
           1162a 
           1163a MTEMP   SET TO AND NOT FROM AND CHGM
           1164a         IF ((FROM OR MTEMP) AND CHGM) == TO &&  \
           1165a            (FROM_X AND NOT MTEMP AND CHGM) == 0 &&  \
           1166a            _OR_OK(MTEMP)
           1167a          OR A, #MTEMP
           1168a          EXITM
           1169a         ENDIF
           1170a 
           1171a         IF (FROM AND TO AND CHGM) == TO &&  \
           1172a            (FROM_X AND TO AND CHGM) == 0 && _MOV_OK(TO OR NOT CHGM)
           1173a          AND A, #TO OR NOT CHGM
           1174a          EXITM
           1175a         ENDIF
           1176a 
           1177a MTEMP   SET _MOV_FILL((TO OR NOT (FROM OR FROM_X) OR NOT CHGM) AND $FFFF, TO_X)
           1178a         IF ((FROM AND MTEMP) AND CHGM) == TO &&  \
           1179a            (FROM_X AND MTEMP AND CHGM) == 0 &&  \
           1180a            _MOV_OK(MTEMP)
           1181a          AND A, #MTEMP
           1182a          EXITM
           1183a         ENDIF
           1184a 
           1185a         IF (FROM_X AND CHGM) == 0 &&  \
           1186a            _OR_OK((FROM XOR TO) AND CHGM)
           1187a          XOR A, #(FROM XOR TO) AND CHGM
           1188a          EXITM
           1189a         ENDIF
           1190a 
           1191a         IF _ADD_OK(TO - (FROM AND CHGM)) &&  \
           1192a            (FROM_X AND CHGM) == 0
           1193a          ADD A, #TO - (FROM AND CHGM)
           1194a          EXITM
           1195a         ENDIF
           1196a 
           1197a         IF ((FROM XOR $FFFF) AND CHGM) == TO &&  \
           1198a            (FROM_X AND CHGM) == 0 &&  \
           1199a            (CHGM OR TO_X) == $FFFF
           1200a          COM A
           1201a          EXITM
           1202a         ENDIF
           1203a 
           1204a         IF ((FROM SHL 1) AND $FFFF AND CHGM) == TO &&  \
           1205a            ((FROM_X SHL 1) AND $FFFF AND CHGM) == 0 &&  \
           1206a            (CHGM OR TO_X) == $FFFF
           1207a          ADD A, A
           1208a          EXITM
           1209a         ENDIF
           1210a 
           1211a         IF ((FROM SHL 4) AND $FFFF AND CHGM) == TO &&  \
           1212a            ((FROM_X SHL 4) AND $FFFF AND CHGM) == 0 &&  \
           1213a            (CHGM OR TO_X) == $FFFF
           1214a          SHL4 A
           1215a          EXITM
           1216a         ENDIF
           1217a 
           1218a         IF ((FROM SHR 4) AND CHGM) == TO &&  \
           1219a            ((FROM_X SHR 4) AND CHGM) == 0 &&  \
           1220a            (CHGM OR TO_X) == $FFFF
           1221a          SHR4 A

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 18

T1005 standard register definitions


           1222a          EXITM
           1223a         ENDIF
           1224a 
           1225a         IF (((FROM AND $00FF) * $0101) AND CHGM) == TO &&  \
           1226a            (((FROM_X AND $00FF) * $0101) AND CHGM) == 0 &&  \
           1227a            (CHGM OR TO_X) == $FFFF
           1228a          MOV HIGH A, A
           1229a          EXITM
           1230a         ENDIF
           1231a 
           1232a         IF (((FROM SHR 8) * $0101) AND CHGM) == TO &&  \
           1233a            (((FROM_X SHR 8) * $0101) AND CHGM) == 0 &&  \
           1234a            (CHGM OR TO_X) == $FFFF
           1235a          ASSERT [NOSAFE]
           1236a          MOV A, HIGH A
           1237a          EXITM
           1238a         ENDIF
           1239a 
           1240a         IF (FROM AND $8000) != $0000 &&  \
           1241a            (((FROM SHL 1) + FROM) AND $FFFF) == TO &&  \
           1242a            FROM_X == 0 && (CHGM OR TO_X) == $FFFF
           1243a          MSTEP A, A
           1244a          EXITM
           1245a         ENDIF
           1246a 
           1247a         ; Look for two-instruction idioms.
           1248a 
           1249a         IF (CHGM OR TO_X) == $FFFF
           1250a          MOV A, #TO
           1251a          EXITM
           1252a         ENDIF
           1253a 
           1254a         IF ((FROM OR TO) AND CHGM) == TO &&  \
           1255a            (FROM_X AND NOT TO AND CHGM) == 0
           1256a          OR A, #TO
           1257a          EXITM
           1258a         ENDIF
           1259a 
           1260a         IF (FROM AND TO AND CHGM) == TO &&  \
           1261a            (FROM_X AND TO AND CHGM) == 0
           1262a          AND A, #TO OR NOT CHGM
           1263a          EXITM
           1264a         ENDIF
           1265a 
           1266a         IF (FROM_X AND CHGM) == 0
           1267a          XOR A, #(FROM XOR TO) AND CHGM
           1268a          EXITM
           1269a         ENDIF
           1270a 
           1271a         ; Fall back on the most general case.
           1272a 
           1273a          AND A, #_MOV_FILL((TO OR NOT (FROM OR FROM_X) OR NOT CHGM) AND $FFFF,  \
           1274a                            TO_X OR (TO AND NOT FROM AND CHGM))
           1275a          OR A, #TO AND NOT FROM AND CHGM
           1276a 
           1277a _MUTATE_A ENDM
           1278a 
           1279a 
           1280a _MUTATE_R_GEN MACRO R:VAL, FROM:NUM, FROM_X:NUM, TO:NUM, TO_X:NUM, CHGM:VAL, SIMUL:VAL, USING:V\
AL
           1281a 
           1282a         LOCAL CLRM, SETM, WCLRM, KEEPSYM:FALSE
           1283a 
           1284a CLRM    SET (FROM OR FROM_X) AND NOT TO AND CHGM
           1285a SETM    SET TO AND NOT FROM
           1286a WCLRM   SET _MOV_FILL(CLRM, CHGM OR TO_X)
           1287a 
           1288a         IF CLRM == 0
           1289a          ; Nothing to clear!
           1290a         ELSEIF _BW_OK(WCLRM) &&  \
           1291a                (USING == A ||  \
           1292a                 1 + POPCOUNT(SETM OR (TO AND WCLRM)) <=  \
           1293a                 POPCOUNT(CLRM) + POPCOUNT(SETM))

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 19

T1005 standard register definitions


           1294a          CLR R BITS WCLRM
           1295a SETM     SET SETM OR (TO AND WCLRM)
           1296a         ELSEIF PO2(CLRM) || (_TWO_BITS(CLRM) || USING != A) && !SIMUL
           1297a NUM      REPEAT 16
           1298a           IF (CLRM AND (1 SHL NUM)) != 0
           1299a          BCLR R BIT NUM
           1300a           ENDIF
           1301a          ENDM
           1302a         ELSE
           1303a          ASSERT USING == A, MSG: "MUTATE cannot adjust register without USING:A"
           1304a          MOV A, #NOT WCLRM
           1305a          AND R, A
           1306a SETM     SET SETM OR (TO AND WCLRM)
           1307a         ENDIF
           1308a 
           1309a         IF SETM == 0
           1310a          ; Nothing to set!
           1311a         ELSEIF PO2(SETM) || (_TWO_BITS(SETM) || USING != A) && !SIMUL
           1312a NUM      REPEAT 16
           1313a           IF (SETM AND (1 SHL NUM)) != 0
           1314a          BSET R BIT NUM
           1315a           ENDIF
           1316a          ENDM
           1317a         ELSE
           1318a          ASSERT USING == A, MSG: "MUTATE cannot adjust register without USING:A"
           1319a          MOV A, #SETM
           1320a          OR R, A
           1321a         ENDIF
           1322a 
           1323a _MUTATE_R_GEN ENDM
           1324a 
           1325a 
           1326a _MUTATE_R_COM MACRO R:VAL, FROM:NUM, FROM_X:NUM, TO:NUM, TO_X:NUM, CHGM:VAL, SIMUL:VAL, USING:V\
AL
           1327a 
           1328a         LOCAL LIMIT, WCOMM, KEEPSYM:FALSE
           1329a 
           1330a LIMIT   EQU IF USING == A THEN 2 ELSE 100
           1331a WCOMM   EQU (IF ((POPCOUNT((FROM OR FROM_X) AND NOT TO AND CHGM AND $00FF) MIN LIMIT) +  \
           1332a                  (POPCOUNT(TO AND NOT FROM AND CHGM AND $00FF) MIN LIMIT) >  \
           1333a                  1 + (POPCOUNT((NOT FROM OR FROM_X) AND NOT TO AND CHGM AND $00FF) MIN LIMIT) +\
  \
           1334a                      (POPCOUNT(TO AND FROM AND CHGM AND $00FF) MIN LIMIT) THEN $00FF ELSE $0000\
) OR \
           1335a              IF ((POPCOUNT((FROM OR FROM_X) AND NOT TO AND CHGM AND $FF00) MIN LIMIT) +  \
           1336a                  (POPCOUNT(TO AND NOT FROM AND CHGM AND $FF00) MIN LIMIT) >  \
           1337a                  1 + (POPCOUNT((NOT FROM OR FROM_X) AND NOT TO AND CHGM AND $FF00) MIN LIMIT) +\
  \
           1338a                      (POPCOUNT(TO AND FROM AND CHGM AND $FF00) MIN LIMIT) THEN $FF00 ELSE $0000\
)) AND  \
           1339a             (CHGM OR TO_X)
           1340a         IF _BW_OK(WCOMM)
           1341a          COM R BITS WCOMM
           1342a          _MUTATE_R_GEN R, FROM XOR (WCOMM AND NOT FROM_X), FROM_X,  \
           1343a                        TO, TO_X, CHGM, SIMUL, USING
           1344a          EXITM
           1345a         ENDIF
           1346a 
           1347a         _MUTATE_R_GEN R, FROM, FROM_X, TO, TO_X, CHGM, SIMUL, USING
           1348a 
           1349a _MUTATE_R_COM ENDM
           1350a 
           1351a 
           1352a _MUTATE_R MACRO R:VAL, FROM:NUM, FROM_X:NUM, TO:NUM, TO_X:NUM, CHGM:VAL, SIMUL:VAL, USING:VAL
           1353a 
           1354a         LOCAL CLRM, SETM, WCHGM, MTEMP, KEEPSYM:FALSE
           1355a CLRM    SET (FROM OR FROM_X) AND NOT TO AND CHGM
           1356a SETM    SET TO AND NOT FROM
           1357a WCHGM   SET _MOV_FILL(CHGM, TO_X)
           1358a 
           1359a         IF SETM == 0 && CLRM == 0
           1360a          ; Nothing to do!
           1361a          EXITM

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 20

T1005 standard register definitions


           1362a         ENDIF
           1363a 
           1364a         ; Take care of the one-instruction cases first.
           1365a 
           1366a         IF PO2(SETM) && CLRM == 0
           1367a          BSET R BITS SETM
           1368a          EXITM
           1369a         ENDIF
           1370a 
           1371a         IF PO2(CLRM) && SETM == 0
           1372a          BCLR R BITS CLRM
           1373a          EXITM
           1374a         ENDIF
           1375a 
           1376a MTEMP   SET _MOV_FILL(CLRM, TO_X OR (CHGM AND NOT TO) OR SETM)
           1377a         IF _BW_OK(MTEMP) && SETM == 0
           1378a          CLR R BITS MTEMP
           1379a          EXITM
           1380a         ENDIF
           1381a 
           1382a         IF _BW_OK(WCHGM)
           1383a 
           1384a          IF (((FROM XOR $FFFF) XOR TO) AND NOT TO_X) == 0 &&  \
           1385a             (FROM_X AND CHGM) == 0
           1386a          COM R BITS WCHGM
           1387a          EXITM
           1388a          ENDIF
           1389a 
           1390a          IF (((FROM - 1) XOR TO) AND NOT TO_X AND $FFFF) == 0 &&  \
           1391a             FROM_X == 0
           1392a          DEC R BITS WCHGM
           1393a          EXITM
           1394a          ENDIF
           1395a 
           1396a          IF (((FROM + 1) XOR TO) AND NOT TO_X AND $FFFF) == 0 &&  \
           1397a             FROM_X == 0
           1398a          INC R BITS WCHGM
           1399a          EXITM
           1400a          ENDIF
           1401a 
           1402a          IF (((FROM - $100) XOR TO) AND NOT TO_X AND $FFFF) == 0 &&  \
           1403a             FROM_X == 0
           1404a          DEC HIGH R
           1405a          EXITM
           1406a          ENDIF
           1407a 
           1408a          IF (((FROM + $100) XOR TO) AND NOT TO_X AND $FFFF) == 0 &&  \
           1409a             FROM_X == 0
           1410a          INC HIGH R
           1411a          EXITM
           1412a          ENDIF
           1413a 
           1414a         ENDIF
           1415a 
           1416a         IF WCHGM == $FFFF
           1417a 
           1418a          IF (((FROM SHL 4) XOR TO) AND NOT TO_X AND $FFFF) == 0 &&  \
           1419a             ((FROM_X SHL 4) AND CHGM) == 0
           1420a          SHL4 R
           1421a          EXITM
           1422a          ENDIF
           1423a 
           1424a          IF (((FROM SHR 4) XOR TO) AND NOT TO_X AND $FFFF) == 0 &&  \
           1425a             ((FROM_X SHR 4) AND CHGM) == 0
           1426a          SHR4 R
           1427a          EXITM
           1428a          ENDIF
           1429a 
           1430a         ENDIF
           1431a 
           1432a         ; Otherwise, look for a two-instruction idiom.
           1433a 
           1434a MTEMP   SET _MOV_FILL(TO, TO_X)

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 21

T1005 standard register definitions


           1435a         IF _BW_OK(WCHGM) && USING == A && _MOV_OK(MTEMP)
           1436a          MOV A, #MTEMP / _LOW_BIT(WCHGM)
           1437a          MOV R BITS WCHGM, A
           1438a          EXITM
           1439a         ENDIF
           1440a 
           1441a         IF (_TWO_BITS(SETM OR CLRM) ||  \
           1442a             (_BW_OK(WCHGM) &&  \
           1443a              (PO2(TO)))) &&  \
           1444a            !SIMUL
           1445a          _MUTATE_R_GEN R, FROM, FROM_X, TO, TO_X, CHGM, SIMUL, RESET_REG
           1446a          EXITM
           1447a         ENDIF
           1448a 
           1449a MTEMP   SET _MOV_FILL((FROM XOR TO) AND CHGM, TO_X)
           1450a         IF (FROM_X AND CHGM) == 0 && USING == A && _MOV_OK(MTEMP)
           1451a          MOV A, #MTEMP
           1452a          XOR R, A
           1453a          EXITM
           1454a         ENDIF
           1455a 
           1456a MTEMP   SET TO - (FROM AND CHGM)
           1457a         IF (FROM_X AND CHGM) == 0 && USING == A && _MOV_OK(MTEMP)
           1458a          MOV A, #MTEMP
           1459a          ADD R, A
           1460a          EXITM
           1461a         ENDIF
           1462a 
           1463a         ; Look for some common three-instruction idioms.
           1464a 
           1465a MTEMP   SET _MOV_FILL(TO, TO_X)
           1466a         IF WCHGM == $FFFF && USING == A
           1467a          MOV A, #MTEMP
           1468a          MOV R BITS WCHGM, A
           1469a          EXITM
           1470a         ENDIF
           1471a 
           1472a MTEMP   SET _MOV_FILL((FROM XOR TO) AND CHGM, TO_X)
           1473a         IF (FROM_X AND CHGM) == 0 && USING == A
           1474a          MOV A, #MTEMP
           1475a          XOR R, A
           1476a          EXITM
           1477a         ENDIF
           1478a 
           1479a         IF CLRM != 0 && SETM != 0 && SIMUL
           1480a          ASSERT USING == A, MSG: "MUTATE cannot adjust register without USING:A"
           1481a MTEMP    SET _MOV_FILL(((FROM XOR TO) OR FROM_X) AND CHGM, CHGM OR TO_X)
           1482a          MOV A, #_MOV_FILL(TO AND MTEMP, CHGM OR TO_X OR NOT MTEMP)
           1483a          XOR A, R
           1484a          AND A, #MTEMP
           1485a          XOR R, A
           1486a          EXITM
           1487a         ENDIF
           1488a 
           1489a         ; FIXME: This picks an inefficient method in quite a few cases.
           1490a         ; Is there an efficient way to pick the truly optimal solution?
           1491a 
           1492a MTEMP   SET NOT _BYTE_FILL(NOT CHGM) AND $FFFF
           1493a MTEMP   SET _MOV_FILL(MTEMP, TO_X)
           1494a         IF POPCOUNT(FROM_X AND MTEMP) > 1 && _BW_OK(MTEMP)
           1495a          CLR R BITS MTEMP
           1496a          _MUTATE_R_COM R, FROM AND NOT MTEMP, FROM_X AND NOT MTEMP,  \
           1497a                        TO, TO_X, CHGM, SIMUL, USING
           1498a          EXITM
           1499a         ENDIF
           1500a 
           1501a         _MUTATE_R_COM R, FROM, FROM_X, TO, TO_X, CHGM, SIMUL, USING
           1502a 
           1503a _MUTATE_R ENDM
           1504a 
           1505a 
           1506a ; Perform MUTATE when the register is X.
           1507a 

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 22

T1005 standard register definitions


           1508a _MUTATE_X MACRO FROM:NUM, FROM_X:NUM, TO:NUM, TO_X:NUM, CHGM:VAL, SINGLE:VAL, SIMUL:VAL, USING:\
VAL
           1509a 
           1510a         IF (((FROM XOR TO) OR FROM_X) AND CHGM) == 0 && !SINGLE
           1511a          ; Nothing to do!
           1512a          EXITM
           1513a         ENDIF
           1514a 
           1515a         IF (CHGM OR TO_X) == $FFFF
           1516a          MOV X, #TO AND $FF
           1517a          EXITM
           1518a         ENDIF
           1519a 
           1520a         IF PO2((FROM XOR TO) AND CHGM) &&  \
           1521a            (FROM_X AND CHGM) == 0
           1522a          IF ((TO AND NOT FROM) AND CHGM) != 0
           1523a          BSET X BITS ((FROM XOR TO) AND CHGM)
           1524a          ELSE
           1525a          BCLR X BITS ((FROM XOR TO) AND CHGM)
           1526a          ENDIF
           1527a          EXITM
           1528a         ENDIF
           1529a 
           1530a         IF (FROM_X AND CHGM) == 0 &&  \
           1531a            ((TO - (FROM AND CHGM)) AND $FF) != 0
           1532a          ADD X, #(TO - (FROM AND CHGM)) AND $FF
           1533a          EXITM
           1534a         ENDIF
           1535a 
           1536a         ; Otherwise treat it as a general-case adjustment to STATX.
           1537a 
           1538a         _MUTATE_R STATX, FROM, FROM_X, TO, TO_X, CHGM, SIMUL, USING
           1539a 
           1540a _MUTATE_X ENDM
           1541a 
           1542a 
           1543a ;
           1544a ; The general-purpose MUTATE macro.
           1545a ;
           1546a ; R specifies any register word, byte, bit, or bit-field.
           1547a ;
           1548a ; FROM specifies the known previous contents of the register.
           1549a ; FROM can be an ALT range to say that certain bits are unknown,
           1550a ; or FROM can be omitted if the previous contents are completely unknown.
           1551a ;
           1552a ; TO specifies the desired new contents of the register.
           1553a ; TO can be an ALT range to say that certain bits are don't-cares.
           1554a ;
           1555a ; MASK specifies which bits of R are significant.
           1556a ; A MASK bit of '0' means the bit of R must be preserved.
           1557a ; An unknown bit of MASK (using an ALT range) means the bit of R
           1558a ; is a don't-care; this is equivalent to using an unknown bit of TO.
           1559a ; If MASK is omitted, all bits of R are considered significant.
           1560a ;
           1561a ; The FROM, TO, and MASK values are interpreted relative to the
           1562a ; bit-field R; in "MUTATE HIGH R, ..." they would range from 0 to 255.
           1563a ;
           1564a ; If SINGLE is true, MUTATE must generate exactly one instruction.
           1565a ;
           1566a ; If MAX is specified, it is the maximum number of instructions that
           1567a ; MUTATE is allowed to generate.  The default is 4; if you need to
           1568a ; specify more, consider specifying USING:A instead.
           1569a ;
           1570a ; If SIMUL is true, MUTATE must write R in just one instruction.
           1571a ;
           1572a ; If USING:A is specified, then MUTATE is allowed to use A as
           1573a ; a scratch register.
           1574a ;
           1575a 
           1576a   if defined _ASM_CHASM
           1577a*
           1578a*  ;; Chasm doesn't yet support the NAMED option...
           1579a*

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 23

T1005 standard register definitions


           1580a*MUTATE MACRO R:VAL, FROM:VAL:NAMED:POS:=0, TO:NAMED:VAL:POS,  \
           1581a*             TheMask:NAMED:VAL:=-1, XBYTE:NAMED:BOOL, XWORD:NAMED:BOOL,  \
           1582a*             XALLOC:NAMED:BOOL, SINGLE:NAMED:BOOL, TheMax:NAMED:NUM:=4,  \
           1583a*             SIMUL:NAMED:BOOL, USING:NAMED:VAL:=RESET_REG
           1584a*
           1585a*        LOCAL WR, FROMVAL, FROM_X, TOVAL, TO_X, CHGM, XMASK, START, KEEPSYM:FALSE
           1586a*WR      SET R                              [Ref*: 1585a* 1588a* 1592a* 1592a* 1598a* 1600a* ...]
           1587a*        IF IS BITNOT R
           1588a*WR      SET BITNOT WR                      [Ref*: 1585a* 1588a* 1592a* 1592a* 1598a* 1600a* ...]
           1589a*        ENDIF
           1590a*        IF EXISTS FROM
           1591a*FROMVAL  EQU BITBASE(R, ALTBASE FROM)      [Ref*: 1585a* 1622a* 1622a* 1629a* 1629a* 1635a* ...]
           1592a*FROM_X   EQU BITBASE(WR, ALTSPAN FROM) OR (BITMASK WR XOR $FFFF)
                                                            [Ref*: 1585a* 1622a* 1622a* 1629a* 1629a* 1635a* ...]
           1593a*        ELSE
           1594a*FROMVAL  EQU $0000                         [Ref*: 1585a* 1622a* 1622a* 1629a* 1629a* 1635a* ...]
           1595a*FROM_X   EQU $FFFF                         [Ref*: 1585a* 1622a* 1622a* 1629a* 1629a* 1635a* ...]
           1596a*        ENDIF
           1597a*        IF XWORD
           1598a*XMASK    SET $FFFF AND NOT BITMASK WR          [Ref*: 1585a* 1605a* 1608a* 1609a* 1611a* 1612a*]
           1599a*        ELSEIF XBYTE
           1600a*XMASK    SET _BYTE_FILL(BITMASK WR) AND NOT BITMASK WR
                                                                [Ref*: 1585a* 1605a* 1608a* 1609a* 1611a* 1612a*]
           1601a*        ELSE
           1602a*XMASK    SET 0                                 [Ref*: 1585a* 1605a* 1608a* 1609a* 1611a* 1612a*]
           1603a*        ENDIF
           1604a*        IF XALLOC
           1605a*XMASK   SET XMASK OR (BITMASK WR AND NOT ALLOCMASK WR)
                                                                [Ref*: 1585a* 1605a* 1608a* 1609a* 1611a* 1612a*]
           1606a*        ENDIF
           1607a*        IF EXISTS TheMask
           1608a*CHGM     EQU BITBASE(WR, ALTBASE TheMask AND NOT ALTSPAN TO) AND NOT XMASK
                                                            [Ref*: 1585a* 1614a* 1622a* 1622a* 1624a* 1629a* ...]
           1609a*TO_X     EQU BITBASE(WR, ALTSPAN TheMask OR ALTSPAN TO) OR XMASK
                                                            [Ref*: 1585a* 1622a* 1622a* 1622a* 1629a* 1629a* ...]
           1610a*        ELSE
           1611a*CHGM     EQU BITMASK WR AND NOT BITBASE(WR, ALTSPAN TO) AND NOT XMASK
                                                            [Ref*: 1585a* 1614a* 1622a* 1622a* 1624a* 1629a* ...]
           1612a*TO_X     EQU BITBASE(WR, ALTSPAN TO) OR XMASK
                                                            [Ref*: 1585a* 1622a* 1622a* 1622a* 1629a* 1629a* ...]
           1613a*        ENDIF
           1614a*TOVAL   EQU BITBASE(R, ALTBASE TO) AND CHGM           [Ref*: 1585a* 1622a* 1629a* 1635a* 1651a*]
           1615a*WR      SET WORD WR                        [Ref*: 1585a* 1588a* 1592a* 1592a* 1598a* 1600a* ...]
           1616a*
           1617a*START:                                                [Ref*: 1585a* 1638a* 1639a* 1646a* 1650a*]
           1618a*        IF WR == A
           1619a*         _MUTATE_A FROMVAL, FROM_X,  \
           1620a*                   TOVAL OR (FROMVAL AND NOT CHGM AND NOT TO_X), TO_X,  \
           1621a*                   CHGM OR (NOT FROM_X AND NOT TO_X AND $FFFF),  \
           1622a*                   SINGLE
           1623a*
           1624a*        ELSEIF WR == STATX && (CHGM AND $FF00) == $0000
           1625a*         _MUTATE_X FROMVAL, FROM_X,  \
           1626a*                   TOVAL OR (FROMVAL AND NOT CHGM AND NOT TO_X AND $00FF),  \
           1627a*                   TO_X OR $FF00,  \
           1628a*                   CHGM OR (NOT FROM_X AND NOT TO_X AND $00FF),  \
           1629a*                   SINGLE, SIMUL, USING
           1630a*
           1631a*        ELSE
           1632a*         _MUTATE_R WR, FROMVAL, FROM_X,  \
           1633a*                   TOVAL OR (FROMVAL AND NOT CHGM AND NOT TO_X), TO_X,  \
           1634a*                   CHGM OR (NOT FROM_X AND NOT TO_X AND $FFFF),  \
           1635a*                   SIMUL, USING
           1636a*        ENDIF
           1637a*
           1638a*        IF SINGLE && _ASM_ADDRESS != START+1
           1639a*         IF _ASM_ADDRESS != START
           1640a*          ERROR "MUTATE cannot adjust register in one instruction"
           1641a*         ELSE
           1642a*          NOP
           1643a*         ENDIF
           1644a*        ENDIF
           1645a*

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 24

T1005 standard register definitions


           1646a*        IF _ASM_ADDRESS - START > TheMax
           1647a*         ERROR "MUTATE cannot adjust register in " ++ STRING(TheMax) ++ " instructions"
           1648a*        ENDIF
           1649a*
           1650a*        IF _ASM_ADDRESS > START && CHGM != 0
           1651a*         ASSERT post, ([WR] AND CHGM) == TOVAL
           1652a*        ENDIF
           1653a*
           1654a*;       UNDEF START    ; Avoid cluttering hex file with labels.
           1655a*
           1656a*MUTATE ENDM
           1657a*
           1658a   else !defined _ASM_CHASM
           1659a 
           1660a MUTATE MACRO R:VAL, FROM:VAL:NAMED:POS:=0, TO:NAMED:VAL:POS,  \
           1661a              TheMASK:NAMED(MASK):VAL:=-1, XBYTE:NAMED:BOOL, XWORD:NAMED:BOOL,  \
           1662a              XALLOC:NAMED:BOOL, SINGLE:NAMED:BOOL, TheMAX:NAMED(MAX):NUM:=4,  \
           1663a              SIMUL:NAMED:BOOL, USING:NAMED:VAL:=RESET_REG
           1664a 
           1665a         LOCAL WR, FROMVAL, FROM_X, TOVAL, TO_X, CHGM, XMASK, START, KEEPSYM:FALSE
           1666a WR      SET R
           1667a         IF IS BITNOT R
           1668a WR      SET BITNOT WR
           1669a         ENDIF
           1670a         IF EXISTS FROM
           1671a FROMVAL  EQU BITBASE(R, ALTBASE FROM)
           1672a FROM_X   EQU BITBASE(WR, ALTSPAN FROM) OR (BITMASK WR XOR $FFFF)
           1673a         ELSE
           1674a FROMVAL  EQU $0000
           1675a FROM_X   EQU $FFFF
           1676a         ENDIF
           1677a         IF XWORD
           1678a XMASK    SET $FFFF AND NOT BITMASK WR
           1679a         ELSEIF XBYTE
           1680a XMASK    SET _BYTE_FILL(BITMASK WR) AND NOT BITMASK WR
           1681a         ELSE
           1682a XMASK    SET 0
           1683a         ENDIF
           1684a         IF XALLOC
           1685a XMASK   SET XMASK OR (BITMASK WR AND NOT ALLOCMASK WR)
           1686a         ENDIF
           1687a         IF EXISTS TheMASK
           1688a CHGM     EQU BITBASE(WR, ALTBASE TheMASK AND NOT ALTSPAN TO) AND NOT XMASK
           1689a TO_X     EQU BITBASE(WR, ALTSPAN TheMASK OR ALTSPAN TO) OR XMASK
           1690a         ELSE
           1691a CHGM     EQU BITMASK WR AND NOT BITBASE(WR, ALTSPAN TO) AND NOT XMASK
           1692a TO_X     EQU BITBASE(WR, ALTSPAN TO) OR XMASK
           1693a         ENDIF
           1694a TOVAL   EQU BITBASE(R, ALTBASE TO) AND CHGM
           1695a WR      SET WORD WR
           1696a 
           1697a START:
           1698a         IF WR == A
           1699a          _MUTATE_A FROMVAL, FROM_X,  \
           1700a                    TOVAL OR (FROMVAL AND NOT CHGM AND NOT TO_X), TO_X,  \
           1701a                    CHGM OR (NOT FROM_X AND NOT TO_X AND $FFFF),  \
           1702a                    SINGLE
           1703a 
           1704a         ELSEIF WR == STATX && (CHGM AND $FF00) == $0000
           1705a          _MUTATE_X FROMVAL, FROM_X,  \
           1706a                    TOVAL OR (FROMVAL AND NOT CHGM AND NOT TO_X AND $00FF),  \
           1707a                    TO_X OR $FF00,  \
           1708a                    CHGM OR (NOT FROM_X AND NOT TO_X AND $00FF),  \
           1709a                    SINGLE, SIMUL, USING
           1710a 
           1711a         ELSE
           1712a          _MUTATE_R WR, FROMVAL, FROM_X,  \
           1713a                    TOVAL OR (FROMVAL AND NOT CHGM AND NOT TO_X), TO_X,  \
           1714a                    CHGM OR (NOT FROM_X AND NOT TO_X AND $FFFF),  \
           1715a                    SIMUL, USING
           1716a         ENDIF
           1717a 
           1718a         IF SINGLE && _ASM_ADDRESS != START+1

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 25

T1005 standard register definitions


           1719a          IF _ASM_ADDRESS != START
           1720a           ERROR "MUTATE cannot adjust register in one instruction"
           1721a          ELSE
           1722a           NOP
           1723a          ENDIF
           1724a         ENDIF
           1725a 
           1726a         IF _ASM_ADDRESS - START > TheMAX
           1727a          ERROR "MUTATE cannot adjust register in " ++ STRING(TheMAX) ++ " instructions"
           1728a         ENDIF
           1729a 
           1730a         IF _ASM_ADDRESS > START && CHGM != 0
           1731a          ASSERT post, ([WR] AND CHGM) == TOVAL
           1732a         ENDIF
           1733a 
           1734a ;       UNDEF START    ; Avoid cluttering hex file with labels.
           1735a 
           1736a MUTATE ENDM
           1737a 
           1738a   endif ; defined _ASM_CHASM
           1739a 
           1740a 
           1741a ;
           1742a ; Determine whether MUTATE_A would generate exactly one instruction
           1743a ; for given FROM and TO values.
           1744a ;
           1745a 
           1746a DEFINE MUTABLE_A(FROM:VAL,TO:VAL)  (  \
           1747a         _MOV_OK(TO) ||  \
           1748a         _ADD_OK((TO) - (FROM)) ||  \
           1749a         _OR_OK((FROM) XOR (TO)) ||  \
           1750a         ((FROM) XOR (TO)) == $FFFF ||  \
           1751a         (((FROM) SHL 1) AND $FFFF) == ((TO) AND $FFFF) ||  \
           1752a         (((FROM) SHL 4) AND $FFFF) == ((TO) AND $FFFF) ||  \
           1753a         (((FROM) SHR 4) AND $FFFF) == ((TO) AND $FFFF) ||  \
           1754a         ((FROM) AND $8000) != $0000 &&  \
           1755a               ((((FROM) SHL 1) + (FROM)) AND $FFFF) == ((TO) AND $FFFF)  \
           1756a )
           1757a 
           1758a 
           1759a ;
           1760a ; Determine whether MUTATE would generate exactly one instruction.
           1761a ; This doesn't catch all the cases, but it does catch many common
           1762a ; ones.  At present, options such as MASK are not supported.
           1763a ;
           1764a 
           1765a DEFINE MUTABLE(R:VAL,FROM:VAL,TO:VAL)  (  \
           1766a         ALTSPAN (TO) == 0 &&  \
           1767a         (((R) == A && MUTABLE_A((FROM),(TO))) ||  \
           1768a          ((R) == X) ||  \
           1769a          IS BIT (R) || PO2((TO) XOR (FROM)) ||  \
           1770a          ((IS WORD (R) || IS BYTE (R)) && (TO) == 0))  \
           1771a )
           1772a 
           1773a 
           1774a ; Change the bank if necessary, or not if two registers lie in the
           1775a ; same bank.
           1776a MBANK   MACRO   FROM:REQ, TO:REQ
           1777a         IF VAL ALTSPAN(TO) != 0
           1778a          IF VAL ALTSPAN(FROM) != VAL ALTSPAN(TO)
           1779a           ERROR "MBANK: Invalid ALT argument"
           1780a          ELSE
           1781a           ASSERT ([X] AND NOT ALTSPAN(FROM)) ==  \
           1782a                  (VAL ALTBASE(FROM) AND ($100 - RAM_BANK_SIZE))
           1783a           IF ((VAL ALTBASE(FROM) AND ($100 - RAM_BANK_SIZE)) !=  \
           1784a               (VAL ALTBASE(TO) AND ($100 - RAM_BANK_SIZE)))
           1785a            ADD  X, #((ALTBASE(TO) AND ($100 - RAM_BANK_SIZE)) -  \
           1786a                      (ALTBASE(FROM) AND ($100 - RAM_BANK_SIZE))) AND $FF
           1787a           ENDIF
           1788a          ENDIF
           1789a         ELSE
           1790a          IF VAL ALTSPAN(FROM) != 0
           1791a           BANK  (TO)

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 26

T1005 standard register definitions


           1792a          ELSEIF (VAL(FROM) AND ($100 - RAM_BANK_SIZE)) !=  \
           1793a                 (VAL(TO) AND ($100 - RAM_BANK_SIZE))
           1794a           BANK  (TO)
           1795a          ELSE
           1796a           ASSERT [X] == (VAL(FROM) AND ($100 - RAM_BANK_SIZE))
           1797a          ENDIF
           1798a         ENDIF
           1799a MBANK   ENDM
           1800a 
           1801a 
           1802a ;
           1803a ; Allocation options for ALLOC and ALLOCVAR.
           1804a ;
           1805a 
           1806a ANY_DIRECT      TEXTEQU "_PROC_FIRSTRAM:(REG _PROC_BANKSIZE - 1)"
           1807a ANY_NONDIRECT   TEXTEQU "REG _PROC_BANKSIZE:_PROC_LASTRAM"
           1808a 
           1809a ANY_RAM_UP      TEXTEQU "_PROC_FIRSTRAM:_PROC_LASTRAM"
           1810a ANY_RAM_DOWN    TEXTEQU "_PROC_LASTRAM:_PROC_FIRSTRAM"
           1811a ANY_PERTHREAD   TEXTEQU "PERTHREAD"
           1812a ANY_LINK        TEXTEQU "TRYLINK"
           1813a 
           1814a         DEFINE ANY_BANK(X:VAL) ((ALIAS REG BANK(X) MAX _PROC_FIRSTRAM) BITS (X)) :  \
           1815a                                (((ALIAS REG BANK(X) + _PROC_BANKSIZE-1) MIN _PROC_LASTRAM) BITS\
 (X))
           1816a 
           1817a 
           1818a ;
           1819a ; Pseudo-registers for simulation.
           1820a ;
           1821a ; These are supported by both the Verilog functional models (simstuff.v)
           1822a ; and the firmware simulator (simt4).
           1823a ;
           1824a 
           1825a   IFNDEF NO_SIM_FEATURES
           1826a 
00F2       1827a SIMEXTPDIR      EQU     REG $F2
00F3       1828a SIMEXTPOUT      EQU     REG $F3
00F7       1829a SIMMAP          EQU     REG $F7
00FA       1830a SIMARG          EQU     REG $FA
00FB       1831a SIMCTL          EQU     REG $FB             [Ref: 1850a 1851a 1852a 1854a 1855a 1856a 1857a ...]
           1832a 
010C       1833a PINEXT          EQU     REG $10C
           1834a 
00F6       1835a SIMANASEQ       EQU     REG $F6                       [Ref: 1836a 1837a 1838a 1839a 1840a 1841a]
00F6       1836a SIMANASEQ_CVI   EQU     SIMANASEQ BIT 13
00F6       1837a SIMANASEQ_CHN   EQU     SIMANASEQ BITS 12:11
00F6       1838a SIMANASEQ_S     EQU     SIMANASEQ BITS 10:7
00F6       1839a SIMANASEQ_JHIGH EQU     SIMANASEQ BIT 6
00F6       1840a SIMANASEQ_J     EQU     SIMANASEQ BITS 5:2
00F6       1841a SIMANASEQ_C     EQU     SIMANASEQ BITS 1:0
           1842a 
           1843a ; Older version:
010D       1844a ANASEQ          EQU     REG $10D                                  [Ref: 1845a 1846a 1847a 1848a]
010D       1845a ANASEQ_S        EQU     ANASEQ BITS 15:12
010D       1846a ANASEQ_J        EQU     ANASEQ BITS 11:10
010D       1847a ANASEQ_JG       EQU     ANASEQ BITS 9:4
010D       1848a ANASEQ_C        EQU     ANASEQ BITS 3:0
           1849a 
00FB       1850a SIMCTL_FASTTIMERS EQU   SIMCTL BIT 0    ; Speed up LST to 200us and WDT to 1ms.
00FB       1851a SIMCTL_NOXTAL   EQU     SIMCTL BIT 1    ; Disable external XTAL oscillator.
00FB       1852a SIMCTL_NOTRACE  EQU     SIMCTL BIT 2    ; Disable instruction trace output to stdout.
           1853a ;               EQU     SIMCTL BIT 3    ;
00FB       1854a SIMCTL_DELAYPOUT0 EQU   SIMCTL BIT 4    ; Delayed EXTPOUT for pin 0.
00FB       1855a SIMCTL_DELAYPDIR0 EQU   SIMCTL BIT 5    ; Delayed EXTPDIR for pin 0.
00FB       1856a SIMCTL_EXTWOUT  EQU     SIMCTL BIT 6    ; Level for very weak drive.
00FB       1857a SIMCTL_EXTWDIR  EQU     SIMCTL BIT 7    ; Enable very weak drive on all I/O pins.
00FB       1858a SIMCTL_FASTTEST EQU     SIMCTL BIT 8    ; User requests faster test.
           1859a ;               EQU     SIMCTL BIT 9    ;
           1860a ;               EQU     SIMCTL BIT 10   ;
           1861a ;               EQU     SIMCTL BIT 11   ;
00FB       1862a SIMCTL_CMD      EQU     SIMCTL BITS 15:12             [Ref: 1864a 1865a 1866a 1867a 1868a 1869a]
           1863a 

ASMT4 1.003  --  File regs.asm  --  6/17/05 18:29:50  --  Page 27




0000       1864a SIMCTL_CMD_NONE         EQU BITBASE(SIMCTL_CMD, 0000b)  ; No special operation.
5000       1865a SIMCTL_CMD_COUNTTIME    EQU BITBASE(SIMCTL_CMD, 0101b)  ; SIMARG is a 100ns counter.
6000       1866a SIMCTL_CMD_COUNTCLKOUT  EQU BITBASE(SIMCTL_CMD, 0110b)  ; SIMARG counts CLKOUT rising.
7000       1867a SIMCTL_CMD_COUNTCLKIN   EQU BITBASE(SIMCTL_CMD, 0111b)  ; SIMARG counts CLKIN falling.
9000       1868a SIMCTL_CMD_COUNTBGCLK   EQU BITBASE(SIMCTL_CMD, 1001b)  ; SIMARG counts bandgap clocks.
A000       1869a SIMCTL_CMD_SPIMON       EQU BITBASE(SIMCTL_CMD, 1010b)  ; Read external SPI monitor.
           1870a 
           1871a   ENDIF NO_SIM_FEATURES
           1872a 
           1873a 
           1874a 
           1875a ;
           1876a ; End of regs.asm.
           1877a ;
           1878a 
           1879a         SUBTITLE PREVIOUS
           1880a 
           1881a  ELSE  ; _ASM_CODEPAGE
           1882a*  INCLUDE "regs_old.asm"  ; Can remove this after transition period to new asmt4.
           1883a  ENDIF
               6 ;include macros.asm
               7 
               8 
               9 ;*************************************************************
              10 ; OPTIONS
              11 
              12 
0001          13 hasPackrat      equ 1                                                              [Ref: 16 24b]
              14 
              15 
              16   if hasPackrat                                                                        [Def: 13]
              17                         shell   "packrat > /dev/null &",pass:1 ; fork the archiver backend (no-\
op if already there)
              18 firmware_build_ID       shell   "packrat --allocate"    ; get an identification number from the\
 archiver
                                                                                                       [Ref: 25b]
              19                         keepsym firmware_build_ID       ; make sure we keep it around
              20 
              21 ; This command will run after the assembler completes, assuming there are no prior errors.
              22 firmware_archive        shell   "packrat --open " ++ firmware_build_ID ++ \
              23                                 " --stream " ++ \
              24                                 " --hex " ++ _ASM_HEXNAME ++ \
              25                                 " --file " ++ _ASM_LSTNAME,pass:post
                                                                                     [Def: (built-in) (built-in)]
              26                         keepsym firmware_archive        ; make sure the feedback string hangs a\
round
              27 
              28   endif hasPackrat
              29 
              30 
              31 ; define PWM IOs
0001          32 PWM_Red_pin   equ 1                                                                   [Ref: 215]
0002          33 PWM_Green_pin equ 2                                                                   [Ref: 216]
0003          34 PWM_Blue_pin  equ 3                                                                   [Ref: 217]
              35 
              36 
              37 ; Pole Dance Revolution Startup
              38 ;
              39 ; At powerup, the sensors use the SetAddressIn and Out lines
              40 ; to determine their address.  The sequence is as follows:
              41 ;
              42 ; At powerup, all the sensors enable pullups on their
              43 ; SetAddress lines and the controller drives a 0 onto the
              44 ; first sensors SetAddressIn line.
              45 ;
              46 ; The SPI master will drive a DATA sequence with an address.
              47 ; The device with 0 on SetDataIn takes this address as theirs.
              48 ; The current device drives SetDataOut to 0 for the next
              49 ; transaction and the sequence repeats for the next sensor &
              50 ; address.
              51 ;
0000          52 SetAddressIn_pin        equ 0                                                         [Ref: 212]
000C          53 SetAddressOut_pin       equ 12                                                        [Ref: 213]

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 28




              54 
              55 ; estimates to get some sort of sensing data out (though we will
              56 ; be able to servo through software control)
0030          57 bestGuessXRefHi         equ $30                                                       [Ref: 275]
0010          58 bestGuessXRefLo         equ $10                                                       [Ref: 281]
0001          59 SetBigRef               equ 1                                                         [Ref: 286]
              60 
              61 
              62 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              63 ; Our initial colors
03FF          64 Color_Pink_Amount_Red           equ $3FF                                              [Ref: 85b]
0080          65 Color_Pink_Amount_Green         equ $080                                              [Ref: 87b]
0180          66 Color_Pink_Amount_Blue          equ $180                                              [Ref: 89b]
              67 
03FF          68 Color_Red_Amount_Red            equ $3FF                                              [Ref: 94b]
0000          69 Color_Red_Amount_Green          equ $000                                              [Ref: 96b]
0000          70 Color_Red_Amount_Blue           equ $000                                              [Ref: 98b]
              71 
03FF          72 Color_Orange_Amount_Red         equ $3FF                                             [Ref: 104b]
0180          73 Color_Orange_Amount_Green       equ $180                                             [Ref: 106b]
0000          74 Color_Orange_Amount_Blue        equ $000                                             [Ref: 108b]
              75 
03FF          76 Color_Yellow_Amount_Red         equ $3FF                                             [Ref: 113b]
03FF          77 Color_Yellow_Amount_Green       equ $3FF                                             [Ref: 115b]
0000          78 Color_Yellow_Amount_Blue        equ $000                                             [Ref: 117b]
              79 
0000          80 Color_Green_Amount_Red          equ $000                                             [Ref: 123b]
03FF          81 Color_Green_Amount_Green        equ $3FF                                             [Ref: 125b]
0000          82 Color_Green_Amount_Blue         equ $000                                             [Ref: 127b]
              83 
0080          84 Color_Aqua_Amount_Red           equ $080                                             [Ref: 133b]
03FF          85 Color_Aqua_Amount_Green         equ $3FF                                             [Ref: 135b]
0200          86 Color_Aqua_Amount_Blue          equ $200                                             [Ref: 137b]
              87 
0000          88 Color_Cyan_Amount_Red           equ $000                                             [Ref: 143b]
03FF          89 Color_Cyan_Amount_Green         equ $3FF                                             [Ref: 145b]
03FF          90 Color_Cyan_Amount_Blue          equ $3FF                                             [Ref: 147b]
              91 
0000          92 Color_Blue_Amount_Red           equ $000                                             [Ref: 153b]
0000          93 Color_Blue_Amount_Green         equ $000                                             [Ref: 155b]
03FF          94 Color_Blue_Amount_Blue          equ $3FF                                             [Ref: 157b]
              95 
0080          96 Color_BlueViolet_Amount_Red     equ $080                                             [Ref: 163b]
0000          97 Color_BlueViolet_Amount_Green   equ $000                                             [Ref: 165b]
03FF          98 Color_BlueViolet_Amount_Blue    equ $3FF                                             [Ref: 167b]
              99 
0180         100 Color_Violet_Amount_Red         equ $180                                             [Ref: 173b]
0000         101 Color_Violet_Amount_Green       equ $000                                             [Ref: 175b]
03FF         102 Color_Violet_Amount_Blue        equ $3FF                                             [Ref: 177b]
             103 
03FF         104 Color_Magenta_Amount_Red        equ $3FF                                             [Ref: 182b]
0000         105 Color_Magenta_Amount_Green      equ $000                                             [Ref: 184b]
0300         106 Color_Magenta_Amount_Blue       equ $300                                             [Ref: 186b]
             107 
03FF         108 Color_White_Amount_Red          equ $3FF                         [Ref: 192b 202b 212b 222b 232b]
03FF         109 Color_White_Amount_Green        equ $3FF                         [Ref: 194b 204b 214b 224b 234b]
03FF         110 Color_White_Amount_Blue         equ $3FF                         [Ref: 196b 206b 216b 226b 236b]
             111 
             112 
             113 
             114 
             115 
             116 ;*************************************************************
             117 ; VARIABLES
             118 
             119 
000C         120 FlagWord                alloc reg $0C                                             [Ref: 150 154]
001E         121 PackratIDLow            alloc reg $1E                                                 [Ref: 26b]
001F         122 PackratIDHigh           alloc reg $1F
             123 
             124 
             125 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
             126 ; Thread 1 Variables

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 29




             127 
             128 ; thread 3 adds data to the head, and thread 1 reads it
             129 ; from the tail.  Only the low byte of each pointer contains
             130 ; meaningful data.
000D         131 Q_Head                  alloc reg $0D                                       [Ref: 46b 286b 308b]
000E         132 Q_Tail                  alloc reg $0E                             [Ref: 47b 290b 196d 207d 238d]
             133 
             134 ; the data thread 1 is reading off the queue
000F         135 t1_CurrentData          alloc reg $0F                  [Ref: 298b 326b 327b 347b 355b 363b 371b]
             136 ; marks whether we want to receive the first, second, or third 
             137 ; word of PWM data
0010         138 t1_ReceivePWMState      alloc reg $10                     [Ref: 139 140 141 351b 359b 367b 374b]
0010         139 ReadyForRed             equ t1_ReceivePWMState bit 0                 [Ref: 335b 350b] [Def: 138]
0010         140 ReadyForGreen           equ t1_ReceivePWMState bit 1                 [Ref: 337b 358b] [Def: 138]
0010         141 ReadyForBlue            equ t1_ReceivePWMState bit 2                 [Ref: 339b 366b] [Def: 138]
             142 
             143 ; while thread 1 is parsing commands, it stores them here
0011         144 t1_Receiving_Time       alloc reg $11                                           [Ref: 349b 383b]
0012         145 t1_Receiving_Red        alloc reg $12                                           [Ref: 357b 385b]
0013         146 t1_Receiving_Green      alloc reg $13                                           [Ref: 365b 387b]
0014         147 t1_Receiving_Blue       alloc reg $14                                           [Ref: 373b 389b]
             148 
             149 ; flag that thread 1 has data ready for thread 2 to copy
000C         150 t1_DataReady            equ FlagWord bit 0             [Ref: 247b 379b 392b 98c 114c] [Def: 120]
             151 
             152 ; flag that tells threads 1 and 2 that thread 3 has received
             153 ; and stored the address.
000C         154 t1_HaveAddress          equ FlagWord bit 1                     [Ref: 69b 54c 64c 85d] [Def: 120]
             155 
             156 ; these are the words thread 2 copies when it needs new data
0015         157 t1_Time_Data            alloc reg $15                                 [Ref: 244b 245b 384b 111c]
0016         158 t1_Red_Data             alloc reg $16      [Ref: 86b 95b 105b 114b 124b 134b 144b 154b 164b ...]
0017         159 t1_Green_Data           alloc reg $17      [Ref: 88b 97b 107b 116b 126b 136b 146b 156b 166b ...]
0018         160 t1_Blue_Data            alloc reg $18      [Ref: 90b 99b 109b 118b 128b 138b 148b 158b 168b ...]
             161 
             162 
             163 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
             164 ; Thread 2 Variables
             165 
             166 ; this is the data thread 1 passed to thread 2
             167 ; time = how long (minimum) the data is good for
0020         168 t2_Time_Data            alloc reg $20                                    [Ref: 43c 83c 87c 112c]
0021         169 t2_Red_Data             alloc reg $21                                           [Ref: 103c 137c]
0022         170 t2_Green_Data           alloc reg $22                                           [Ref: 106c 140c]
0023         171 t2_Blue_Data            alloc reg $23                                           [Ref: 109c 143c]
             172 
             173 ; to process the data, thread 2 cycles through its
             174 ; PWM loop, taking the lowest bit of data first
0024         175 t2_Red_Rotate           alloc reg $24                                           [Ref: 138c 238c]
0025         176 t2_Green_Rotate         alloc reg $25                                           [Ref: 141c 242c]
0026         177 t2_Blue_Rotate          alloc reg $26                                           [Ref: 144c 246c]
             178 
             179 
             180 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
             181 ; Thread 3 Variables
             182 
             183 ; store the address we were dynamically assigned
0030         184 MyAddress               alloc reg $30                                        [Ref: 73b 82d 117d]
             185 
             186 ; the data just received over the SPI port
0031         187 t3_CurrentData          alloc reg $31              [Ref: 80d 110d 158d 185d 202d 215d 222d 229d]
             188 
             189 ; the address to write to
0033         190 t3_WriteRegisterAddress alloc reg $33                                       [Ref: 49d 216d 232d]
             191 ; the data to write to the address
0034         192 t3_WriteRegisterData    alloc reg $34                                      [Ref: 223d 230d 235d]
             193 
             194 
             195 
             196 
             197 ; thread 3 receives data over the SPI bus, and 
             198 ; copies the received data into this SPI buffer.  
             199 ; Thread 1 then takes the data out of the

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 30




             200 ; buffer and does any necessary PWM processing.
             201 ;
0040         202 SPI_Buffer              alloc reg $40                               [Ref: 204 45b 305b 54d 193d]
             203 
             204         assert  (val(SPI_Buffer) & $F) == 0                                           [Def: 202]
             205 
             206 
             207 ;*************************************************************
             208 ; BITMASKS
             209 
             210 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
             211 ; I/O Data
0008         212 SetAddressIn    equ PIN  bit SetAddressIn_pin          [Ref: 235 249 65d 66d 70d] [Def: 52 408a]
0006         213 SetAddressOut   equ PDIR bit SetAddressOut_pin        [Ref: 236 246 250 89d 115d] [Def: 53 406a]
             214 
0007         215 PWM_Red   equ POUT bit PWM_Red_pin                                [Ref: 220 240c] [Def: 32 407a]
0007         216 PWM_Green equ POUT bit PWM_Green_pin                              [Ref: 221 244c] [Def: 33 407a]
0007         217 PWM_Blue  equ POUT bit PWM_Blue_pin                               [Ref: 222 248c] [Def: 34 407a]
             218 
0000         219 bitmask_PWMs    set 0                           [Ref: 220 221 222 234 243 261 49c 60c 236c 253c]
0002         220 bitmask_PWMs set bitmask_PWMs | bitmask PWM_Red
                                                             [Ref: 220 221 222 234 243 261 49c 60c 236c 253c] ...
0006         221 bitmask_PWMs set bitmask_PWMs | bitmask PWM_Green
                                                             [Ref: 220 221 222 234 243 261 49c 60c 236c 253c] ...
000E         222 bitmask_PWMs set bitmask_PWMs | bitmask PWM_Blue
                                                             [Ref: 220 221 222 234 243 261 49c 60c 236c 253c] ...
             223 
0008         224 SSB  equ PIN bit 6                        [Ref: 228 254 260 61d 71d 73d 75d 98d 100d] [Def: ...]
0008         225 SDIN equ PIN bit 7                                                        [Ref: 228] [Def: 408a]
0008         226 SCLK equ PIN bit 10                                                       [Ref: 228] [Def: 408a]
0007         227 SDOUT equ POUT bit 11                                            [Ref: 229 257 124d] [Def: 407a]
04C0         228 bitmask_SPI_in  set (bitmask SSB) | (bitmask SDIN) | (bitmask SCLK)
                                                                                    [Ref: 230] [Def: 224 225 226]
0800         229 bitmask_SPI_out set (bitmask SDOUT)                                        [Ref: 230] [Def: 227]
0CC0         230 bitmask_SPI     set bitmask_SPI_in | bitmask_SPI_out                   [Ref: 233] [Def: 228 229]
             231 
FFFF         232 bitmask_unusedIOs  set $FFFF                                          [Ref: 233 234 235 236 251]
F33F         233 bitmask_unusedIOs  set bitmask_unusedIOs & not(bitmask_SPI)
                                                            [Ref: 233 234 235 236 251] [Def: 232 233 234 235 ...]
F331         234 bitmask_unusedIOs  set bitmask_unusedIOs & not(bitmask_PWMs)
                                                            [Ref: 233 234 235 236 251] [Def: 232 233 234 235 ...]
F330         235 bitmask_unusedIOs  set bitmask_unusedIOs & not(bitmask SetAddressIn)
                                                            [Ref: 233 234 235 236 251] [Def: 232 233 234 235 ...]
E330         236 bitmask_unusedIOs  set bitmask_unusedIOs & not(bitmask SetAddressOut)
                                                            [Ref: 233 234 235 236 251] [Def: 232 233 234 235 ...]
             237 
             238 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
             239 ; Port Masks
0000         240 basePAUXmask    set 0
             241 
0000         242 basePDIRmask    set 0                                                       [Ref: 243 287c 261d]
000E         243 basePDIRmask    set basePDIRmask | bitmask_PWMs         ; always drive LEDs
                                                              [Ref: 243 287c 261d] [Def: 242 243 219 220 221 222]
             244 
0000         245 preservePins_PDIR set 0                                                     [Ref: 246 289c 263d]
1000         246 preservePins_PDIR set preservePins_PDIR | bitmask SetAddressOut
                                                                          [Ref: 246 289c 263d] [Def: 245 246 213]
             247 
0000         248 basePCTLmask    set 0                                           [Ref: 249 250 251 30b 292c 266d]
0001         249 basePCTLmask    set basePCTLmask | bitmask SetAddressIn ; pullup on address input
                                                              [Ref: 249 250 251 30b 292c 266d] [Def: 248 249 ...]
1001         250 basePCTLmask    set basePCTLmask | bitmask SetAddressOut; pullup on address output (for sake ou\
t last device in chain)
                                                              [Ref: 249 250 251 30b 292c 266d] [Def: 248 249 ...]
F331         251 basePCTLmask    set basePCTLmask | bitmask_unusedIOs    ; pullups on unused IOs
                                                              [Ref: 249 250 251 30b 292c 266d] [Def: 248 249 ...]
             252 
0000         253 basePIEmask     set 0                                                       [Ref: 254 295c 269d]
0040         254 basePIEmask     set basePIEmask | bitmask SSB           ; interrupt on SSB transitions
                                                                          [Ref: 254 295c 269d] [Def: 253 254 224]
             255 
0000         256 basePOUTmask    set 0                                                       [Ref: 257 298c 272d]
0800         257 basePOUTmask    set basePOUTmask | bitmask SDOUT        ; fully drive data out, gated by SSB

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 31




                                                                          [Ref: 257 298c 272d] [Def: 256 257 227]
             258 
0000         259 preservePins_POUT set 0                                                 [Ref: 260 261 300c 274d]
0040         260 preservePins_POUT set preservePins_POUT | bitmask SSB   ; never change slave select level in in\
it ports
                                                                  [Ref: 260 261 300c 274d] [Def: 259 260 261 224]
004E         261 preservePins_POUT set preservePins_POUT | bitmask_PWMs  ; never change LEDs in init ports
                                                              [Ref: 260 261 300c 274d] [Def: 259 260 261 219 ...]
             262 
             263 
             264 ;*************************************************************
             265 ; ANALOG SETTINGS
             266 
00E0         267 SensorData      equ     XCH0                            ; corresponds to X1 since we're in 1CHN\
 mode.
                                                                                        [Ref: 128d] [Def: 446a.2]
             268 
0000         269 baseOCTLmask    set     0                                                    [Ref: 270 271 411b]
0020         270 baseOCTLmask    set     baseOCTLmask | $20              ; set RCosc to 4 MHz
                                                                           [Ref: 270 271 411b] [Def: 269 270 271]
0220         271 baseOCTLmask    set     baseOCTLmask | (bitmask AEN)    ; turn on analog block
                                                                      [Ref: 270 271 411b] [Def: 269 270 271 550a]
             272 
0000         273 baseXHCTLmask   set     0                                                    [Ref: 274 275 418b]
0100         274 baseXHCTLmask   set     baseXHCTLmask | $100            ; set the chip to 1 CHN mode
                                                                           [Ref: 274 275 418b] [Def: 273 274 275]
0130         275 baseXHCTLmask   set     baseXHCTLmask | bestGuessXRefHi ; try servoing by estimation
                                                                        [Ref: 274 275 418b] [Def: 273 274 275 57]
             276 
0000         277 baseXLCTLmask   set     0                                            [Ref: 278 279 280 281 421b]
0200         278 baseXLCTLmask   set     baseXLCTLmask | (bitmask XSENSE); turn on X sensors
                                                           [Ref: 278 279 280 281 421b] [Def: 277 278 279 280 ...]
0300         279 baseXLCTLmask   set     baseXLCTLmask | (bitmask XREFEN)
                                                           [Ref: 278 279 280 281 421b] [Def: 277 278 279 280 ...]
0380         280 baseXLCTLmask   set     baseXLCTLmask | (bitmask XADCEN); turn on X ADCs
                                                           [Ref: 278 279 280 281 421b] [Def: 277 278 279 280 ...]
0390         281 baseXLCTLmask   set     baseXLCTLmask | bestGuessXRefLo
                                                           [Ref: 278 279 280 281 421b] [Def: 277 278 279 280 ...]
             282 
0000         283 baseYHCTLmask   set     0                                                            [Ref: 424b]
             284 
0000         285 baseYLCTLmask   set     0                                                        [Ref: 287 427b]
             286   if SetBigRef                                                                         [Def: 59]
0040         287 baseYLCTLmask   set     baseYLCTLmask | (bitmask BigRef)
                                                                        [Ref: 287 427b] [Def: 285 287 683a 693a*]
             288   endif
             289 
             290 
             291 ;*************************************************************
             292 ; BEGIN CODE
             293 
             294 include pwm_t1.asm
              1b ; Pole Dance Revolution - Thread 1
              2b ;
              3b ; Thread 1 code for PWM
              4b ;
              5b 
0000          6b org $0000
0000          7b resetVector:
0000 3002     8b         jmp     t1_begin                                           ; JMP $0002        [Def: 20b]
              9b 
             10b 
             11b 
0001         12b mfgOscVectorAddr:                                                                    [Ref: 407b]
0001         13b oscVector:
             14b 
             15b         assert  IS_T1005                                                              [Def: 73a]
0001 FFFF    16b         word    $FFFF   ; we're assuming unused RAM is '1'         ; RESET
             17b 
             18b 
             19b 
0002         20b t1_begin:                                                                              [Ref: 8b]
0002 3F01    21b         nop     ; not needed, but does no harm                     ; NOP

ASMT4 1.003  --  File pwm_t1.asm  --  6/17/05 18:29:50  --  Page 32




0003 3F01    22b         nop                                                        ; NOP
             23b 
             24b    if hasPackrat                                                                       [Def: 13]
0004 2C50    25b         mov     A, #firmware_build_ID AND $FFFF                    ; MOVN A,#$0050
0005 2361                                                                           ; OR A,#$6100
0006 3F1E    26b         mov     PackratIDLow, A                                    ; MOVN REG $1E,A   [Def: 121]
             27b    endif hasPackrat
             28b 
             29b ; initialize the pullup on SetAddressIn
0007 2C31    30b         mov A, #basePCTLmask                                       ; MOVN A,#$0031
                                                                                           [Def: 248 249 250 251]
0008 23F3                                                                           ; OR A,#$F300
0009 3F04    31b         mov PCTL, A                                                ; MOVN PCTL,A     [Def: 404a]
             32b 
             33b ; Clear the RAM
000A 2D0B    34b         mov     X, #val reg $0B                                    ; MOVN X,#$0B
000B 2CD4    35b         mov     A, #last_ram - reg $0B                             ; MOVN A,#$00D4
                                                                                          [Def: 417a* 421a 425a*]
000C         36b clearLoop:                                                                            [Ref: 40b]
000C 4EC0    37b         clr     @X                                                 ; CLR @X
000D 0140    38b         inc     X                                                  ; INC X           [Def: 465a]
000E 0FC1    39b         loop    a                                                  ; LOOP A          [Def: 401a]
000F 300C    40b             jmp clearLoop                                          ; JMP $000C        [Def: 36b]
             41b 
             42b ; We only initialize the analog block once to our best guess values.
0010 38ED    43b         call    initAnalog                                         ; CALL $00ED      [Def: 405b]
             44b 
0011 2C40    45b         mov     A, #val(SPI_Buffer)                                ; MOVN A,#$0040    [Def: 202]
0012 3F0D    46b         mov     Q_Head, A                                          ; MOVN REG $0D,A   [Def: 131]
0013 3F0E    47b         mov     Q_Tail, A                                          ; MOVN REG $0E,A   [Def: 132]
             48b 
             49b         ; In our implementation, thread 2 will run at all times, leaving thread 1 and 3
             50b         ; 50% of the CPU time to do all necessary command receiving and processing.
             51b         ; At least we don't care about power consumption.
0014 1189    52b         bset    TALT    ; Interleaved Mode -                       ; BSET CCTL BIT 6
                                                                                                      [Def: 512a]
0015 11C9    53b         bset    TPRI    ; threads 2 and 3 not eligible to run at same time
                                                                                    ; BSET CCTL BIT 7
                                                                                                      [Def: 511a]
             54b 
             55b 
0016 2C38    56b         mov     A, #$A000+val wide t2_start     ; start Thread 2 - lights will blink
                                                                                    ; MOVN A,#$0038
                                                                                                       [Def: 41c]
0017 23A1                                                                           ; OR A,#$A100
0018 3FE3    57b         movn    TPC2, A                                            ; MOVN TPC2,A     [Def: 430a]
0019 1289    58b         bset    trdy2                                              ; BSET CCTL BIT 10
                                                                                                      [Def: 508a]
001A 12C9    59b         bset    ten2                                               ; BSET CCTL BIT 11
                                                                                                      [Def: 507a]
             60b 
001B 2C9E    61b         mov     A, #$A000+val wide t3_start     ; start Thread 3   ; MOVN A,#$009E    [Def: 46d]
001C 23A1                                                                           ; OR A,#$A100
001D 3FE6    62b         movn    TPC3, A                                            ; MOVN TPC3,A     [Def: 431a]
001E 13CA    63b         bset    trdy3                                              ; BSET CTIME BIT 15
                                                                                                      [Def: 499a]
001F 1309    64b         bset    ten3                                               ; BSET CCTL BIT 12
                                                                                                      [Def: 506a]
             65b 
0020         66b WaitForThread3ToReceiveSPIAddress:                                                    [Ref: 70b]
0020 3C02    67b         clrwdt  ; we may be here a while, and don't want to reset
                                                                                    ; CLRWDT
             68b         ; thread 3 will break us free from this loop as soon as it receives an address
0021 184C    69b         ifclr   t1_HaveAddress                                     ; IFCLR REG $0C BIT 1
                                                                                                       [Def: 154]
0022 3020    70b           jmp   WaitForThread3ToReceiveSPIAddress                  ; JMP $0020        [Def: 66b]
             71b 
             72b         ; based on the value now in MyAddress, set the appropriate output color
0023 3D30    73b         mov     A, MyAddress    ; the is really the address *$1000
                                                                                    ; MOVN A,REG $30
                                                                                                       [Def: 184]
0024 0D81    74b         mov     A, high A       ; now address * $10                ; MOVT A,HIGH A   [Def: 401a]
0025 09C1    75b         rrc     A               ; now address * 8                  ; RRC A           [Def: 401a]

ASMT4 1.003  --  File pwm_t1.asm  --  6/17/05 18:29:50  --  Page 33




0026 2A78    76b         and     A, #$78                                            ; AND A,#$0078
             77b                                 ; that's our offset into the ColorJumpTable
0027 202A    78b         add     A, #val narrow ColorJumpTable                      ; ADD A,#$002A     [Def: 83b]
0028 23A0    79b         or      A, #$A000       ; include safety bits              ; OR A,#$A000
0029 3F02    80b         mov     PC, A           ; and off we go...                 ; MOVN PC,A       [Def: 402a]
             81b 
             82b 
002A         83b ColorJumpTable:                                                                       [Ref: 78b]
002A         84b Pink::          ; Address 0
002A 2503    85b         mov     A, #narrow Color_Pink_Amount_Red                   ; MOVN A,#$03FF     [Def: 64]
002B 3F16    86b         mov     t1_Red_Data, A                                     ; MOVN REG $16,A   [Def: 158]
002C 2C80    87b         mov     A, #narrow Color_Pink_Amount_Green                 ; MOVN A,#$0080     [Def: 65]
002D 3F17    88b         mov     t1_Green_Data, A                                   ; MOVN REG $17,A   [Def: 159]
002E 2C80    89b         mov     A, #wide Color_Pink_Amount_Blue                    ; MOVN A,#$0080     [Def: 66]
002F 2301                                                                           ; OR A,#$0100
0030 3F18    90b         mov     t1_Blue_Data, A                                    ; MOVN REG $18,A   [Def: 160]
0031 30A8    91b         jmp     ColorSet                                           ; JMP $00A8       [Def: 242b]
             92b 
0032         93b Red::           ; Address 1
0032 2503    94b         mov     A, #narrow Color_Red_Amount_Red                    ; MOVN A,#$03FF     [Def: 68]
0033 3F16    95b         mov     t1_Red_Data, A                                     ; MOVN REG $16,A   [Def: 158]
0034 2C00    96b         mov     A, #narrow Color_Red_Amount_Green                  ; MOVN A,#$0000     [Def: 69]
0035 3F17    97b         mov     t1_Green_Data, A                                   ; MOVN REG $17,A   [Def: 159]
0036 2C00    98b         mov     A, #narrow Color_Red_Amount_Blue                   ; MOVN A,#$0000     [Def: 70]
0037 3F18    99b         mov     t1_Blue_Data, A                                    ; MOVN REG $18,A   [Def: 160]
0038 30A8   100b         jmp     ColorSet                                           ; JMP $00A8       [Def: 242b]
0039 3F01   101b         nop                                                        ; NOP
            102b 
003A        103b Orange::        ; Address 2
003A 2503   104b         mov     A, #narrow Color_Orange_Amount_Red                 ; MOVN A,#$03FF     [Def: 72]
003B 3F16   105b         mov     t1_Red_Data, A                                     ; MOVN REG $16,A   [Def: 158]
003C 2C80   106b         mov     A, #wide Color_Orange_Amount_Green                 ; MOVN A,#$0080     [Def: 73]
003D 2301                                                                           ; OR A,#$0100
003E 3F17   107b         mov     t1_Green_Data, A                                   ; MOVN REG $17,A   [Def: 159]
003F 2C00   108b         mov     A, #narrow Color_Orange_Amount_Blue                ; MOVN A,#$0000     [Def: 74]
0040 3F18   109b         mov     t1_Blue_Data, A                                    ; MOVN REG $18,A   [Def: 160]
0041 30A8   110b         jmp     ColorSet                                           ; JMP $00A8       [Def: 242b]
            111b 
0042        112b Yellow::        ; Address 3
0042 2503   113b         mov     A, #narrow Color_Yellow_Amount_Red                 ; MOVN A,#$03FF     [Def: 76]
0043 3F16   114b         mov     t1_Red_Data, A                                     ; MOVN REG $16,A   [Def: 158]
0044 2503   115b         mov     A, #narrow Color_Yellow_Amount_Green               ; MOVN A,#$03FF     [Def: 77]
0045 3F17   116b         mov     t1_Green_Data, A                                   ; MOVN REG $17,A   [Def: 159]
0046 2C00   117b         mov     A, #narrow Color_Yellow_Amount_Blue                ; MOVN A,#$0000     [Def: 78]
0047 3F18   118b         mov     t1_Blue_Data, A                                    ; MOVN REG $18,A   [Def: 160]
0048 30A8   119b         jmp     ColorSet                                           ; JMP $00A8       [Def: 242b]
0049 3F01   120b         nop                                                        ; NOP
            121b 
004A        122b Green::         ; Address 4
004A 2C00   123b         mov     A, #narrow Color_Green_Amount_Red                  ; MOVN A,#$0000     [Def: 80]
004B 3F16   124b         mov     t1_Red_Data, A                                     ; MOVN REG $16,A   [Def: 158]
004C 2503   125b         mov     A, #narrow Color_Green_Amount_Green                ; MOVN A,#$03FF     [Def: 81]
004D 3F17   126b         mov     t1_Green_Data, A                                   ; MOVN REG $17,A   [Def: 159]
004E 2C00   127b         mov     A, #narrow Color_Green_Amount_Blue                 ; MOVN A,#$0000     [Def: 82]
004F 3F18   128b         mov     t1_Blue_Data, A                                    ; MOVN REG $18,A   [Def: 160]
0050 30A8   129b         jmp     ColorSet                                           ; JMP $00A8       [Def: 242b]
0051 3F01   130b         nop                                                        ; NOP
            131b 
0052        132b Aqua::          ; Address 5
0052 2C80   133b         mov     A, #narrow Color_Aqua_Amount_Red                   ; MOVN A,#$0080     [Def: 84]
0053 3F16   134b         mov     t1_Red_Data, A                                     ; MOVN REG $16,A   [Def: 158]
0054 2503   135b         mov     A, #narrow Color_Aqua_Amount_Green                 ; MOVN A,#$03FF     [Def: 85]
0055 3F17   136b         mov     t1_Green_Data, A                                   ; MOVN REG $17,A   [Def: 159]
0056 2F02   137b         mov     A, #narrow Color_Aqua_Amount_Blue                  ; MOVN A,#$0200     [Def: 86]
0057 3F18   138b         mov     t1_Blue_Data, A                                    ; MOVN REG $18,A   [Def: 160]
0058 30A8   139b         jmp     ColorSet                                           ; JMP $00A8       [Def: 242b]
0059 3F01   140b         nop                                                        ; NOP
            141b 
005A        142b Cyan::          ; Address 6
005A 2C00   143b         mov     A, #narrow Color_Cyan_Amount_Red                   ; MOVN A,#$0000     [Def: 88]
005B 3F16   144b         mov     t1_Red_Data, A                                     ; MOVN REG $16,A   [Def: 158]
005C 2503   145b         mov     A, #narrow Color_Cyan_Amount_Green                 ; MOVN A,#$03FF     [Def: 89]
005D 3F17   146b         mov     t1_Green_Data, A                                   ; MOVN REG $17,A   [Def: 159]

ASMT4 1.003  --  File pwm_t1.asm  --  6/17/05 18:29:50  --  Page 34




005E 2503   147b         mov     A, #narrow Color_Cyan_Amount_Blue                  ; MOVN A,#$03FF     [Def: 90]
005F 3F18   148b         mov     t1_Blue_Data, A                                    ; MOVN REG $18,A   [Def: 160]
0060 30A8   149b         jmp     ColorSet                                           ; JMP $00A8       [Def: 242b]
0061 3F01   150b         nop                                                        ; NOP
            151b 
0062        152b Blue::          ; Address 7
0062 2C00   153b         mov     A, #narrow Color_Blue_Amount_Red                   ; MOVN A,#$0000     [Def: 92]
0063 3F16   154b         mov     t1_Red_Data, A                                     ; MOVN REG $16,A   [Def: 158]
0064 2C00   155b         mov     A, #narrow Color_Blue_Amount_Green                 ; MOVN A,#$0000     [Def: 93]
0065 3F17   156b         mov     t1_Green_Data, A                                   ; MOVN REG $17,A   [Def: 159]
0066 2503   157b         mov     A, #narrow Color_Blue_Amount_Blue                  ; MOVN A,#$03FF     [Def: 94]
0067 3F18   158b         mov     t1_Blue_Data, A                                    ; MOVN REG $18,A   [Def: 160]
0068 30A8   159b         jmp     ColorSet                                           ; JMP $00A8       [Def: 242b]
0069 3F01   160b         nop                                                        ; NOP
            161b 
006A        162b BlueViolet::    ; Address 8
006A 2C80   163b         mov     A, #narrow Color_BlueViolet_Amount_Red             ; MOVN A,#$0080     [Def: 96]
006B 3F16   164b         mov     t1_Red_Data, A                                     ; MOVN REG $16,A   [Def: 158]
006C 2C00   165b         mov     A, #narrow Color_BlueViolet_Amount_Green           ; MOVN A,#$0000     [Def: 97]
006D 3F17   166b         mov     t1_Green_Data, A                                   ; MOVN REG $17,A   [Def: 159]
006E 2503   167b         mov     A, #narrow Color_BlueViolet_Amount_Blue            ; MOVN A,#$03FF     [Def: 98]
006F 3F18   168b         mov     t1_Blue_Data, A                                    ; MOVN REG $18,A   [Def: 160]
0070 30A8   169b         jmp     ColorSet                                           ; JMP $00A8       [Def: 242b]
0071 3F01   170b         nop                                                        ; NOP
            171b 
0072        172b Violet::        ; Address 9
0072 2C80   173b         mov     A, #wide Color_Violet_Amount_Red                   ; MOVN A,#$0080    [Def: 100]
0073 2301                                                                           ; OR A,#$0100
0074 3F16   174b         mov     t1_Red_Data, A                                     ; MOVN REG $16,A   [Def: 158]
0075 2C00   175b         mov     A, #narrow Color_Violet_Amount_Green               ; MOVN A,#$0000    [Def: 101]
0076 3F17   176b         mov     t1_Green_Data, A                                   ; MOVN REG $17,A   [Def: 159]
0077 2503   177b         mov     A, #narrow Color_Violet_Amount_Blue                ; MOVN A,#$03FF    [Def: 102]
0078 3F18   178b         mov     t1_Blue_Data, A                                    ; MOVN REG $18,A   [Def: 160]
0079 30A8   179b         jmp     ColorSet                                           ; JMP $00A8       [Def: 242b]
            180b 
007A        181b Magenta::       ; Address 10
007A 2503   182b         mov     A, #narrow Color_Magenta_Amount_Red                ; MOVN A,#$03FF    [Def: 104]
007B 3F16   183b         mov     t1_Red_Data, A                                     ; MOVN REG $16,A   [Def: 158]
007C 2C00   184b         mov     A, #narrow Color_Magenta_Amount_Green              ; MOVN A,#$0000    [Def: 105]
007D 3F17   185b         mov     t1_Green_Data, A                                   ; MOVN REG $17,A   [Def: 159]
007E 2F03   186b         mov     A, #narrow Color_Magenta_Amount_Blue               ; MOVN A,#$0300    [Def: 106]
007F 3F18   187b         mov     t1_Blue_Data, A                                    ; MOVN REG $18,A   [Def: 160]
0080 30A8   188b         jmp     ColorSet                                           ; JMP $00A8       [Def: 242b]
0081 3F01   189b         nop                                                        ; NOP
            190b 
0082        191b White_11::      ; Address 11 (not valid)
0082 2503   192b         mov     A, #narrow Color_White_Amount_Red                  ; MOVN A,#$03FF    [Def: 108]
0083 3F16   193b         mov     t1_Red_Data, A                                     ; MOVN REG $16,A   [Def: 158]
0084 2503   194b         mov     A, #narrow Color_White_Amount_Green                ; MOVN A,#$03FF    [Def: 109]
0085 3F17   195b         mov     t1_Green_Data, A                                   ; MOVN REG $17,A   [Def: 159]
0086 2503   196b         mov     A, #narrow Color_White_Amount_Blue                 ; MOVN A,#$03FF    [Def: 110]
0087 3F18   197b         mov     t1_Blue_Data, A                                    ; MOVN REG $18,A   [Def: 160]
0088 30A8   198b         jmp     ColorSet                                           ; JMP $00A8       [Def: 242b]
0089 3F01   199b         nop                                                        ; NOP
            200b 
008A        201b White_12::      ; Address 12 (not valid)
008A 2503   202b         mov     A, #narrow Color_White_Amount_Red                  ; MOVN A,#$03FF    [Def: 108]
008B 3F16   203b         mov     t1_Red_Data, A                                     ; MOVN REG $16,A   [Def: 158]
008C 2503   204b         mov     A, #narrow Color_White_Amount_Green                ; MOVN A,#$03FF    [Def: 109]
008D 3F17   205b         mov     t1_Green_Data, A                                   ; MOVN REG $17,A   [Def: 159]
008E 2503   206b         mov     A, #narrow Color_White_Amount_Blue                 ; MOVN A,#$03FF    [Def: 110]
008F 3F18   207b         mov     t1_Blue_Data, A                                    ; MOVN REG $18,A   [Def: 160]
0090 30A8   208b         jmp     ColorSet                                           ; JMP $00A8       [Def: 242b]
0091 3F01   209b         nop                                                        ; NOP
            210b 
0092        211b White_13::      ; Address 13 (not valid)
0092 2503   212b         mov     A, #narrow Color_White_Amount_Red                  ; MOVN A,#$03FF    [Def: 108]
0093 3F16   213b         mov     t1_Red_Data, A                                     ; MOVN REG $16,A   [Def: 158]
0094 2503   214b         mov     A, #narrow Color_White_Amount_Green                ; MOVN A,#$03FF    [Def: 109]
0095 3F17   215b         mov     t1_Green_Data, A                                   ; MOVN REG $17,A   [Def: 159]
0096 2503   216b         mov     A, #narrow Color_White_Amount_Blue                 ; MOVN A,#$03FF    [Def: 110]
0097 3F18   217b         mov     t1_Blue_Data, A                                    ; MOVN REG $18,A   [Def: 160]
0098 30A8   218b         jmp     ColorSet                                           ; JMP $00A8       [Def: 242b]

ASMT4 1.003  --  File pwm_t1.asm  --  6/17/05 18:29:50  --  Page 35




0099 3F01   219b         nop                                                        ; NOP
            220b 
009A        221b White_14::      ; Address 14 (not valid)
009A 2503   222b         mov     A, #narrow Color_White_Amount_Red                  ; MOVN A,#$03FF    [Def: 108]
009B 3F16   223b         mov     t1_Red_Data, A                                     ; MOVN REG $16,A   [Def: 158]
009C 2503   224b         mov     A, #narrow Color_White_Amount_Green                ; MOVN A,#$03FF    [Def: 109]
009D 3F17   225b         mov     t1_Green_Data, A                                   ; MOVN REG $17,A   [Def: 159]
009E 2503   226b         mov     A, #narrow Color_White_Amount_Blue                 ; MOVN A,#$03FF    [Def: 110]
009F 3F18   227b         mov     t1_Blue_Data, A                                    ; MOVN REG $18,A   [Def: 160]
00A0 30A8   228b         jmp     ColorSet                                           ; JMP $00A8       [Def: 242b]
00A1 3F01   229b         nop                                                        ; NOP
            230b 
00A2        231b White_15::      ; Address 15 (not valid)
00A2 2503   232b         mov     A, #narrow Color_White_Amount_Red                  ; MOVN A,#$03FF    [Def: 108]
00A3 3F16   233b         mov     t1_Red_Data, A                                     ; MOVN REG $16,A   [Def: 158]
00A4 2503   234b         mov     A, #narrow Color_White_Amount_Green                ; MOVN A,#$03FF    [Def: 109]
00A5 3F17   235b         mov     t1_Green_Data, A                                   ; MOVN REG $17,A   [Def: 159]
00A6 2503   236b         mov     A, #narrow Color_White_Amount_Blue                 ; MOVN A,#$03FF    [Def: 110]
00A7 3F18   237b         mov     t1_Blue_Data, A                                    ; MOVN REG $18,A   [Def: 160]
            238b ;        jmp     ColorSet                not needed for last one...
            239b ;        nop
            240b 
            241b 
00A8        242b ColorSet:                                 [Ref: 91b 100b 110b 119b 129b 139b 149b 159b 169b ...]
            243b        ; artificial delay so we'll show our address color 
00A8 0ED5   244b         clr     t1_Time_Data                                       ; CLR REG $15      [Def: 157]
00A9 1215   245b         bset    t1_Time_Data bit 8                                 ; BSET REG $15 BIT 8
                                                                                                       [Def: 157]
            246b 
00AA 100C   247b         bset    t1_DataReady    ; make sure thread 2 copies the buffer at least once
                                                                                    ; BSET REG $0C BIT 0
                                                                                                       [Def: 150]
            248b 
            249b 
            250b ; Thread 1 receives data from thread 3 and processes it and passes is on to
            251b ; thread 2.
            252b ;
            253b ; Thread 1 sits in a loop checking if we have data in our SPI Buffer.  As soon
            254b ; as we see we have data, we copy the data and update our queue pointer.
            255b ; Thread 3 has already verified that the data is for us, and that it is not a
            256b ; read or write register command.
            257b ;
            258b ; Since PWM commands are four bytes long, we maintain a state machine to
            259b ; indicate which word we expect next.  We first check to see if the command is
            260b ; a PWM header.  If so, we copy the encapsulated time data into our receiving
            261b ; buffer, and set our state machine to receive our red data.  Subsequently,
            262b ; for each color, we store the color data into the receiving buffer and
            263b ; increment our state machine.  If at any point we receive a word that does not
            264b ; match our expected data format, we reset the state machine.
            265b ; After we have received all four words of a PWM command, we wait for thread 2
            266b ; to clear t1_dataReady, and then copy the data into the thread 1 data buffer,
            267b ; which thread 2 will then copy, and sets the t1_dataReady flag.
            268b ;
            269b ;
            270b ; timings (instructions):
            271b ; no data: 10
            272b ; PWM header: 29
            273b ; receive red: 20
            274b ; receive green: 22
            275b ; receive blue: 45 + wait time for buffer empty
            276b 
            277b 
00AB        278b t1_main:                                                    [Ref: 293b 343b 352b 360b 368b 394b]
            279b ; thread sanity checking
00AB 1809   280b         skpset thr bit 0                                           ; IFCLR CCTL BIT 0
                                                                                                      [Def: 532a]
00AC 1C49   281b          ifset thr bit 1                                           ; IFSET CCTL BIT 1
                                                                                                      [Def: 532a]
00AD 3FFF   282b           reset                                                    ; RESET
            283b 
00AE 3C02   284b         clrwdt ; 10ms timeout - we should be fine                  ; CLRWDT
            285b 
00AF 3D0D   286b         mov A, Q_Head                                              ; MOVN A,REG $0D   [Def: 131]

ASMT4 1.003  --  File pwm_t1.asm  --  6/17/05 18:29:50  --  Page 36




00B0 0040   287b         mov X, A                                                   ; MOVT X,A        [Def: 465a]
            288b 
            289b         ; do we have new data from thread 3?
00B1 3D0E   290b         mov A, Q_Tail                                              ; MOVN A,REG $0E   [Def: 132]
00B2 0300   291b         sub A, STATX, A         ; are we pointing to the Tail?     ; SUB A,STATX,A   [Def: 400a]
00B3 1F00   292b         ifzl                    ; if so, the buffer's empty        ; IFZL   [Def: 469a.3 469a.1]
00B4 30AB   293b           jmp   t1_main         ; and we have nothing to do.       ; JMP $00AB       [Def: 278b]
            294b 
            295b 
            296b         ; Q_Head != Q_Tail, so we have data to process
00B5 4D00   297b         mov A, @X               ; get data                         ; MOVT A,@X
00B6 3F0F   298b         mov t1_CurrentData, A   ; store it                         ; MOVN REG $0F,A   [Def: 135]
            299b 
            300b         ; update our pointed
00B7 0140   301b         inc X                                                      ; INC X           [Def: 465a]
00B8 2CE0   302b         mov A, #$E0             ; has our pointer wrapped?         ; MOVN A,#$00E0
00B9 0600   303b         xor A, STATX                                               ; XOR A,STATX     [Def: 400a]
00BA 1F00   304b         ifzl                                                       ; IFZL   [Def: 469a.3 469a.1]
00BB 2D40   305b           mov X, #val(SPI_Buffer)                                  ; MOVN X,#$40      [Def: 202]
            306b 
00BC 0D40   307b         mov A, X                                                   ; MOVS A,X        [Def: 465a]
00BD 3F0D   308b         mov Q_Head, A                                              ; MOVN REG $0D,A   [Def: 131]
            309b 
            310b 
            311b ; Thread 1 only receives PWM commands.
            312b ;    PWM Sequence
            313b ;    |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
            314b ;    |    ADDRESS    | 0 | 0 |               TIME DELAY              |
            315b ;    |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
            316b ;    |    ADDRESS    | 1 | 0 |              RED PWM DATA             |
            317b ;    |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
            318b ;    |    ADDRESS    | 1 | 0 |            GREEN PWM DATA             |
            319b ;    |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
            320b ;    |    ADDRESS    | 1 | 0 |             BLUE PWM DATA             |
            321b ;    |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
            322b ;
            323b 
            324b 
            325b         ; check if we have a header
00BE 1A8F   326b         skpset  t1_CurrentData bit 10                              ; IFCLR REG $0F BIT 10
                                                                                                       [Def: 135]
00BF 1ECF   327b          ifset  t1_CurrentData bit 11   ; if either bit is set,    ; IFSET REG $0F BIT 11
                                                                                                       [Def: 135]
00C0 30C2   328b           jmp   NotHeader               ; it's not a header        ; JMP $00C2       [Def: 331b]
00C1 30C9   329b         jmp     PWMSequenceHeader                                  ; JMP $00C9       [Def: 345b]
            330b 
00C2        331b NotHeader:                                                                           [Ref: 328b]
            332b ; We now know that either bit 10 or 11 is set, and thanks to thread 3, we know that
            333b ; bits 11:10 are not '01', so bit 11 must be set, meaning we have data.
            334b 
00C2 1C10   335b         ifset   ReadyForRed                                        ; IFSET REG $10 BIT 0
                                                                                                       [Def: 139]
00C3 30CF   336b           jmp   ReceivePWM_Red                                     ; JMP $00CF       [Def: 354b]
00C4 1C50   337b         ifset   ReadyForGreen                                      ; IFSET REG $10 BIT 1
                                                                                                       [Def: 140]
00C5 30D5   338b           jmp   ReceivePWM_Green                                   ; JMP $00D5       [Def: 362b]
00C6 1C90   339b         ifset   ReadyForBlue                                       ; IFSET REG $10 BIT 2
                                                                                                       [Def: 141]
00C7 30DB   340b           jmp   ReceivePWM_Blue                                    ; JMP $00DB       [Def: 370b]
            341b 
            342b ; Huh, we've received data without a header.  Throw it out.
00C8 30AB   343b         jmp   t1_main                                              ; JMP $00AB       [Def: 278b]
            344b 
00C9        345b PWMSequenceHeader:                                                                   [Ref: 329b]
            346b ; Now we know it must be a PWM sequence header.
00C9 3D0F   347b         mov     A, t1_CurrentData                                  ; MOVN A,REG $0F   [Def: 135]
00CA 2903   348b         and     A, #$3FF                                           ; AND A,#$03FF
00CB 3F11   349b         mov     t1_Receiving_Time, A    ; save the time            ; MOVN REG $11,A   [Def: 144]
00CC 2C01   350b         mov     A, #bitmask(ReadyForRed)                           ; MOVN A,#$0001    [Def: 139]
00CD 3F10   351b         mov     t1_ReceivePWMState, A   ; update the PWM state to store 'red' next time
                                                                                    ; MOVN REG $10,A
                                                                                                       [Def: 138]
00CE 30AB   352b         jmp     t1_main                                            ; JMP $00AB       [Def: 278b]

ASMT4 1.003  --  File pwm_t1.asm  --  6/17/05 18:29:50  --  Page 37




            353b 
00CF        354b ReceivePWM_Red:                                                                      [Ref: 336b]
00CF 3D0F   355b         mov     A, t1_CurrentData                                  ; MOVN A,REG $0F   [Def: 135]
00D0 2903   356b         and     A, #$3FF                                           ; AND A,#$03FF
00D1 3F12   357b         mov     t1_Receiving_Red, A     ; save red                 ; MOVN REG $12,A   [Def: 145]
00D2 2C02   358b         mov     A, #bitmask(ReadyForGreen)                         ; MOVN A,#$0002    [Def: 140]
00D3 3F10   359b         mov     t1_ReceivePWMState, A   ; update the PWM state to store 'green' next time
                                                                                    ; MOVN REG $10,A
                                                                                                       [Def: 138]
00D4 30AB   360b         jmp     t1_main                                            ; JMP $00AB       [Def: 278b]
            361b 
00D5        362b ReceivePWM_Green:                                                                    [Ref: 338b]
00D5 3D0F   363b         mov     A, t1_CurrentData                                  ; MOVN A,REG $0F   [Def: 135]
00D6 2903   364b         and     A, #$3FF                                           ; AND A,#$03FF
00D7 3F13   365b         mov     t1_Receiving_Green, A   ; save green               ; MOVN REG $13,A   [Def: 146]
00D8 2C04   366b         mov     A, #bitmask(ReadyForBlue)                          ; MOVN A,#$0004    [Def: 141]
00D9 3F10   367b         mov     t1_ReceivePWMState, A   ; update the PWM state to store 'blue' next time
                                                                                    ; MOVN REG $10,A
                                                                                                       [Def: 138]
00DA 30AB   368b         jmp     t1_main                                            ; JMP $00AB       [Def: 278b]
            369b 
00DB        370b ReceivePWM_Blue:                                                                     [Ref: 340b]
00DB 3D0F   371b         mov     A, t1_CurrentData                                  ; MOVN A,REG $0F   [Def: 135]
00DC 2903   372b         and     A, #$3FF                                           ; AND A,#$03FF
00DD 3F14   373b         mov     t1_Receiving_Blue, A    ; save blue                ; MOVN REG $14,A   [Def: 147]
00DE 0ED0   374b         clr     t1_ReceivePWMState                                 ; CLR REG $10      [Def: 138]
            375b 
            376b         ; we've received a complete PWM packet
00DF        377b t1_WaitForBufferEmpty:                                                               [Ref: 380b]
00DF 3C02   378b         clrwdt  ; we may be here a while, and don't want to reset
                                                                                    ; CLRWDT
00E0 1C0C   379b         ifset   t1_DataReady            ; thread 2 will clear this flag as soon as it reads the\
 previous data
                                                                                    ; IFSET REG $0C BIT 0
                                                                                                       [Def: 150]
00E1 30DF   380b           jmp   t1_WaitForBufferEmpty                              ; JMP $00DF       [Def: 377b]
            381b 
            382b 
00E2 3D11   383b         mov     A, t1_Receiving_Time                               ; MOVN A,REG $11   [Def: 144]
00E3 3F15   384b         mov     t1_Time_Data, A                                    ; MOVN REG $15,A   [Def: 157]
00E4 3D12   385b         mov     A, t1_Receiving_Red                                ; MOVN A,REG $12   [Def: 145]
00E5 3F16   386b         mov     t1_Red_Data, A                                     ; MOVN REG $16,A   [Def: 158]
00E6 3D13   387b         mov     A, t1_Receiving_Green                              ; MOVN A,REG $13   [Def: 146]
00E7 3F17   388b         mov     t1_Green_Data, A                                   ; MOVN REG $17,A   [Def: 159]
00E8 3D14   389b         mov     A, t1_Receiving_Blue                               ; MOVN A,REG $14   [Def: 147]
00E9 3F18   390b         mov     t1_Blue_Data, A                                    ; MOVN REG $18,A   [Def: 160]
            391b 
00EA 100C   392b         bset    t1_DataReady                                       ; BSET REG $0C BIT 0
                                                                                                       [Def: 150]
            393b 
00EB 30AB   394b         jmp     t1_main                                            ; JMP $00AB       [Def: 278b]
            395b 
            396b 
            397b         ; should never get here!
00EC 3FFF   398b         reset                                                      ; RESET
            399b 
            400b 
            401b 
00ED        402b         seg subr
            403b 
            404b 
00ED        405b initAnalog:                                                                           [Ref: 43b]
            406b 
00ED 2C01   407b         mov     a, #val mfgOscVectorAddr                           ; MOVN A,#$0001    [Def: 12b]
00EE 3E03   408b         lookup  A, A                                               ; LOOKUP A,A
00EF 1BC1   409b         ifclr   A bit 15                                           ; IFCLR A BIT 15  [Def: 401a]
00F0 30F3   410b           jmp   OscVectorInitialized                               ; JMP $00F3       [Def: 412b]
00F1 2C20   411b         mov     A, #baseOCTLmask                                   ; MOVN A,#$0020
                                                                                               [Def: 269 270 271]
00F2 2302                                                                           ; OR A,#$0200
00F3        412b OscVectorInitialized:                                                                [Ref: 410b]
00F3 3FF4   413b         mov     OCTL, A                                            ; MOVN OCTL,A     [Def: 455a]
            414b 

ASMT4 1.003  --  File pwm_t1.asm  --  6/17/05 18:29:50  --  Page 38




00F4 2C2E   415b         mov     A, #psel_ground + bitmask pstr                     ; MOVN A,#$002E
                                                                                     [Def: 609a* 634a 655a* 581a]
00F5 3FF5   416b         mov     TCTL, A                                            ; MOVN TCTL,A     [Def: 456a]
            417b 
00F6 2C30   418b         mov     A, #baseXHCTLmask                                  ; MOVN A,#$0030
                                                                                               [Def: 273 274 275]
00F7 2301                                                                           ; OR A,#$0100
00F8 3FFC   419b         mov     XHCTL, A                                           ; MOVN XHCTL,A  [Def: 452a.2]
            420b 
00F9 2C90   421b         mov     A, #baseXLCTLmask                                  ; MOVN A,#$0090
                                                                                       [Def: 277 278 279 280 281]
00FA 2303                                                                           ; OR A,#$0300
00FB 3FF8   422b         mov     XLCTL, A                                           ; MOVN XLCTL,A  [Def: 451a.2]
            423b 
00FC 2C00   424b         mov     A, #baseYHCTLmask                                  ; MOVN A,#$0000    [Def: 283]
00FD 3FFD   425b         mov     YHCTL, A                                           ; MOVN YHCTL,A  [Def: 452a.3]
            426b 
00FE 2C40   427b         mov     A, #baseYLCTLmask                                  ; MOVN A,#$0040
                                                                                                   [Def: 285 287]
00FF 3FF9   428b         mov     YLCTL, A                                           ; MOVN YLCTL,A  [Def: 451a.3]
            429b 
0100 3E02   430b         ret                                                        ; RET
            431b 
0138        432b         seg code                     295 
             296 include pwm_t2.asm
              1c ; Pole Dance Revolution - Thread 2
              2c ;
              3c ; Thread 2 handles the PWM of the LEDs.  During thread 2, we have a significant
              4c ; limitation.  Namely, we must have the analog block enabled, which in turn
              5c ; enables the analog interrupts.  Unfortunately, since the analog interrupts
              6c ; are enabled, we are unable to have any other interrupt sources from thread 2.
              7c ;
              8c ; In the first round of design, the PDR code handled the pulse width modulation
              9c ; in thread 3 in order to use CTIME.  Thread 2 then handled the SPI
             10c ; transactions.  Unfortunately, since the conversion interrupts could not be
             11c ; masked, we were unable to distinguish between an SPI interrupt and a
             12c ; conversion interrupt.  The best solution seemed to be to switch the thread 2
             13c ; and 3 functions, and have thread 2 deal with the pulse width modulation.  By
             14c ; using interleaved mode, we are able to leave thread 2 awake at all times, and
             15c ; threads 1 and 3 then share the remaining 50% of the CPU time.  In order to
             16c ; time the PWM, thread 2 sits in idle loops.
             17c ;
             18c ; In thread 2 during initialization, we toggle all LEDs on and off until we
             19c ; receive our address.  The LEDs will blink white at approximately 2Hz.  Once
             20c ; we receive an address, normal thread processing begins.
             21c ;
             22c ; Thread 2 maintains a counter, whose initial value is passed in via a command,
             23c ; That indicates how many minimum PWM cycles the current data is maintained.
             24c ; As long as the counter is non-zero, we ignore any new data from thread 1.
             25c ; Once the counter reaches zero, it pegs, but we keep our current data until
             26c ; thread 1 has new data for us.
             27c ;
             28c ; Once thread 1 has new data for us and our counter has timed out, we copy the
             29c ; data from thread 1 into our own buffer and clear the t1_dataReady flag,
             30c ; telling therad 1 we have successfully received the data.  Each PWM cycle, we
             31c ; reinitialize our working register from this thread 2 data buffer.  Then, each
             32c ; 10 * 2^N instructions, we rotate the working registers and update the LEDs
             33c ; based on the state of the carry flag.  
             34c ;
             35c ; Using this method, we are able to acheive 10 bits of resolution on our PWMs.
             36c ; We have 10us of resolution on updating the LEDs, and our cycle repeats at a
             37c ; frequency of approximately 100Hz (actually 97.7Hz).
             38c ;
             39c ;
             40c 
0138         41c t2_start:                                                                             [Ref: 56b]
             42c ; make sure we copy data at the first opportunity
0138 0EE0    43c         clr t2_Time_Data                                           ; CLR REG $20      [Def: 168]
             44c 
             45c 
             46c ; This is an initialization loop that we sit in until we have our address.
             47c ; While in this loop, we turn all the LEDs on and off repeatedly.
0139         48c t2_toggleLights:                                                                      [Ref: 70c]

ASMT4 1.003  --  File pwm_t2.asm  --  6/17/05 18:29:50  --  Page 39




0139 2C0E    49c         mov     A, #bitmask_PWMs        ; turn on all LEDs         ; MOVN A,#$000E
                                                                                           [Def: 219 220 221 222]
013A 05C7    50c         or      POUT, A                                            ; OR POUT,A       [Def: 407a]
             51c 
013B 2C24    52c         mov     A, #$F424               ; number chosen to cause LEDs to blink at ~2Hz.
                                                                                    ; MOVN A,#$0024
013C 23F4                                                                           ; OR A,#$F400
013D         53c t2_OnWaitingLoop:                                                                     [Ref: 58c]
013D 1C4C    54c         ifset   t1_HaveAddress                                     ; IFSET REG $0C BIT 1
                                                                                                       [Def: 154]
013E 314A    55c           jmp   t2_main                                            ; JMP $014A        [Def: 72c]
             56c 
013F 0FC1    57c         loop    A                                                  ; LOOP A          [Def: 401a]
0140 313D    58c           jmp   t2_OnWaitingLoop                                   ; JMP $013D        [Def: 53c]
             59c 
0141 24F1    60c         mov     A, #not(bitmask_PWMs)   ; turn off all LEDs        ; MOVN A,#$FFF1
                                                                                           [Def: 219 220 221 222]
0142 04C7    61c         and     POUT, A                                            ; AND POUT,A      [Def: 407a]
0143 2C24    62c         mov     A, #$F424                                          ; MOVN A,#$0024
0144 23F4                                                                           ; OR A,#$F400
0145         63c t2_OffWaitingLoop:                                                                    [Ref: 68c]
0145 1C4C    64c         ifset   t1_HaveAddress                                     ; IFSET REG $0C BIT 1
                                                                                                       [Def: 154]
0146 314A    65c           jmp   t2_main                                            ; JMP $014A        [Def: 72c]
             66c 
0147 0FC1    67c         loop    A                                                  ; LOOP A          [Def: 401a]
0148 3145    68c           jmp   t2_OffWaitingLoop                                  ; JMP $0145        [Def: 63c]
             69c         ; stay in the loop until we have our address
0149 3139    70c         jmp     t2_toggleLights                                    ; JMP $0139        [Def: 48c]
             71c 
014A         72c t2_main:                                                                     [Ref: 55c 65c 225c]
             73c         ; this entire loop needs to take 10,000 instructions in
             74c         ; order to acheive the PWM cycle frequency we want (100Hz).
             75c         ; (actually takes 10,235 - close enough?)
             76c 
014A 1809    77c         ifclr thr bit 0                 ; 1                        ; IFCLR CCTL BIT 0
                                                                                                      [Def: 532a]
014B 3FFF    78c           reset                         ; 2                        ; RESET
             79c 
             80c ; we do a whole lot of footwork to have the setup take the same number of instructions
             81c ; regardless of your path through this code (whether our counter has timed out, we have
             82c ; new data to process, et cetera).  I'm probably being anal, but oh well...
014C 0DE0    83c         tst  t2_Time_Data               ; 3                        ; TST REG $20      [Def: 168]
014D 1F40    84c         ifz                             ; 4                        ; IFZ    [Def: 468a.3 468a.1]
014E 3152    85c           jmp CounterPegged             ; 5                        ; JMP $0152        [Def: 92c]
             86c 
014F 0FE0    87c         loop t2_Time_Data               ; 6                        ; LOOP REG $20     [Def: 168]
0150 3161    88c           jmp NoCounterTimeout          ; 7                        ; JMP $0161       [Def: 118c]
             89c 
0151 3155    90c         jmp CheckForNewData             ; 8                        ; JMP $0155        [Def: 97c]
             91c 
0152         92c CounterPegged:                          ; 5                                           [Ref: 85c]
0152 3F01    93c         nop                             ; 6                        ; NOP
0153 3F01    94c         nop                             ; 7                        ; NOP
0154 3F01    95c         nop                             ; 8                        ; NOP
             96c 
0155         97c CheckForNewData:                                                                      [Ref: 90c]
0155 180C    98c         ifclr t1_DataReady              ; 9                        ; IFCLR REG $0C BIT 0
                                                                                                       [Def: 150]
0156 3164    99c           jmp NoNewData                 ; 10                       ; JMP $0164       [Def: 123c]
            100c 
            101c         ; initialize t2 regs from whatever's in t1
0157 3D16   102c         mov A, t1_Red_Data              ; 11                       ; MOVN A,REG $16   [Def: 158]
0158 3F21   103c         mov t2_Red_Data, A              ; 12                       ; MOVN REG $21,A   [Def: 169]
            104c 
0159 3D17   105c         mov A, t1_Green_Data            ; 13                       ; MOVN A,REG $17   [Def: 159]
015A 3F22   106c         mov t2_Green_Data, A            ; 14                       ; MOVN REG $22,A   [Def: 170]
            107c 
015B 3D18   108c         mov A, t1_Blue_Data             ; 15                       ; MOVN A,REG $18   [Def: 160]
015C 3F23   109c         mov t2_Blue_Data, A             ; 16                       ; MOVN REG $23,A   [Def: 171]
            110c 
015D 3D15   111c         mov A, t1_Time_Data             ; 17                       ; MOVN A,REG $15   [Def: 157]
015E 3F20   112c         mov t2_Time_Data, A             ; 18                       ; MOVN REG $20,A   [Def: 168]

ASMT4 1.003  --  File pwm_t2.asm  --  6/17/05 18:29:50  --  Page 40




            113c 
015F 140C   114c         bclr t1_DataReady               ; 19                       ; BCLR REG $0C BIT 0
                                                                                                       [Def: 150]
            115c 
0160 316E   116c         jmp Do_PWM                      ; 20                       ; JMP $016E       [Def: 135c]
            117c         
0161        118c NoCounterTimeout:                       ; 7                                           [Ref: 88c]
0161 3F01   119c         nop                             ; 8                        ; NOP
0162 3F01   120c         nop                             ; 9                        ; NOP
0163 3F01   121c         nop                             ; 10                       ; NOP
            122c 
0164        123c NoNewData:                              ; 10                                          [Ref: 99c]
0164 3F01   124c         nop                             ; 11                       ; NOP
0165 3F01   125c         nop                             ; 12                       ; NOP
0166 3F01   126c         nop                             ; 13                       ; NOP
0167 3F01   127c         nop                             ; 14                       ; NOP
0168 3F01   128c         nop                             ; 15                       ; NOP
0169 3F01   129c         nop                             ; 16                       ; NOP
016A 3F01   130c         nop                             ; 17                       ; NOP
016B 3F01   131c         nop                             ; 18                       ; NOP
016C 3F01   132c         nop                             ; 19                       ; NOP
016D 3F01   133c         nop                             ; 20                       ; NOP
            134c 
016E        135c Do_PWM:                                 ; 20                                         [Ref: 116c]
            136c         ; move current data into our working registers
016E 3D21   137c         mov A, t2_Red_Data                                         ; MOVN A,REG $21   [Def: 169]
016F 3F24   138c         mov t2_Red_Rotate, A                                       ; MOVN REG $24,A   [Def: 175]
            139c 
0170 3D22   140c         mov A, t2_Green_Data                                       ; MOVN A,REG $22   [Def: 170]
0171 3F25   141c         mov t2_Green_Rotate, A                                     ; MOVN REG $25,A   [Def: 176]
            142c 
0172 3D23   143c         mov A, t2_Blue_Data                                        ; MOVN A,REG $23   [Def: 171]
0173 3F26   144c         mov t2_Blue_Rotate, A           ; 27 instructions overhead (including the jump to t2_ma\
in)
                                                                                    ; MOVN REG $26,A
                                                                                                       [Def: 177]
            145c 
            146c ; now to update and sleep:
0174 3901   147c         call t2_UpdateLEDs              ; 15 instructions          ; CALL $0101      [Def: 233c]
            148c ; cycle 1: 10 instructions (sorry, it's going to be 15)
            149c 
0175 3901   150c         call t2_UpdateLEDs              ; 15 instructions          ; CALL $0101      [Def: 233c]
            151c ; cycle 2: 20 instructions
0176 3F01   152c         nop                                                        ; NOP
0177 3F01   153c         nop                                                        ; NOP
0178 3F01   154c         nop                                                        ; NOP
0179 3F01   155c         nop                                                        ; NOP
017A 3F01   156c         nop                             ; +5 = 20 instructions     ; NOP
            157c 
            158c 
017B 3901   159c         call t2_UpdateLEDs              ; 15 instructions          ; CALL $0101      [Def: 233c]
            160c ; cycle 3: 40 instructions
017C 2C02   161c         mov A, #2                       ; 1 instruction            ; MOVN A,#$0002
017D 390F   162c         call t2_Wait_10A_and_4          ; 24 instructions          ; CALL $010F      [Def: 259c]
            163c                                         ;    = 40 instructions
            164c 
            165c 
017E 3901   166c         call t2_UpdateLEDs              ; 15 instructions          ; CALL $0101      [Def: 233c]
            167c ; cycle 4: 80 instructions
017F 2C06   168c         mov A, #6                       ; 1 instruction            ; MOVN A,#$0006
0180 390F   169c         call t2_Wait_10A_and_4          ; 64 instructions          ; CALL $010F      [Def: 259c]
            170c                                         ;    = 80 instructions
            171c 
            172c 
0181 3901   173c         call t2_UpdateLEDs              ; 15 instructions          ; CALL $0101      [Def: 233c]
            174c ; cycle 5: 160 instructions
0182 2C0E   175c         mov A, #14                      ; 1 instruction            ; MOVN A,#$000E
0183 390F   176c         call t2_Wait_10A_and_4          ; 144 instructions         ; CALL $010F      [Def: 259c]
            177c                                         ;    = 160 instructions
            178c 
            179c 
0184 3901   180c         call t2_UpdateLEDs              ; 15 instructions          ; CALL $0101      [Def: 233c]
            181c ; cycle 6: 320 instructions

ASMT4 1.003  --  File pwm_t2.asm  --  6/17/05 18:29:50  --  Page 41




0185 2C1E   182c         mov A, #30                      ; 1 instruction            ; MOVN A,#$001E
0186 390F   183c         call t2_Wait_10A_and_4          ; 304 instructions         ; CALL $010F      [Def: 259c]
            184c                                         ;    = 320 instructions
            185c 
            186c 
0187 3901   187c         call t2_UpdateLEDs              ; 15 instructions          ; CALL $0101      [Def: 233c]
            188c ; cycle 7: 640 instructions
0188 2C3E   189c         mov A, #62                      ; 1 instruction            ; MOVN A,#$003E
0189 390F   190c         call t2_Wait_10A_and_4          ; 624 instructions         ; CALL $010F      [Def: 259c]
            191c                                         ;    = 640 instructions
            192c 
            193c 
018A 3901   194c         call t2_UpdateLEDs              ; 15 instructions          ; CALL $0101      [Def: 233c]
            195c ; cycle 8: 1280 instructions
018B 2C7E   196c         mov A, #126                     ; 1 instruction            ; MOVN A,#$007E
018C 390F   197c         call t2_Wait_10A_and_4          ; 1264 instructions        ; CALL $010F      [Def: 259c]
            198c                                         ;    = 1280 instructions
            199c 
            200c 
018D 3901   201c         call t2_UpdateLEDs              ; 15 instructions          ; CALL $0101      [Def: 233c]
            202c ; cycle 9: 2560 instructions
018E 2CFE   203c         mov A, #254                     ; 1 instruction            ; MOVN A,#$00FE
018F 390F   204c         call t2_Wait_10A_and_4          ; 2544 instructions        ; CALL $010F      [Def: 259c]
            205c                                         ;    = 2560 instructions
            206c 
            207c 
0190 3901   208c         call t2_UpdateLEDs              ; 15 instructions          ; CALL $0101      [Def: 233c]
            209c ; cycle 10: 5120 instructions
            210c                                         ; 27 instructions (overhead)
0191 391C   211c         call t2_InitializePorts         ; 15 instructions          ; CALL $011C      [Def: 274c]
            212c 
0192 2CF8   213c         mov A, #504                     ; 2 instructions           ; MOVN A,#$00F8
0193 2301                                                                           ; OR A,#$0100
0194 390F   214c         call t2_Wait_10A_and_4          ; 5054 instructions        ; CALL $010F      [Def: 259c]
            215c 
0195 3F01   216c         nop                                                        ; NOP
0196 3F01   217c         nop                                                        ; NOP
0197 3F01   218c         nop                                                        ; NOP
0198 3F01   219c         nop                                                        ; NOP
0199 3F01   220c         nop                                                        ; NOP
019A 3F01   221c         nop                                                        ; NOP
019B 3F01   222c         nop                             ; 7 instructions           ; NOP
            223c                                         ;   = 5120 instructions
            224c 
019C 314A   225c         jmp t2_main                                                ; JMP $014A        [Def: 72c]
            226c 
            227c         ; should never get here!
019D 3FFF   228c         reset                                                      ; RESET
            229c 
            230c 
0101        231c         seg subr
            232c 
0101        233c t2_UpdateLEDs:                                [Ref: 147c 150c 159c 166c 173c 180c 187c 194c ...]
            234c ; We are relying on all LEDs being either in the low byte or the 
            235c ; high byte.
0101 24F1   236c         mov A, #not(bitmask_PWMs)       ; assume no PWMs on        ; MOVN A,#$FFF1
                                                                                           [Def: 219 220 221 222]
            237c 
0102 09E4   238c         rrc t2_Red_Rotate               ; turn on red?             ; RRC REG $24      [Def: 175]
0103 1EC0   239c         ifc                                                        ; IFC    [Def: 470a.3 470a.1]
0104 1041   240c           bset  A bit PWM_Red                                      ; BSET A BIT 1
                                                                                                  [Def: 215 401a]
            241c 
0105 09E5   242c         rrc t2_Green_Rotate             ; turn on green?           ; RRC REG $25      [Def: 176]
0106 1EC0   243c         ifc                                                        ; IFC    [Def: 470a.3 470a.1]
0107 1081   244c           bset  A bit PWM_Green                                    ; BSET A BIT 2
                                                                                                  [Def: 216 401a]
            245c 
0108 09E6   246c         rrc t2_Blue_Rotate              ; turn on blue?            ; RRC REG $26      [Def: 177]
0109 1EC0   247c         ifc                                                        ; IFC    [Def: 470a.3 470a.1]
010A 10C1   248c           bset  A bit PWM_Blue                                     ; BSET A BIT 3
                                                                                                  [Def: 217 401a]
            249c 

ASMT4 1.003  --  File pwm_t2.asm  --  6/17/05 18:29:50  --  Page 42




            250c         ; We can't read-modify-write POUT because thread 3 might
            251c         ; be changing the state of POUT bit SSB.
010B 04C7   252c         and POUT, A                     ; turn off any LED that should be off
                                                                                    ; AND POUT,A
                                                                                                      [Def: 407a]
010C 2A0E   253c         and A, #bitmask_PWMs                                       ; AND A,#$000E
                                                                                           [Def: 219 220 221 222]
010D 05C7   254c         or  POUT, A                     ; turn on any LEDs that should be on
                                                                                    ; OR POUT,A
                                                                                                      [Def: 407a]
            255c 
010E 3E02   256c         ret                                                        ; RET
            257c         
            258c 
010F        259c t2_Wait_10A_and_4:                      ;       1 for the call
                                                              [Ref: 162c 169c 176c 183c 190c 197c 204c 214c 269c]
010F 3F01   260c         nop                             ; 1                        ; NOP
0110 3F01   261c         nop                             ; 2                        ; NOP
0111 3F01   262c         nop                             ; 3                        ; NOP
0112 3F01   263c         nop                             ; 4                        ; NOP
0113 3F01   264c         nop                             ; 5                        ; NOP
0114 3F01   265c         nop                             ; 6                        ; NOP
0115 3F01   266c         nop                             ; 7                        ; NOP
0116 3F01   267c         nop                             ; 8                        ; NOP
0117 0FC1   268c         loop A                          ; 9                        ; LOOP A          [Def: 401a]
0118 310F   269c           jmp   t2_Wait_10A_and_4       ; 10    10 * A + 1         ; JMP $010F       [Def: 259c]
0119 3F01   270c         nop                             ;       10 * A + 2         ; NOP
011A 3F01   271c         nop                             ;       10 * A + 3         ; NOP
011B 3E02   272c         ret                             ;       10 * A + 4         ; RET
            273c 
011C        274c t2_initializePorts:                                                                  [Ref: 211c]
            275c ; We're doing read-modify-writes on port registers while in TALT mode.
            276c ; Why is this safe?  Thread 2 only changes POUT of the PWMs, which are
            277c ; all protected from thread 3 by "preservePins_POUT".
            278c ;
            279c ; By the time thread 2 is allowed to call this routine, thread 3 is
            280c ; only changing PAUX (which isn't initialized here) and POUT bit SSB, 
            281c ; which is protected by preserve pins.
            282c 
            283c ; Thread 3 regularly takes care of PAUX, and thread 2 isn't allowed to touch it.
            284c ;       mov A, #basePAUXmask
            285c ;       mov PAUX, A
            286c 
011C 2C0E   287c         mov A, #basePDIRmask                                       ; MOVN A,#$000E
                                                                                                   [Def: 242 243]
011D 0606   288c         xor A, PDIR                                                ; XOR A,PDIR      [Def: 406a]
011E 29EF   289c         and A, #NOT(preservePins_PDIR)                             ; AND A,#$EFFF
                                                                                                   [Def: 245 246]
011F 06C6   290c         xor PDIR, A                                                ; XOR PDIR,A      [Def: 406a]
            291c 
0120 2C31   292c         mov A, #basePCTLmask                                       ; MOVN A,#$0031
                                                                                           [Def: 248 249 250 251]
0121 23F3                                                                           ; OR A,#$F300
0122 3F04   293c         mov PCTL, A                                                ; MOVN PCTL,A     [Def: 404a]
            294c 
0123 2C40   295c         mov A, #basePIEmask                                        ; MOVN A,#$0040
                                                                                                   [Def: 253 254]
0124 3F05   296c         mov PIE, A                                                 ; MOVN PIE,A      [Def: 405a]
            297c 
0125 2F08   298c         mov A, #basePOUTmask                                       ; MOVN A,#$0800
                                                                                                   [Def: 256 257]
0126 0607   299c         xor A, POUT                                                ; XOR A,POUT      [Def: 407a]
0127 28B1   300c         and A, #NOT(preservePins_POUT)                             ; AND A,#$FFB1
                                                                                               [Def: 259 260 261]
0128 06C7   301c         xor POUT, A                                                ; XOR POUT,A      [Def: 407a]
            302c 
0129 3E02   303c         ret                                                        ; RET
            304c 
            305c 
019E        306c         seg code             297 
             298 include pwm_t3.asm
              1d ; Pole Dance Revolution - Thread 3
              2d ;

ASMT4 1.003  --  File pwm_t3.asm  --  6/17/05 18:29:50  --  Page 43




              3d ; Thread 3 Overview
              4d ;
              5d ; Thread 3 handles all incoming SPI transactions from the host.
              6d ;
              7d ; During initialization, we sleep in thread 3 until we see our AddressIn line go
              8d ; low, signaling our turn to take an address.  Once the line goes low, we receive
              9d ; one word over the SPI port, and set our address to whichever address that word
             10d ; was sent to.  We then drive our AddressOut line low for one word, signalling
             11d ; the next device in the chain to take an address.
             12d ;
             13d ; After we receive each word over the SPI lines, we first assume the data is not
             14d ; for us and clear PAUX bit 11 to keep from driving data next round.  We then
             15d ; check the address that the command is sent to, comparing it to our own.  If the
             16d ; address doesn't match, we're done, so we wait for the next transaction.
             17d ;
             18d ; As soon as we verify the received data is addressed to us, we set PAUX bit 11
             19d ; to drive data next round.  We then copy our current sensing data (since we're
             20d ; in 1-CHN mode, sensing data is always from the same sensor) into SPITX.
             21d ;
             22d ; To process the command, we first check to see if it's a read register command.
             23d ; If so, we copy the register indicated by the command into SPITX.  Otherwise, we
             24d ; check for a write register command.  Since a write register command is three
             25d ; words, we use a state machine to keep track of which word we're receiving.  If
             26d ; at any point in the middle of a write command we receive an unexpected word,
             27d ; for example a read command, we reinitialize the state machine.
             28d ;
             29d ; Once we determine the command is for us, but not part of a read or write
             30d ; register command, we move it into the next available place in the SPI buffer
             31d ; for thread 1 to deal with.
             32d ;
             33d ;
             34d ; During an SPI transaction, we require the following minimum times from
             35d ; the host:
             36d ;
             37d ; Packet type   Total cycle time        Time between end of packet and start of next
             38d ;                                       (the amount of time it takes data to become valid)
             39d ; Not for us    15us                    2us
             40d ; Read Reg      33us                    24us
             41d ; Write Reg     42us                    13us
             42d ; PWM data      41us                    13us
             43d ;
             44d ; The SSB low time does not contribute to the minimum cycle time.
             45d 
019E         46d t3_start:                                                                             [Ref: 61b]
             47d         ; initialize this to a harmless value while testing.
019E 2C35    48d         mov     A, #$35                                            ; MOVN A,#$0035
019F 3F33    49d         mov     t3_WriteRegisterAddress, A                         ; MOVN REG $33,A   [Def: 190]
             50d 
01A0 2DEF    51d         mov     X, #val(PAUX)                                      ; MOVN X,#$EF     [Def: 436a]
01A1 4EEF    52d         clr     ind PAUX                ; initialize ports doesn't touch PAUX
                                                                                    ; CLR $2F @X
                                                                                                      [Def: 436a]
             53d 
01A2 2D40    54d         mov     X, #val(SPI_Buffer)     ; initialize SPI buffer    ; MOVN X,#$40      [Def: 202]
01A3 392A    55d         call    t3_InitializePorts                                 ; CALL $012A      [Def: 248d]
             56d 
             57d 
01A4         58d initializeAddress:
             59d         ; sleep until it's our turn to receive an address
             60d         ; it's our turn to receive an address when our set address line is high
01A4 1585    61d         bclr    PIE bit SSB     ; ignore all SPI transactions until our turn
                                                                                    ; BCLR PIE BIT 6
                                                                                                  [Def: 224 405a]
             62d 
             63d 
             64d         ; interrupt when the set address line is low
01A5 1007    65d         bset    POUT bit SetAddressIn                              ; BSET POUT BIT 0
                                                                                                  [Def: 212 407a]
01A6 1005    66d         bset    PIE  bit SetAddressIn                              ; BSET PIE BIT 0
                                                                                                  [Def: 212 405a]
01A7 0ECA    67d         clr     ctime                                              ; CLR CTIME       [Def: 410a]
             68d 
             69d         ; it's our turn to get our address

ASMT4 1.003  --  File pwm_t3.asm  --  6/17/05 18:29:50  --  Page 44




01A8 1405    70d         bclr    PIE  bit SetAddressIn                              ; BCLR PIE BIT 0
                                                                                                  [Def: 212 405a]
01A9 1185    71d         bset    PIE bit SSB                                        ; BSET PIE BIT 6
                                                                                                  [Def: 224 405a]
             72d 
01AA 1187    73d         bset    POUT bit SSB    ; interrupt on IO6 low             ; BSET POUT BIT 6
                                                                                                  [Def: 224 407a]
01AB 0ECA    74d         clr     ctime                                              ; CLR CTIME       [Def: 410a]
01AC 1587    75d         bclr    POUT bit SSB    ; interrupt on IO6 high (transaction complete)
                                                                                    ; BCLR POUT BIT 6
                                                                                                  [Def: 224 407a]
01AD 0ECA    76d         clr     ctime                                              ; CLR CTIME       [Def: 410a]
             77d 
             78d         ; we now have our address!
01AE 3DEE    79d         mov     A, SPIRX                                           ; MOVN A,REG $EE  [Def: 435a]
01AF 3F31    80d         mov     t3_CurrentData, A                                  ; MOVN REG $31,A   [Def: 187]
01B0 2BF0    81d         and     A, #$F000       ; isolate address                  ; AND A,#$F000
01B1 3F30    82d         mov     MyAddress, A    ; and store it                     ; MOVN REG $30,A   [Def: 184]
             83d 
             84d         ; tell other threads to start processing data
01B2 104C    85d         bset    t1_HaveAddress                                     ; BSET REG $0C BIT 1
                                                                                                       [Def: 154]
             86d 
             87d         ; tell the next guy it's his turn to get his address by driving
             88d         ; the address out pin low
01B3 1306    89d         bset    SetAddressOut   ; drive the addressOut             ; BSET PDIR BIT 12
                                                                                                       [Def: 213]
             90d 
01B4 31C4    91d         jmp     DataForUs                                          ; JMP $01C4       [Def: 122d]
             92d 
01B5         93d t3_main:                                      [Ref: 120d 170d 172d 179d 180d 198d 210d 218d ...]
             94d         ; thread sanity checking
01B5 1849    95d          ifclr thr bit 1                                           ; IFCLR CCTL BIT 1
                                                                                                      [Def: 532a]
01B6 3FFF    96d             reset                                                  ; RESET
             97d 
01B7 1187    98d         bset    POUT bit SSB    ; interrupt on IO6 low             ; BSET POUT BIT 6
                                                                                                  [Def: 224 407a]
01B8 0ECA    99d         clr     ctime                                              ; CLR CTIME       [Def: 410a]
01B9 1587   100d         bclr    POUT bit SSB    ; interrupt on IO6 high (transaction complete)
                                                                                    ; BCLR POUT BIT 6
                                                                                                  [Def: 224 407a]
01BA 0ECA   101d         clr     ctime                                              ; CLR CTIME       [Def: 410a]
            102d 
01BB 0EC1   103d         clr     A                                                  ; CLR A           [Def: 401a]
01BC 3FEF   104d         movn    PAUX, A         ; don't drive data next round      ; MOVN REG $EF,A  [Def: 436a]
            105d                                 ; keep in mind, PAUX is not direct, and the rest of
            106d                                 ; PAUX ought to be clear anyway.
            107d 
            108d         ; we now have data
01BD 3DEE   109d         mov     A, SPIRX                                           ; MOVN A,REG $EE  [Def: 435a]
01BE 3F31   110d         mov     t3_CurrentData, A                                  ; MOVN REG $31,A   [Def: 187]
            111d 
            112d         ; now that we've received at least one word since we set our address,
            113d         ; release the AddressOut pin so that if our "guest" resets, he will
            114d         ; flash lights instead of taking a random address.
01BF 1706   115d         bclr    SetAddressOut                                      ; BCLR PDIR BIT 12
                                                                                                       [Def: 213]
            116d 
01C0 0630   117d         xor     A, MyAddress    ; check if it's for us             ; XOR A,REG $30    [Def: 184]
01C1 2BF0   118d         and     A, #$F000                                          ; AND A,#$F000
01C2 1B40   119d         ifnz                    ; data not for us -                ; IFNZ   [Def: 866a.3 866a.1]
01C3 31B5   120d           jmp   t3_main         ; do nothing                       ; JMP $01B5        [Def: 93d]
            121d 
01C4        122d DataForUs:                                                                            [Ref: 91d]
            123d         ; we have data, and it's for us
01C4 2F08   124d         mov     A, #bitmask SDOUT                                  ; MOVN A,#$0800    [Def: 227]
01C5 3FEF   125d         mov     PAUX, A         ; drive data next round            ; MOVN REG $EF,A  [Def: 436a]
            126d 
            127d         ; assume the command was not to read a register...
01C6 3DE0   128d         mov     A, SensorData                                      ; MOVN A,XCH0      [Def: 267]
01C7 3F0B   129d         mov     SPITX, A                                           ; MOVN REG $0B,A  [Def: 412a]
            130d 

ASMT4 1.003  --  File pwm_t3.asm  --  6/17/05 18:29:50  --  Page 45




            131d         ; ...and now check to see if it was
            132d ; The read register command has the following form:
            133d ;    |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
            134d ;    |    ADDRESS    | 0 | 1 | 1 | 0 |            REGISTER           |
            135d ;    |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
            136d 
            137d ; The write register command has the following form:
            138d ;    |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
            139d ;    |    ADDRESS    | 0 | 1 | 0 | 0 |            REGISTER           |
            140d ;    |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
            141d ;    |    ADDRESS    | 1 | 1 | 0 | 0 |           LOW 8 BITS          |
            142d ;    |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
            143d ;    |    ADDRESS    | 1 | 1 | 0 | 1 |          HIGH 8 BITS          |
            144d ;    |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
            145d 
            146d ; A PWM Sequence has the form:
            147d ;    |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
            148d ;    |    ADDRESS    | 0 | 0 |               TIME DELAY              |
            149d ;    |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
            150d ;    |    ADDRESS    | 1 | 0 |              RED PWM DATA             |
            151d ;    |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
            152d ;    |    ADDRESS    | 1 | 0 |            GREEN PWM DATA             |
            153d ;    |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
            154d ;    |    ADDRESS    | 1 | 0 |             BLUE PWM DATA             |
            155d ;    |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
            156d ;
            157d 
01C8 0DB1   158d         mov     A, high t3_CurrentData  ; get our data             ; MOVT A,HIGH REG $31
                                                                                                       [Def: 187]
01C9 2A0F   159d         and     A, #$0F                 ; isolate the command      ; AND A,#$000F
            160d 
01CA 02C2   161d         add     PC, A                                              ; ADD PC,A        [Def: 402a]
            162d 
01CB        163d CommandJumpTable:
            164d 
01CB 31DB   165d         jmp     t3_SendDataToThr1       ; 0000                     ; JMP $01DB       [Def: 184d]
01CC 31DB   166d         jmp     t3_SendDataToThr1       ; 0001                     ; JMP $01DB       [Def: 184d]
01CD 31DB   167d         jmp     t3_SendDataToThr1       ; 0010                     ; JMP $01DB       [Def: 184d]
01CE 31DB   168d         jmp     t3_SendDataToThr1       ; 0011                     ; JMP $01DB       [Def: 184d]
01CF 31EC   169d         jmp     t3_WriteRegister        ; 0100                     ; JMP $01EC       [Def: 213d]
01D0 31B5   170d         jmp     t3_main                 ; 0101                     ; JMP $01B5        [Def: 93d]
01D1 31E5   171d         jmp     t3_ReadRegister         ; 0110                     ; JMP $01E5       [Def: 201d]
01D2 31B5   172d         jmp     t3_main                 ; 0111                     ; JMP $01B5        [Def: 93d]
01D3 31DB   173d         jmp     t3_SendDataToThr1       ; 1000                     ; JMP $01DB       [Def: 184d]
01D4 31DB   174d         jmp     t3_SendDataToThr1       ; 1001                     ; JMP $01DB       [Def: 184d]
01D5 31DB   175d         jmp     t3_SendDataToThr1       ; 1010                     ; JMP $01DB       [Def: 184d]
01D6 31DB   176d         jmp     t3_SendDataToThr1       ; 1011                     ; JMP $01DB       [Def: 184d]
01D7 31EF   177d         jmp     t3_WriteDataLow         ; 1100                     ; JMP $01EF       [Def: 220d]
01D8 31F2   178d         jmp     t3_WriteDataHigh        ; 1101                     ; JMP $01F2       [Def: 227d]
01D9 31B5   179d         jmp     t3_main                 ; 1110                     ; JMP $01B5        [Def: 93d]
01DA 31B5   180d         jmp     t3_main                 ; 1111                     ; JMP $01B5        [Def: 93d]
            181d 
            182d 
            183d 
01DB        184d t3_SendDataToThr1:                                [Ref: 165d 166d 167d 168d 173d 174d 175d 176d]
01DB 3D31   185d         mov     A, t3_CurrentData                                  ; MOVN A,REG $31   [Def: 187]
01DC 40C0   186d         mov     @X, A                                              ; MOVT @X,A
            187d 
            188d         ; update X and our queue pointer
01DD 0140   189d         inc X                                                      ; INC X           [Def: 465a]
01DE 2CE0   190d         mov A, #$E0             ; has our pointer wrapped?         ; MOVN A,#$00E0
01DF 0600   191d         xor A, STATX                                               ; XOR A,STATX     [Def: 400a]
01E0 1F00   192d         ifzl                                                       ; IFZL   [Def: 469a.3 469a.1]
01E1 2D40   193d           mov X, #val(SPI_Buffer)                                  ; MOVN X,#$40      [Def: 202]
            194d 
01E2 0D40   195d         mov     A, X                                               ; MOVS A,X        [Def: 465a]
01E3 3F0E   196d         mov     Q_Tail, A                                          ; MOVN REG $0E,A   [Def: 132]
            197d 
01E4 31B5   198d         jmp   t3_main                                              ; JMP $01B5        [Def: 93d]
            199d 
            200d 
01E5        201d t3_ReadRegister:                                                                     [Ref: 171d]
01E5 3D31   202d         mov     A, t3_CurrentData                                  ; MOVN A,REG $31   [Def: 187]

ASMT4 1.003  --  File pwm_t3.asm  --  6/17/05 18:29:50  --  Page 46




01E6 3F00   203d         mov     STATX, A        ; move register address into X     ; MOVN STATX,A    [Def: 400a]
01E7 4D00   204d         mov     A, @X           ; read from register               ; MOVT A,@X
01E8 3F0B   205d         mov     SPITX, A        ; write register in next SPI transaction
                                                                                    ; MOVN REG $0B,A
                                                                                                      [Def: 412a]
            206d 
01E9 3D0E   207d         mov     A, Q_Tail                                          ; MOVN A,REG $0E   [Def: 132]
01EA 3F00   208d         mov     STATX, A        ; restore buffer location          ; MOVN STATX,A    [Def: 400a]
            209d 
01EB 31B5   210d         jmp     t3_main                                            ; JMP $01B5        [Def: 93d]
            211d 
            212d 
01EC        213d t3_WriteRegister:                                                                    [Ref: 169d]
            214d         ; store address
01EC 3D31   215d         mov     A, t3_CurrentData                                  ; MOVN A,REG $31   [Def: 187]
01ED 3F33   216d         mov     t3_WriteRegisterAddress, A                         ; MOVN REG $33,A   [Def: 190]
            217d 
01EE 31B5   218d         jmp     t3_main                                            ; JMP $01B5        [Def: 93d]
            219d 
01EF        220d t3_WriteDataLow:                                                                     [Ref: 177d]
            221d         ; store low data
01EF 3D31   222d         mov     A, t3_CurrentData                                  ; MOVN A,REG $31   [Def: 187]
01F0 0074   223d         mov     low t3_WriteRegisterData, A                        ; MOVT LOW REG $34,A
                                                                                                       [Def: 192]
            224d 
01F1 31B5   225d         jmp     t3_main                                            ; JMP $01B5        [Def: 93d]
            226d 
01F2        227d t3_WriteDataHigh:                                                                    [Ref: 178d]
            228d         ; store high data
01F2 3D31   229d         mov     A, t3_CurrentData                                  ; MOVN A,REG $31   [Def: 187]
01F3 00B4   230d         mov     high t3_WriteRegisterData, A                       ; MOVT HIGH REG $34,A
                                                                                                       [Def: 192]
            231d 
01F4 3D33   232d         mov     A, t3_WriteRegisterAddress                         ; MOVN A,REG $33   [Def: 190]
01F5 3F00   233d         mov     STATX, A        ; move register address into X     ; MOVN STATX,A    [Def: 400a]
            234d 
01F6 3D34   235d         mov     A, t3_WriteRegisterData                            ; MOVN A,REG $34   [Def: 192]
01F7 40C0   236d         mov     @X, A           ; write to register                ; MOVT @X,A
            237d 
01F8 3D0E   238d         mov     A, Q_Tail                                          ; MOVN A,REG $0E   [Def: 132]
01F9 3F00   239d         mov     STATX, A        ; restore buffer location          ; MOVN STATX,A    [Def: 400a]
            240d 
01FA 31B5   241d         jmp     t3_main                                            ; JMP $01B5        [Def: 93d]
            242d 
01FB 3FFF   243d         reset                                                      ; RESET
            244d 
            245d 
012A        246d         seg subr
            247d         
012A        248d t3_initializePorts:                                                                   [Ref: 55d]
            249d ; We're doing read-modify-writes on port registers while in TALT mode.
            250d ; Why is this safe?  Thread 2 only changes POUT of the PWMs, which are
            251d ; all protected from thread 3 by "preservePins_POUT".
            252d ;
            253d ; By the time thread 2 is allowed to call this routine, thread 3 is
            254d ; only changing PAUX (which isn't initialized here) and POUT bit SSB, 
            255d ; which is protected by preserve pins.
            256d 
            257d ; Thread 3 regularly takes care of PAUX, and thread 2 isn't allowed to touch it.
            258d ;       mov A, #basePAUXmask
            259d ;       mov PAUX, A
            260d 
012A 2C0E   261d         mov A, #basePDIRmask                                       ; MOVN A,#$000E
                                                                                                   [Def: 242 243]
012B 0606   262d         xor A, PDIR                                                ; XOR A,PDIR      [Def: 406a]
012C 29EF   263d         and A, #NOT(preservePins_PDIR)                             ; AND A,#$EFFF
                                                                                                   [Def: 245 246]
012D 06C6   264d         xor PDIR, A                                                ; XOR PDIR,A      [Def: 406a]
            265d 
012E 2C31   266d         mov A, #basePCTLmask                                       ; MOVN A,#$0031
                                                                                           [Def: 248 249 250 251]
012F 23F3                                                                           ; OR A,#$F300
0130 3F04   267d         mov PCTL, A                                                ; MOVN PCTL,A     [Def: 404a]

ASMT4 1.003  --  File pwm_t3.asm  --  6/17/05 18:29:50  --  Page 47




            268d 
0131 2C40   269d         mov A, #basePIEmask                                        ; MOVN A,#$0040
                                                                                                   [Def: 253 254]
0132 3F05   270d         mov PIE, A                                                 ; MOVN PIE,A      [Def: 405a]
            271d 
0133 2F08   272d         mov A, #basePOUTmask                                       ; MOVN A,#$0800
                                                                                                   [Def: 256 257]
0134 0607   273d         xor A, POUT                                                ; XOR A,POUT      [Def: 407a]
0135 28B1   274d         and A, #NOT(preservePins_POUT)                             ; AND A,#$FFB1
                                                                                               [Def: 259 260 261]
0136 06C7   275d         xor POUT, A                                                ; XOR POUT,A      [Def: 407a]
            276d 
0137 3E02   277d         ret                                                        ; RET
            278d 
01FC        279d         seg code
             299 
             300 
             301         assert [pass]
01FC 3FFF    302 happy:  reset                                                      ; RESET
             303 
0BFF         304         org $0BFF
0BFF 2FFF    305         word $2FFF                                                 ; MOVN A,#$FF00
             306 
             307 end
             308*


Lines:        3103
Instrs:        510
Checksum: 00D309B2
Errors:          0
Warnings:        0










ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 48

Symbol table (alphabetical and cross-ref)


A                       REG $01              [Def: 401a] [Ref: 1618a* 39b 74b 75b 409b 57c 67c 240c 244c 248c
                         268c 103d]
AEN                     REG $F4 BITS $0200   [Def: 550a] [Ref: 271]
ANACTL_RESERVED         $FC00                [Def: 547a] [Ref: 572a 574a* 586a 725a 726a 727a 728a]
ANASEQ                  REG $10D             [Def: 1844a] [Ref: 1845a 1846a 1847a 1848a]
ANASEQ_C                REG $10D BITS $000F  [Def: 1848a]
ANASEQ_J                REG $10D BITS $0C00  [Def: 1846a]
ANASEQ_JG               REG $10D BITS $03F0  [Def: 1847a]
ANASEQ_S                REG $10D BITS $F000  [Def: 1845a]
ANY_BANK                "((ALIAS REG BANK(X) MAX _PROC_FIRSTRAM) BITS (X)) : (((ALIAS REG BANK(X) +
                         _PROC_BANKSIZE-1) MIN _PROC_LASTRAM) BITS (X))" [Def: 1815a]
ANY_DIRECT              "_PROC_FIRSTRAM:(REG _PROC_BANKSIZE - 1)" [Def: 1806a]
ANY_LINK                "TRYLINK"            [Def: 1812a]
ANY_NONDIRECT           "REG _PROC_BANKSIZE:_PROC_LASTRAM" [Def: 1807a]
ANY_PERTHREAD           "PERTHREAD"          [Def: 1811a]
ANY_RAM_DOWN            "_PROC_LASTRAM:_PROC_FIRSTRAM" [Def: 1810a]
ANY_RAM_UP              "_PROC_FIRSTRAM:_PROC_LASTRAM" [Def: 1809a]
AQUA                    LADDR $0052          [Seg: ORG:0] [Def: 132b]
A_EQ_I                  REG $00 BITS $2000   [Def: 882a.1]
A_EQ_IL                 REG $00 BITS $1000   [Def: 892a.1]
A_EQ_R                  REG $00 BITS $2000   [Def: 880a.1]
A_EQ_RL                 REG $00 BITS $1000   [Def: 890a.1]
A_GE_I                  REG $00 BITS $0800   [Def: 902a.1]
A_GE_IL                 REG $00 BITS $0400   [Def: 912a.1]
A_GE_R                  BITNOT REG $00 BITS $0200 [Def: 935a.1]
A_GT_I                  REG $00 BITS $0200   [Def: 932a.1]
A_GT_R                  BITNOT REG $00 BITS $0800 [Def: 905a.1]
A_GT_RL                 BITNOT REG $00 BITS $0400 [Def: 915a.1]
A_LE_I                  BITNOT REG $00 BITS $0200 [Def: 937a.1]
A_LE_R                  REG $00 BITS $0800   [Def: 900a.1]
A_LE_RL                 REG $00 BITS $0400   [Def: 910a.1]
A_LT_I                  BITNOT REG $00 BITS $0800 [Def: 907a.1]
A_LT_IL                 BITNOT REG $00 BITS $0400 [Def: 917a.1]
A_LT_R                  REG $00 BITS $0200   [Def: 930a.1]
A_NE_I                  BITNOT REG $00 BITS $2000 [Def: 887a.1]
A_NE_IL                 BITNOT REG $00 BITS $1000 [Def: 897a.1]
A_NE_R                  BITNOT REG $00 BITS $2000 [Def: 885a.1]
A_NE_RL                 BITNOT REG $00 BITS $1000 [Def: 895a.1]
BASEOCTLMASK            $0220                [Def: 269 270 271] [Ref: 270 271 411b]
BASEPAUXMASK            $0000                [Def: 240]
BASEPCTLMASK            $F331                [Def: 248 249 250 251] [Ref: 249 250 251 30b 292c 266d]
BASEPDIRMASK            $000E                [Def: 242 243] [Ref: 243 287c 261d]
BASEPIEMASK             $0040                [Def: 253 254] [Ref: 254 295c 269d]
BASEPOUTMASK            $0800                [Def: 256 257] [Ref: 257 298c 272d]
BASEXHCTLMASK           $0130                [Def: 273 274 275] [Ref: 274 275 418b]
BASEXLCTLMASK           $0390                [Def: 277 278 279 280 281] [Ref: 278 279 280 281 421b]
BASEYHCTLMASK           $0000                [Def: 283] [Ref: 424b]
BASEYLCTLMASK           $0040                [Def: 285 287] [Ref: 287 427b]
BESTGUESSXREFHI         $0030                [Def: 57] [Ref: 275]
BESTGUESSXREFLO         $0010                [Def: 58] [Ref: 281]
BGCAL                   REG $F4 BITS $01C0   [Def: 561a]
BIASENB                 REG $FD BITS $0040   [Def: 701a]
BIGREF                  REG $F9 BITS $0040   [Def: 683a 693a*] [Ref: 287]
BITMASK_PWMS            $000E                [Def: 219 220 221 222] [Ref: 220 221 222 234 243 261 49c 60c 236c
                         253c]
BITMASK_SPI             $0CC0                [Def: 230] [Ref: 233]
BITMASK_SPI_IN          $04C0                [Def: 228] [Ref: 230]
BITMASK_SPI_OUT         $0800                [Def: 229] [Ref: 230]
BITMASK_UNUSEDIOS       $E330                [Def: 232 233 234 235 236] [Ref: 233 234 235 236 251]
BLUE                    LADDR $0062          [Seg: ORG:0] [Def: 152b]
BLUEVIOLET              LADDR $006A          [Seg: ORG:0] [Def: 162b]
BOFF                    REG $FD BITS $0040   [Def: 700a] [Ref: 701a]
BW                      BITNOT REG $00 BITS $0800 [Def: 872a.1]
BWL                     BITNOT REG $00 BITS $0400 [Def: 874a.1]
C                       REG $00 BITS $0800   [Def: 470a.1] [Ref: 868a.1 873a.1 900a.1 901a.1 902a.1 903a.1 239c
                         243c 247c]
CCLK                    REG $09 BITS $0030   [Def: 514a* 522a 526a*]
CCTL                    REG $09              [Def: 409a] [Ref: 503a 505a 506a 507a 508a 509a 510a 511a 512a
                         514a* 516a* 520a* 522a 523a 524a 526a* 527a* 528a* 529a* 532a]
CCTL_GUARD              REG $09 BITS $C000   [Def: 503a] [Ref: 537a 539a*]
CCTL_GUARD_VAL          $8000                [Def: 535a]
CCTL_RESERVED           $C000                [Def: 537a 539a*]
CDIV                    REG $09 BITS $0008   [Def: 523a]

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 49

Symbol table (alphabetical and cross-ref)


CHECKFORNEWDATA         LADDR $0155          [Seg: CODE0] [Def: 97c] [Ref: 90c]
CHGM                    Undefined            [Def*: 1608a* 1611a*] [Ref*: 1585a* 1614a* 1622a* 1622a* 1624a*
                         1629a* 1629a* 1635a* 1635a* 1650a* 1651a*]
CHN                     REG $F5 BITS $0300   [Def: 578a]
CL                      REG $00 BITS $0400   [Def: 471a.1] [Ref: 869a.1 875a.1 910a.1 911a.1 912a.1 913a.1]
CLEARLOOP               LADDR $000C          [Seg: ORG:0] [Def: 36b] [Ref: 40b]
CLRAEQI                 "BCLR A_EQ_I"        [Def: 882a.6]
CLRAEQIL                "BCLR A_EQ_IL"       [Def: 892a.6]
CLRAEQR                 "BCLR A_EQ_R"        [Def: 880a.6]
CLRAEQRL                "BCLR A_EQ_RL"       [Def: 890a.6]
CLRAGEI                 "BCLR A_GE_I"        [Def: 902a.6]
CLRAGEIL                "BCLR A_GE_IL"       [Def: 912a.6]
CLRAGER                 "BCLR A_GE_R"        [Def: 935a.6]
CLRAGTI                 "BCLR A_GT_I"        [Def: 932a.6]
CLRAGTR                 "BCLR A_GT_R"        [Def: 905a.6]
CLRAGTRL                "BCLR A_GT_RL"       [Def: 915a.6]
CLRALEI                 "BCLR A_LE_I"        [Def: 937a.6]
CLRALER                 "BCLR A_LE_R"        [Def: 900a.6]
CLRALERL                "BCLR A_LE_RL"       [Def: 910a.6]
CLRALTI                 "BCLR A_LT_I"        [Def: 907a.6]
CLRALTIL                "BCLR A_LT_IL"       [Def: 917a.6]
CLRALTR                 "BCLR A_LT_R"        [Def: 930a.6]
CLRANEI                 "BCLR A_NE_I"        [Def: 887a.6]
CLRANEIL                "BCLR A_NE_IL"       [Def: 897a.6]
CLRANER                 "BCLR A_NE_R"        [Def: 885a.6]
CLRANERL                "BCLR A_NE_RL"       [Def: 895a.6]
CLRBW                   "BCLR BW"            [Def: 872a.6]
CLRBWL                  "BCLR BWL"           [Def: 874a.6]
CLRC                    "BCLR C"             [Def: 470a.6]
CLRCL                   "BCLR CL"            [Def: 471a.6]
CLRCNZ                  "BCLR CNZ"           [Def: 472a.6]
CLRIEQA                 "BCLR I_EQ_A"        [Def: 883a.6]
CLRIEQAL                "BCLR I_EQ_AL"       [Def: 893a.6]
CLRIGEA                 "BCLR I_GE_A"        [Def: 938a.6]
CLRIGTA                 "BCLR I_GT_A"        [Def: 908a.6]
CLRIGTAL                "BCLR I_GT_AL"       [Def: 918a.6]
CLRILEA                 "BCLR I_LE_A"        [Def: 903a.6]
CLRILEAL                "BCLR I_LE_AL"       [Def: 913a.6]
CLRILTA                 "BCLR I_LT_A"        [Def: 933a.6]
CLRINEA                 "BCLR I_NE_A"        [Def: 888a.6]
CLRINEAL                "BCLR I_NE_AL"       [Def: 898a.6]
CLRNBW                  "BCLR NBW"           [Def: 873a.6]
CLRNBWL                 "BCLR NBWL"          [Def: 875a.6]
CLRNC                   "BCLR NC"            [Def: 868a.6]
CLRNCL                  "BCLR NCL"           [Def: 869a.6]
CLRNCNZ                 "BCLR NCNZ"          [Def: 870a.6]
CLRNZ                   "BCLR NZ"            [Def: 866a.6]
CLRNZL                  "BCLR NZL"           [Def: 867a.6]
CLRREQA                 "BCLR R_EQ_A"        [Def: 881a.6]
CLRREQAL                "BCLR R_EQ_AL"       [Def: 891a.6]
CLRRGEA                 "BCLR R_GE_A"        [Def: 901a.6]
CLRRGEAL                "BCLR R_GE_AL"       [Def: 911a.6]
CLRRGTA                 "BCLR R_GT_A"        [Def: 931a.6]
CLRRLEA                 "BCLR R_LE_A"        [Def: 936a.6]
CLRRLTA                 "BCLR R_LT_A"        [Def: 906a.6]
CLRRLTAL                "BCLR R_LT_AL"       [Def: 916a.6]
CLRRNEA                 "BCLR R_NE_A"        [Def: 886a.6]
CLRRNEAL                "BCLR R_NE_AL"       [Def: 896a.6]
CLRZ                    "BCLR Z"             [Def: 468a.6]
CLRZL                   "BCLR ZL"            [Def: 469a.6]
CNZ                     REG $00 BITS $0200   [Def: 472a.1] [Ref: 870a.1 930a.1 931a.1 932a.1 933a.1]
CODE                    Undefined            [Def*: 132a*]
CODE0                   Undefined            [Def*: 94a* 106a* 120a*] [Ref*: 132a*]
CODE1                   Undefined            [Def*: 98a* 110a* 124a*]
COLORJUMPTABLE          LADDR $002A          [Seg: ORG:0] [Def: 83b] [Ref: 78b]
COLORSET                LADDR $00A8          [Seg: ORG:0] [Def: 242b] [Ref: 91b 100b 110b 119b 129b 139b 149b
                         159b 169b 179b 188b 198b 208b 218b 228b]
COLOR_AQUA_AMOUNT_BLUE  $0200                [Def: 86] [Ref: 137b]
COLOR_AQUA_AMOUNT_GREEN $03FF                [Def: 85] [Ref: 135b]
COLOR_AQUA_AMOUNT_RED   $0080                [Def: 84] [Ref: 133b]
COLOR_BLUEVIOLET_AMOUNT_BLUE $03FF                [Def: 98] [Ref: 167b]
COLOR_BLUEVIOLET_AMOUNT_GREEN $0000                [Def: 97] [Ref: 165b]
COLOR_BLUEVIOLET_AMOUNT_RED $0080                [Def: 96] [Ref: 163b]

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 50

Symbol table (alphabetical and cross-ref)


COLOR_BLUE_AMOUNT_BLUE  $03FF                [Def: 94] [Ref: 157b]
COLOR_BLUE_AMOUNT_GREEN $0000                [Def: 93] [Ref: 155b]
COLOR_BLUE_AMOUNT_RED   $0000                [Def: 92] [Ref: 153b]
COLOR_CYAN_AMOUNT_BLUE  $03FF                [Def: 90] [Ref: 147b]
COLOR_CYAN_AMOUNT_GREEN $03FF                [Def: 89] [Ref: 145b]
COLOR_CYAN_AMOUNT_RED   $0000                [Def: 88] [Ref: 143b]
COLOR_GREEN_AMOUNT_BLUE $0000                [Def: 82] [Ref: 127b]
COLOR_GREEN_AMOUNT_GREEN $03FF                [Def: 81] [Ref: 125b]
COLOR_GREEN_AMOUNT_RED  $0000                [Def: 80] [Ref: 123b]
COLOR_MAGENTA_AMOUNT_BLUE $0300                [Def: 106] [Ref: 186b]
COLOR_MAGENTA_AMOUNT_GREEN $0000                [Def: 105] [Ref: 184b]
COLOR_MAGENTA_AMOUNT_RED $03FF                [Def: 104] [Ref: 182b]
COLOR_ORANGE_AMOUNT_BLUE $0000                [Def: 74] [Ref: 108b]
COLOR_ORANGE_AMOUNT_GREEN $0180                [Def: 73] [Ref: 106b]
COLOR_ORANGE_AMOUNT_RED $03FF                [Def: 72] [Ref: 104b]
COLOR_PINK_AMOUNT_BLUE  $0180                [Def: 66] [Ref: 89b]
COLOR_PINK_AMOUNT_GREEN $0080                [Def: 65] [Ref: 87b]
COLOR_PINK_AMOUNT_RED   $03FF                [Def: 64] [Ref: 85b]
COLOR_RED_AMOUNT_BLUE   $0000                [Def: 70] [Ref: 98b]
COLOR_RED_AMOUNT_GREEN  $0000                [Def: 69] [Ref: 96b]
COLOR_RED_AMOUNT_RED    $03FF                [Def: 68] [Ref: 94b]
COLOR_VIOLET_AMOUNT_BLUE $03FF                [Def: 102] [Ref: 177b]
COLOR_VIOLET_AMOUNT_GREEN $0000                [Def: 101] [Ref: 175b]
COLOR_VIOLET_AMOUNT_RED $0180                [Def: 100] [Ref: 173b]
COLOR_WHITE_AMOUNT_BLUE $03FF                [Def: 110] [Ref: 196b 206b 216b 226b 236b]
COLOR_WHITE_AMOUNT_GREEN $03FF                [Def: 109] [Ref: 194b 204b 214b 224b 234b]
COLOR_WHITE_AMOUNT_RED  $03FF                [Def: 108] [Ref: 192b 202b 212b 222b 232b]
COLOR_YELLOW_AMOUNT_BLUE $0000                [Def: 78] [Ref: 117b]
COLOR_YELLOW_AMOUNT_GREEN $03FF                [Def: 77] [Ref: 115b]
COLOR_YELLOW_AMOUNT_RED $03FF                [Def: 76] [Ref: 113b]
COMMANDJUMPTABLE        LADDR $01CB          [Seg: CODE0] [Def: 163d]
COUNTERPEGGED           LADDR $0152          [Seg: CODE0] [Def: 92c] [Ref: 85c]
CTIME                   REG $0A              [Def: 410a] [Ref: 499a 500a 67d 74d 76d 99d 101d]
CTIME_COUNT             REG $0A BITS $7FFF   [Def: 500a]
CYAN                    LADDR $005A          [Seg: ORG:0] [Def: 142b]
DATA0                   Undefined            [Def*: 92a* 104a* 118a*]
DATA1                   Undefined            [Def*: 96a* 108a* 122a*]
DATAFORUS               LADDR $01C4          [Seg: CODE0] [Def: 122d] [Ref: 91d]
DCMP                    REG $F5 BITS $0080   [Def: 579a]
DDAC                    REG $F1              [Def: 454a]
DDRV                    REG $F5 BITS $0040   [Def: 580a]
DEFCONDNAME             Macro                [Def: 344a* 354a* 369a] [Ref: 468a 469a 470a 471a 472a 866a 867a
                         868a 869a 870a 872a 873a 874a 875a 880a 881a 882a 883a 885a 886a 887a 888a 890a 891a
                         892a 893a 895a 896a 897a 898a 900a 901a 902a 903a 905a 906a 907a 908a 910a 911a 912a
                         913a 915a 916a 917a 918a 930a 931a 932a 933a 935a 936a 937a 938a]
DEFCONDNAME_B           Macro                [Def: 356a* 365a* 383a] [Ref: 877a 878a 920a 921a 922a 923a 925a
                         926a 927a 928a 940a 941a 942a 943a 945a 946a 947a 948a]
DHOLD                   Undefined            [Def*: 552a*]
DO_PWM                  LADDR $016E          [Seg: CODE0] [Def: 135c] [Ref: 116c]
DRIVENSHIELD_PIN        Undefined            [Def*: 758a*]
EN3V                    Undefined            [Def*: 557a*]
EN5V                    Undefined            [Def*: 694a*]
ENBL9                   REG $F8 BITS $0040   [Def: 678a]
ENSHLD                  Undefined            [Def*: 516a*]
EQUDEF                  Macro                [Def: 310a]
EQUF                    Undefined            [Def*: 88a*]
EQUFDEF                 Macro                [Def: 317a]
ESDTO                   Undefined            [Def*: 529a*]
FCDIV_FAST              Undefined            [Def*: 827a*] [Ref*: 828a*]
FCDIV_NORMAL            Undefined            [Def*: 828a*]
FCDIV_SLOW              Undefined            [Def*: 826a*]
FESD_DISABLE            Undefined            [Def*: 834a*]
FESD_ENABLE             Undefined            [Def*: 835a*] [Ref*: 836a*]
FESD_NORMAL             Undefined            [Def*: 836a*]
FIRMWARE_BUILD_ID       "90448"              [Ref: 25b]
FIRST_RAM               REG $0C              [Def: 416a* 420a 424a*] [Ref: 417a* 425a* 783a]
FLAGWORD                REG $0C              [Def: 120] [Ref: 150 154]
FOFRC_EITHER            Undefined            [Def*: 816a*] [Ref*: 819a*]
FOFRC_NORMAL            Undefined            [Def*: 819a*]
FOFRC_RC                Undefined            [Def*: 817a*]
FOFRC_XTAL              Undefined            [Def*: 818a*]
FPOR_EXTERNAL           Undefined            [Def*: 831a*]
FPOR_INTERNAL           Undefined            [Def*: 830a*] [Ref*: 832a*]

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 51

Symbol table (alphabetical and cross-ref)


FPOR_NORMAL             Undefined            [Def*: 832a*]
FRINT_EXTERNAL          Undefined            [Def*: 843a*] [Ref*: 844a*]
FRINT_INTERNAL          Undefined            [Def*: 842a*]
FRINT_NORMAL            Undefined            [Def*: 844a*]
FROMVAL                 Undefined            [Def*: 1591a* 1594a*] [Ref*: 1585a* 1622a* 1622a* 1629a* 1629a*
                         1635a* 1635a*]
FROM_X                  Undefined            [Def*: 1592a* 1595a*] [Ref*: 1585a* 1622a* 1622a* 1629a* 1629a*
                         1635a* 1635a*]
FTEST_NORMAL            Undefined            [Def*: 814a*]
FTEST_RUN               Undefined            [Def*: 813a*] [Ref*: 814a*]
FTEST_TEST              Undefined            [Def*: 812a*]
FWDT_DISABLE            Undefined            [Def*: 838a*]
FWDT_ENABLE             Undefined            [Def*: 839a*] [Ref*: 840a*]
FWDT_NORMAL             Undefined            [Def*: 840a*]
FXTAL_EITHER            Undefined            [Def*: 821a*] [Ref*: 824a*]
FXTAL_NORMAL            Undefined            [Def*: 824a*]
FXTAL_RC                Undefined            [Def*: 822a*]
FXTAL_XTAL              Undefined            [Def*: 823a*]
GREEN                   LADDR $004A          [Seg: ORG:0] [Def: 122b]
GS                      REG $FD BITS $0380   [Def: 699a] [Ref: 704a 705a 707a 710a* 712a 714a 715a 717a 720a*
                         722a]
GS_1_000                $0000                [Def: 704a]
GS_1_006                $0080                [Def: 705a]
GS_1_012                $0180                [Def: 712a]
GS_1_100                $0200                [Def: 714a]
GS_1_106                $0280                [Def: 715a]
GS_1_112                $0380                [Def: 722a]
GS_1_200                $0100                [Def: 707a]
GS_1_206                Undefined            [Def*: 710a*]
GS_1_300                $0300                [Def: 717a]
GS_1_306                Undefined            [Def*: 720a*]
GUARDLO                 Undefined            [Def*: 554a*]
HAPPY                   LADDR $01FC          [Seg: CODE0] [Def: 302]
HASPACKRAT              $0001                [Def: 13] [Ref: 16 24b]
I2C_CLAMPBITS           Undefined            [Def*: 490a*]
I2C_DATALATCH           Undefined            [Def*: 493a*]
I2C_INTONCLAMP          Undefined            [Def*: 491a*]
I2C_INTONSTOP           Undefined            [Def*: 492a*]
I2C_INT_ENABLE          Undefined            [Def*: 488a*]
I2C_SAWSTART            Undefined            [Def*: 494a*]
IFAEQI                  "IFSET A_EQ_I"       [Def: 882a.3]
IFAEQIL                 "IFSET A_EQ_IL"      [Def: 892a.3]
IFAEQR                  "IFSET A_EQ_R"       [Def: 880a.3]
IFAEQRL                 "IFSET A_EQ_RL"      [Def: 890a.3]
IFAGEI                  "IFSET A_GE_I"       [Def: 902a.3]
IFAGEIB                 "IFCB"               [Def: 922a.2]
IFAGEIL                 "IFSET A_GE_IL"      [Def: 912a.3]
IFAGER                  "IFSET A_GE_R"       [Def: 935a.3]
IFAGERB                 "IFNCNZB"            [Def: 945a.2]
IFAGTI                  "IFSET A_GT_I"       [Def: 932a.3]
IFAGTIB                 "IFCNZB"             [Def: 942a.2]
IFAGTR                  "IFSET A_GT_R"       [Def: 905a.3]
IFAGTRB                 "IFNCB"              [Def: 925a.2]
IFAGTRL                 "IFSET A_GT_RL"      [Def: 915a.3]
IFALEI                  "IFSET A_LE_I"       [Def: 937a.3]
IFALEIB                 "IFNCNZB"            [Def: 947a.2]
IFALER                  "IFSET A_LE_R"       [Def: 900a.3]
IFALERB                 "IFCB"               [Def: 920a.2]
IFALERL                 "IFSET A_LE_RL"      [Def: 910a.3]
IFALTI                  "IFSET A_LT_I"       [Def: 907a.3]
IFALTIB                 "IFNCB"              [Def: 927a.2]
IFALTIL                 "IFSET A_LT_IL"      [Def: 917a.3]
IFALTR                  "IFSET A_LT_R"       [Def: 930a.3]
IFALTRB                 "IFCNZB"             [Def: 940a.2]
IFANEI                  "IFSET A_NE_I"       [Def: 887a.3]
IFANEIL                 "IFSET A_NE_IL"      [Def: 897a.3]
IFANER                  "IFSET A_NE_R"       [Def: 885a.3]
IFANERL                 "IFSET A_NE_RL"      [Def: 895a.3]
IFBW                    "IFSET BW"           [Def: 872a.3]
IFBWB                   "IFNCB"              [Def: 877a.2]
IFBWL                   "IFSET BWL"          [Def: 874a.3]
IFC                     "IFSET C"            [Def: 470a.3] [Ref: 239c 243c 247c]
IFCL                    "IFSET CL"           [Def: 471a.3]

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 52

Symbol table (alphabetical and cross-ref)


IFCNZ                   "IFSET CNZ"          [Def: 472a.3]
IFIEQA                  "IFSET I_EQ_A"       [Def: 883a.3]
IFIEQAL                 "IFSET I_EQ_AL"      [Def: 893a.3]
IFIGEA                  "IFSET I_GE_A"       [Def: 938a.3]
IFIGEAB                 "IFNCNZB"            [Def: 948a.2]
IFIGTA                  "IFSET I_GT_A"       [Def: 908a.3]
IFIGTAB                 "IFNCB"              [Def: 928a.2]
IFIGTAL                 "IFSET I_GT_AL"      [Def: 918a.3]
IFILEA                  "IFSET I_LE_A"       [Def: 903a.3]
IFILEAB                 "IFCB"               [Def: 923a.2]
IFILEAL                 "IFSET I_LE_AL"      [Def: 913a.3]
IFILTA                  "IFSET I_LT_A"       [Def: 933a.3]
IFILTAB                 "IFCNZB"             [Def: 943a.2]
IFINEA                  "IFSET I_NE_A"       [Def: 888a.3]
IFINEAL                 "IFSET I_NE_AL"      [Def: 898a.3]
IFNBW                   "IFSET NBW"          [Def: 873a.3]
IFNBWB                  "IFCB"               [Def: 878a.2]
IFNBWL                  "IFSET NBWL"         [Def: 875a.3]
IFNC                    "IFSET NC"           [Def: 868a.3]
IFNCL                   "IFSET NCL"          [Def: 869a.3]
IFNCNZ                  "IFSET NCNZ"         [Def: 870a.3]
IFNZ                    "IFSET NZ"           [Def: 866a.3] [Ref: 119d]
IFNZL                   "IFSET NZL"          [Def: 867a.3]
IFREQA                  "IFSET R_EQ_A"       [Def: 881a.3]
IFREQAL                 "IFSET R_EQ_AL"      [Def: 891a.3]
IFRGEA                  "IFSET R_GE_A"       [Def: 901a.3]
IFRGEAB                 "IFCB"               [Def: 921a.2]
IFRGEAL                 "IFSET R_GE_AL"      [Def: 911a.3]
IFRGTA                  "IFSET R_GT_A"       [Def: 931a.3]
IFRGTAB                 "IFCNZB"             [Def: 941a.2]
IFRLEA                  "IFSET R_LE_A"       [Def: 936a.3]
IFRLEAB                 "IFNCNZB"            [Def: 946a.2]
IFRLTA                  "IFSET R_LT_A"       [Def: 906a.3]
IFRLTAB                 "IFNCB"              [Def: 926a.2]
IFRLTAL                 "IFSET R_LT_AL"      [Def: 916a.3]
IFRNEA                  "IFSET R_NE_A"       [Def: 886a.3]
IFRNEAL                 "IFSET R_NE_AL"      [Def: 896a.3]
IFUNAME                 Undefined            [Def*: 348a* 359a*]
IFZ                     "IFSET Z"            [Def: 468a.3] [Ref: 84c]
IFZL                    "IFSET ZL"           [Def: 469a.3] [Ref: 292b 304b 192d]
INFO0                   Undefined            [Def*: 112a* 128a*]
INFO1                   Undefined            [Def*: 113a*]
INITANALOG              LADDR $00ED          [Seg: SUBR0] [Def: 405b] [Ref: 43b]
INITIALIZEADDRESS       LADDR $01A4          [Seg: CODE0] [Def: 58d]
IS_T1004                $0000                [Def: 70a] [Ref: 71a 72a 78a 90a* 150a* 423a* 525a* 538a* 563a*
                         573a* 641a* 668a 691a* 775a* 787a 811a]
IS_T1004A               $0000                [Def: 71a]
IS_T1004B               $0000                [Def: 72a]
IS_T1004_6              $0000                [Def: 78a]
IS_T1005                $0001                [Def: 73a] [Ref: 79a 101a* 148a 411a 419a 434a 521a 560a 616a 750a
                         766a 788a 15b]
IS_T1005_6              $0001                [Def: 79a]
IS_T1006                $0000                [Def: 74a] [Ref: 78a 79a 115a* 142a 415a 487a 513a 551a 588a 773a*
                         789a 852a]
IS_T1006A               $0000                [Def: 75a] [Ref*: 517a* 555a* 603a*]
IS_T1006B               $0000                [Def: 76a] [Ref: 143a* 489a* 515a* 553a* 601a* 757a]
I_EQ_A                  REG $00 BITS $2000   [Def: 883a.1]
I_EQ_AL                 REG $00 BITS $1000   [Def: 893a.1]
I_GE_A                  BITNOT REG $00 BITS $0200 [Def: 938a.1]
I_GT_A                  BITNOT REG $00 BITS $0800 [Def: 908a.1]
I_GT_AL                 BITNOT REG $00 BITS $0400 [Def: 918a.1]
I_LE_A                  REG $00 BITS $0800   [Def: 903a.1]
I_LE_AL                 REG $00 BITS $0400   [Def: 913a.1]
I_LT_A                  REG $00 BITS $0200   [Def: 933a.1]
I_NE_A                  BITNOT REG $00 BITS $2000 [Def: 888a.1]
I_NE_AL                 BITNOT REG $00 BITS $1000 [Def: 898a.1]
JAEQI                   Macro                [Def: 882a.7]
JAEQIL                  Macro                [Def: 892a.7]
JAEQR                   Macro                [Def: 880a.7]
JAEQRL                  Macro                [Def: 890a.7]
JAGEI                   Macro                [Def: 902a.7]
JAGEIB                  Macro                [Def: 922a.4]
JAGEIL                  Macro                [Def: 912a.7]

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 53

Symbol table (alphabetical and cross-ref)


JAGER                   Macro                [Def: 935a.7]
JAGERB                  Macro                [Def: 945a.4]
JAGTI                   Macro                [Def: 932a.7]
JAGTIB                  Macro                [Def: 942a.4]
JAGTR                   Macro                [Def: 905a.7]
JAGTRB                  Macro                [Def: 925a.4]
JAGTRL                  Macro                [Def: 915a.7]
JALEI                   Macro                [Def: 937a.7]
JALEIB                  Macro                [Def: 947a.4]
JALER                   Macro                [Def: 900a.7]
JALERB                  Macro                [Def: 920a.4]
JALERL                  Macro                [Def: 910a.7]
JALTI                   Macro                [Def: 907a.7]
JALTIB                  Macro                [Def: 927a.4]
JALTIL                  Macro                [Def: 917a.7]
JALTR                   Macro                [Def: 930a.7]
JALTRB                  Macro                [Def: 940a.4]
JANEI                   Macro                [Def: 887a.7]
JANEIL                  Macro                [Def: 897a.7]
JANER                   Macro                [Def: 885a.7]
JANERL                  Macro                [Def: 895a.7]
JBW                     Macro                [Def: 872a.7]
JBWB                    Macro                [Def: 877a.4]
JBWL                    Macro                [Def: 874a.7]
JC                      Macro                [Def: 470a.7]
JCL                     Macro                [Def: 471a.7]
JCLR                    Macro                [Def: 966a]
JCNZ                    Macro                [Def: 472a.7]
JIEQA                   Macro                [Def: 883a.7]
JIEQAL                  Macro                [Def: 893a.7]
JIGEA                   Macro                [Def: 938a.7]
JIGEAB                  Macro                [Def: 948a.4]
JIGTA                   Macro                [Def: 908a.7]
JIGTAB                  Macro                [Def: 928a.4]
JIGTAL                  Macro                [Def: 918a.7]
JILEA                   Macro                [Def: 903a.7]
JILEAB                  Macro                [Def: 923a.4]
JILEAL                  Macro                [Def: 913a.7]
JILTA                   Macro                [Def: 933a.7]
JILTAB                  Macro                [Def: 943a.4]
JINEA                   Macro                [Def: 888a.7]
JINEAL                  Macro                [Def: 898a.7]
JNBW                    Macro                [Def: 873a.7]
JNBWB                   Macro                [Def: 878a.4]
JNBWL                   Macro                [Def: 875a.7]
JNC                     Macro                [Def: 868a.7]
JNCL                    Macro                [Def: 869a.7]
JNCNZ                   Macro                [Def: 870a.7]
JNZ                     Macro                [Def: 866a.7]
JNZL                    Macro                [Def: 867a.7]
JREQA                   Macro                [Def: 881a.7]
JREQAL                  Macro                [Def: 891a.7]
JRGEA                   Macro                [Def: 901a.7]
JRGEAB                  Macro                [Def: 921a.4]
JRGEAL                  Macro                [Def: 911a.7]
JRGTA                   Macro                [Def: 931a.7]
JRGTAB                  Macro                [Def: 941a.4]
JRLEA                   Macro                [Def: 936a.7]
JRLEAB                  Macro                [Def: 946a.4]
JRLTA                   Macro                [Def: 906a.7]
JRLTAB                  Macro                [Def: 926a.4]
JRLTAL                  Macro                [Def: 916a.7]
JRNEA                   Macro                [Def: 886a.7]
JRNEAL                  Macro                [Def: 896a.7]
JSET                    Macro                [Def: 961a]
JUNAME                  Undefined            [Def*: 350a* 361a*]
JZ                      Macro                [Def: 468a.7]
JZL                     Macro                [Def: 469a.7]
LAST0                   Undefined            [Def*: 95a* 107a* 121a*]
LAST1                   Undefined            [Def*: 99a* 111a* 127a*]
LAST_RAM                REG $DF              [Def: 417a* 421a 425a*] [Ref: 784a 35b]
LINK                    REG $03              [Def: 403a]
MAGENTA                 LADDR $007A          [Seg: ORG:0] [Def: 181b]

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 54

Symbol table (alphabetical and cross-ref)


MASKREV                 REG $FE BITS $FF00   [Def: 731a]
MASKREV_T1004A          $0000                [Def: 25a]
MASKREV_T1004AA         $0001                [Def: 26a]
MASKREV_T1004AB         $0002                [Def: 27a]
MASKREV_T1004AC         $0003                [Def: 28a]
MASKREV_T1004B          $0008                [Def: 29a] [Ref: 62a]
MASKREV_T1004BA         $0009                [Def: 30a]
MASKREV_T1004BB         $000A                [Def: 31a]
MASKREV_T1004BC         $000A                [Def: 32a]
MASKREV_T1004BD         $000B                [Def: 33a]
MASKREV_T1004BE         $000C                [Def: 34a]
MASKREV_T1004C          $000F                [Def: 35a] [Ref: 63a]
MASKREV_T1005           $0011                [Def: 37a]
MASKREV_T1005A1         $0010                [Def: 36a] [Ref: 64a]
MASKREV_T1005A2         $0011                [Def: 38a]
MASKREV_T1005A3         $0012                [Def: 39a]
MASKREV_T1005A4         $0013                [Def: 40a] [Ref: 65a]
MASKREV_T1006           $0020                [Def: 41a] [Ref: 66a]
MASKREV_T1006A0         $0020                [Def: 42a]
MASKREV_T1006A2         $0021                [Def: 43a]
MASKREV_T1006A3         $0022                [Def: 44a]
MASKREV_T1006A4         $0023                [Def: 45a] [Ref: 67a]
MASKREV_T1006B          $0028                [Def: 46a] [Ref: 68a]
MASKREV_T1006B0         $0028                [Def: 47a]
MASKREV_T1006B1         $0028                [Def: 48a]
MASKREV_T1007           $0030                [Def: 49a]
MBANK                   Macro                [Def: 1776a]
MFGOSCVECTORADDR        LADDR $0001          [Seg: ORG:0] [Def: 12b] [Ref: 407b]
MOIST                   REG $FC BITS $0040   [Def: 690a 695a*]
MUTABLE                 "( ALTSPAN (TO) == 0 && (((R) == A && MUTABLE_A((FROM),(TO))) || ((R) == X) || IS BIT
                         (R) || PO2((TO) XOR (FROM)) || ((IS WORD (R) || IS BYTE (R)) && (TO) == 0)))" [Def:
                         1771a]
MUTABLE_A               "( _MOV_OK(TO) || _ADD_OK((TO) - (FROM)) || _OR_OK((FROM) XOR (TO)) || ((FROM) XOR (TO))
                         == $FFFF || (((FROM) SHL 1) AND $FFFF) == ((TO) AND $FFFF) || (((FROM) SHL 4) AND
                         $FFFF) == ((TO) AND $FFFF) || (((FROM) SHR 4) AND $FFFF) == ((TO) AND $FFFF) || ((FROM)
                         AND $8000) != $0000 && ((((FROM) SHL 1) + (FROM)) AND $FFFF) == ((TO) AND $FFFF))"
                         [Def: 1756a]
MUTATE                  Macro                [Def: 1583a* 1656a* 1663a]
MUTATE_A                Macro                [Def: 1040a]
MYADDRESS               REG $30              [Def: 184] [Ref: 73b 82d 117d]
NAME                    Undefined            [Def*: 346a*] [Ref*: 344a* 347a* 348a* 349a* 351a* 356a* 358a*]
NBW                     REG $00 BITS $0800   [Def: 873a.1]
NBWL                    REG $00 BITS $0400   [Def: 875a.1]
NC                      BITNOT REG $00 BITS $0800 [Def: 868a.1] [Ref: 872a.1 905a.1 906a.1 907a.1 908a.1]
NCHN                    REG $FC BITS $0300   [Def: 688a]
NCL                     BITNOT REG $00 BITS $0400 [Def: 869a.1] [Ref: 874a.1 915a.1 916a.1 917a.1 918a.1]
NCNZ                    BITNOT REG $00 BITS $0200 [Def: 870a.1] [Ref: 935a.1 936a.1 937a.1 938a.1]
NOCOUNTERTIMEOUT        LADDR $0161          [Seg: CODE0] [Def: 118c] [Ref: 88c]
NONEWDATA               LADDR $0164          [Seg: CODE0] [Def: 123c] [Ref: 99c]
NOTHEADER               LADDR $00C2          [Seg: ORG:0] [Def: 331b] [Ref: 328b]
NO_SIM_FEATURES         Undefined            [Ref: 1825a]
NZ                      BITNOT REG $00 BITS $2000 [Def: 866a.1] [Ref: 885a.1 886a.1 887a.1 888a.1 119d]
NZL                     BITNOT REG $00 BITS $1000 [Def: 867a.1] [Ref: 895a.1 896a.1 897a.1 898a.1]
OCTL                    REG $F4              [Def: 455a] [Ref: 550a 552a* 554a* 556a* 557a* 559a* 561a 562a
                         564a* 565a* 566a* 413b]
OCTL_GUARD              Undefined            [Def*: 556a* 565a*] [Ref*: 574a*]
OCTL_GUARD_VAL          $0000                [Def: 570a]
OCTL_RESERVED           $FC00                [Def: 572a 574a*]
OLDF                    REG $FC BITS $0080   [Def: 689a 692a*]
ORANGE                  LADDR $003A          [Seg: ORG:0] [Def: 103b]
OSC                     REG $F4 BITS $003F   [Def: 559a* 562a 566a*]
OSCVECTOR               LADDR $0001          [Seg: ORG:0] [Def: 13b]
OSCVECTORINITIALIZED    LADDR $00F3          [Seg: SUBR0] [Def: 412b] [Ref: 410b]
PACKRATIDHIGH           REG $1F              [Def: 122]
PACKRATIDLOW            REG $1E              [Def: 121] [Ref: 26b]
PAIREQU                 Macro                [Def: 294a]
PAUX                    REG $EF              [Def: 436a] [Ref: 51d 52d 104d 125d]
PAXIS                   REG $F5 BITS $0001   [Def: 583a]
PC                      REG $02              [Def: 402a] [Ref: 479a 480a 80b 161d]
PCTL                    REG $04              [Def: 404a] [Ref: 31b 293c 267d]
PC_GUARD                REG $02 BITS $F000   [Def: 479a] [Ref: 484a]
PC_GUARD_VAL            $A000                [Def: 483a]
PC_PAGE                 REG $02 BITS $0800   [Def: 480a]

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 55

Symbol table (alphabetical and cross-ref)


PC_RESERVED             $F000                [Def: 484a]
PDIR                    REG $06              [Def: 406a] [Ref: 490a* 213 288c 290c 262d 264d]
PIE                     REG $05              [Def: 405a] [Ref: 488a* 491a* 492a* 296c 61d 66d 70d 71d 270d]
PIN                     REG $08              [Def: 408a] [Ref: 493a* 494a* 212 224 225 226]
PINEXT                  REG $10C             [Def: 1833a]
PINK                    LADDR $002A          [Seg: ORG:0] [Def: 84b]
PORTB                   REG $EA              [Def: 432a]
PORTC                   REG $EB              [Def: 433a]
POUT                    REG $07              [Def: 407a] [Ref: 215 216 217 227 50c 61c 252c 254c 299c 301c 65d
                         73d 75d 98d 100d 273d 275d]
PRESERVEPINS_PDIR       $1000                [Def: 245 246] [Ref: 246 289c 263d]
PRESERVEPINS_POUT       $004E                [Def: 259 260 261] [Ref: 260 261 300c 274d]
PSEL                    REG $F5 BITS $001F   [Def: 582a] [Ref: 590a* 591a* 592a* 593a* 594a* 595a* 596a* 597a*
                         598a* 599a* 600a* 602a* 604a* 606a* 607a* 608a* 609a* 610a* 611a* 612a* 613a* 614a*
                         615a* 617a 618a 619a 620a 621a 622a 623a 624a 625a 626a 627a 628a 629a 630a 631a 632a
                         633a 634a 635a 636a 637a 638a 639a 640a 642a* 643a* 644a* 645a* 646a* 647a* 648a* 649a*
                         650a* 651a* 652a* 653a* 654a* 655a* 656a* 657a* 658a* 659a* 660a* 661a*]
PSEL_ASHIELDL           $000C                [Def: 607a* 630a]
PSEL_BGCLOCK            $000D                [Def: 633a]
PSEL_CHGVG              Undefined            [Def*: 595a*]
PSEL_DSHIELDH           $0000                [Def: 594a* 617a]
PSEL_DSHIELDL           Undefined            [Def*: 604a*]
PSEL_EPROM              Undefined            [Def*: 654a*]
PSEL_FLOAT              $001F                [Def: 615a* 640a 661a*]
PSEL_GROUND             $000E                [Def: 609a* 634a 655a*] [Ref: 415b]
PSEL_HICAP              $0010                [Def: 611a* 636a 657a*]
PSEL_IPB                $0013                [Def: 614a* 639a 660a*]
PSEL_LOCAP              $0012                [Def: 613a* 638a 659a*]
PSEL_LSO                $000D                [Def: 608a* 632a]
PSEL_MINREF             Undefined            [Def*: 602a*]
PSEL_OSCTRIP            $0011                [Def: 612a* 637a 658a*]
PSEL_SAMPLE             $0001                [Def: 606a* 619a]
PSEL_SHIELDH            $0000                [Def: 618a]
PSEL_SHIELDL            $000C                [Def: 631a]
PSEL_VDD                $000F                [Def: 610a* 635a 656a*]
PSEL_XBIASCMP           Undefined            [Def*: 652a*]
PSEL_XCHGVG             $0004                [Def: 622a 646a*]
PSEL_XIREFLO            $0002                [Def: 620a]
PSEL_XMINREF            $000A                [Def: 628a]
PSEL_XREFHI             $0006                [Def: 597a* 624a 648a*]
PSEL_XREFLO             $0008                [Def: 599a* 626a 650a*]
PSEL_XVG1               Undefined            [Def*: 590a* 642a*]
PSEL_XVGSET             Undefined            [Def*: 592a* 644a*]
PSEL_YBIASCMP           Undefined            [Def*: 653a*]
PSEL_YCHGVG             $0005                [Def: 596a* 623a 647a*]
PSEL_YIREFLO            $0003                [Def: 621a]
PSEL_YMINREF            $000B                [Def: 629a]
PSEL_YREFHI             $0007                [Def: 598a* 625a 649a*]
PSEL_YREFLO             $0009                [Def: 600a* 627a 651a*]
PSEL_YVG1               Undefined            [Def*: 591a* 643a*]
PSEL_YVGSET             Undefined            [Def*: 593a* 645a*]
PSTR                    REG $F5 BITS $0020   [Def: 581a] [Ref: 415b]
PWMSEQUENCEHEADER       LADDR $00C9          [Seg: ORG:0] [Def: 345b] [Ref: 329b]
PWM_BLUE                REG $07 BITS $0008   [Def: 217] [Ref: 222 248c]
PWM_BLUE_PIN            $0003                [Def: 34] [Ref: 217]
PWM_GREEN               REG $07 BITS $0004   [Def: 216] [Ref: 221 244c]
PWM_GREEN_PIN           $0002                [Def: 33] [Ref: 216]
PWM_RED                 REG $07 BITS $0002   [Def: 215] [Ref: 220 240c]
PWM_RED_PIN             $0001                [Def: 32] [Ref: 215]
Q_HEAD                  REG $0D              [Def: 131] [Ref: 46b 286b 308b]
Q_TAIL                  REG $0E              [Def: 132] [Ref: 47b 290b 196d 207d 238d]
RAM_BANK_SIZE           $0040                [Def: 418a* 422a 426a*] [Ref: 785a]
RCHECK                  REG $FE BITS $0004   [Def: 738a]
RCOEN                   Undefined            [Def*: 564a*]
RCOND                   REG $FE              [Def: 438a] [Ref: 731a 732a 736a 737a 738a 739a]
RCOND_RESERVED          $0071                [Def: 743a]
READYFORBLUE            REG $10 BITS $0004   [Def: 141] [Ref: 339b 366b]
READYFORGREEN           REG $10 BITS $0002   [Def: 140] [Ref: 337b 358b]
READYFORRED             REG $10 BITS $0001   [Def: 139] [Ref: 335b 350b]
RECEIVEPWM_BLUE         LADDR $00DB          [Seg: ORG:0] [Def: 370b] [Ref: 340b]
RECEIVEPWM_GREEN        LADDR $00D5          [Seg: ORG:0] [Def: 362b] [Ref: 338b]
RECEIVEPWM_RED          LADDR $00CF          [Seg: ORG:0] [Def: 354b] [Ref: 336b]
RED                     LADDR $0032          [Seg: ORG:0] [Def: 93b]

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 56

Symbol table (alphabetical and cross-ref)


RESD                    REG $FE BITS $0008   [Def: 736a]
RESET                   REG $FF              [Def: 440a]
RESETVECTOR             LADDR $0000          [Seg: ORG:0] [Def: 7b]
RESET_REG               REG $FF              [Def: 442a] [Ref*: 1583a*]
ROL                     Macro                [Def: 1007a]
ROR                     Macro                [Def: 1020a]
RPOWER                  REG $FE BITS $0080   [Def: 732a]
RSW                     REG $FE BITS $0002   [Def: 739a]
RWDT                    REG $FE BITS $0008   [Def: 737a]
R_EQ_A                  REG $00 BITS $2000   [Def: 881a.1]
R_EQ_AL                 REG $00 BITS $1000   [Def: 891a.1]
R_GE_A                  REG $00 BITS $0800   [Def: 901a.1]
R_GE_AL                 REG $00 BITS $0400   [Def: 911a.1]
R_GT_A                  REG $00 BITS $0200   [Def: 931a.1]
R_LE_A                  BITNOT REG $00 BITS $0200 [Def: 936a.1]
R_LT_A                  BITNOT REG $00 BITS $0800 [Def: 906a.1]
R_LT_AL                 BITNOT REG $00 BITS $0400 [Def: 916a.1]
R_NE_A                  BITNOT REG $00 BITS $2000 [Def: 886a.1]
R_NE_AL                 BITNOT REG $00 BITS $1000 [Def: 896a.1]
SAR1                    Macro                [Def: 994a]
SCHECK                  REG $09 BITS $0100   [Def: 510a]
SCLK                    REG $08 BITS $0400   [Def: 226] [Ref: 228]
SDIN                    REG $08 BITS $0080   [Def: 225] [Ref: 228]
SDOUT                   REG $07 BITS $0800   [Def: 227] [Ref: 229 257 124d]
SECURITY                Undefined            [Def*: 129a*]
SECURITY_ADDR           Undefined            [Def*: 853a*]
SENSORDATA              REG $E0              [Def: 267] [Ref: 128d]
SETADDRESSIN            REG $08 BITS $0001   [Def: 212] [Ref: 235 249 65d 66d 70d]
SETADDRESSIN_PIN        $0000                [Def: 52] [Ref: 212]
SETADDRESSOUT           REG $06 BITS $1000   [Def: 213] [Ref: 236 246 250 89d 115d]
SETADDRESSOUT_PIN       $000C                [Def: 53] [Ref: 213]
SETAEQI                 "BSET A_EQ_I"        [Def: 882a.5]
SETAEQIL                "BSET A_EQ_IL"       [Def: 892a.5]
SETAEQR                 "BSET A_EQ_R"        [Def: 880a.5]
SETAEQRL                "BSET A_EQ_RL"       [Def: 890a.5]
SETAGEI                 "BSET A_GE_I"        [Def: 902a.5]
SETAGEIL                "BSET A_GE_IL"       [Def: 912a.5]
SETAGER                 "BSET A_GE_R"        [Def: 935a.5]
SETAGTI                 "BSET A_GT_I"        [Def: 932a.5]
SETAGTR                 "BSET A_GT_R"        [Def: 905a.5]
SETAGTRL                "BSET A_GT_RL"       [Def: 915a.5]
SETALEI                 "BSET A_LE_I"        [Def: 937a.5]
SETALER                 "BSET A_LE_R"        [Def: 900a.5]
SETALERL                "BSET A_LE_RL"       [Def: 910a.5]
SETALTI                 "BSET A_LT_I"        [Def: 907a.5]
SETALTIL                "BSET A_LT_IL"       [Def: 917a.5]
SETALTR                 "BSET A_LT_R"        [Def: 930a.5]
SETANEI                 "BSET A_NE_I"        [Def: 887a.5]
SETANEIL                "BSET A_NE_IL"       [Def: 897a.5]
SETANER                 "BSET A_NE_R"        [Def: 885a.5]
SETANERL                "BSET A_NE_RL"       [Def: 895a.5]
SETBIGREF               $0001                [Def: 59] [Ref: 286]
SETBW                   "BSET BW"            [Def: 872a.5]
SETBWL                  "BSET BWL"           [Def: 874a.5]
SETC                    "BSET C"             [Def: 470a.5]
SETCL                   "BSET CL"            [Def: 471a.5]
SETCNZ                  "BSET CNZ"           [Def: 472a.5]
SETIEQA                 "BSET I_EQ_A"        [Def: 883a.5]
SETIEQAL                "BSET I_EQ_AL"       [Def: 893a.5]
SETIGEA                 "BSET I_GE_A"        [Def: 938a.5]
SETIGTA                 "BSET I_GT_A"        [Def: 908a.5]
SETIGTAL                "BSET I_GT_AL"       [Def: 918a.5]
SETILEA                 "BSET I_LE_A"        [Def: 903a.5]
SETILEAL                "BSET I_LE_AL"       [Def: 913a.5]
SETILTA                 "BSET I_LT_A"        [Def: 933a.5]
SETINEA                 "BSET I_NE_A"        [Def: 888a.5]
SETINEAL                "BSET I_NE_AL"       [Def: 898a.5]
SETNBW                  "BSET NBW"           [Def: 873a.5]
SETNBWL                 "BSET NBWL"          [Def: 875a.5]
SETNC                   "BSET NC"            [Def: 868a.5]
SETNCL                  "BSET NCL"           [Def: 869a.5]
SETNCNZ                 "BSET NCNZ"          [Def: 870a.5]
SETNZ                   "BSET NZ"            [Def: 866a.5]

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 57

Symbol table (alphabetical and cross-ref)


SETNZL                  "BSET NZL"           [Def: 867a.5]
SETREQA                 "BSET R_EQ_A"        [Def: 881a.5]
SETREQAL                "BSET R_EQ_AL"       [Def: 891a.5]
SETRGEA                 "BSET R_GE_A"        [Def: 901a.5]
SETRGEAL                "BSET R_GE_AL"       [Def: 911a.5]
SETRGTA                 "BSET R_GT_A"        [Def: 931a.5]
SETRLEA                 "BSET R_LE_A"        [Def: 936a.5]
SETRLTA                 "BSET R_LT_A"        [Def: 906a.5]
SETRLTAL                "BSET R_LT_AL"       [Def: 916a.5]
SETRNEA                 "BSET R_NE_A"        [Def: 886a.5]
SETRNEAL                "BSET R_NE_AL"       [Def: 896a.5]
SETZ                    "BSET Z"             [Def: 468a.5]
SETZL                   "BSET ZL"            [Def: 469a.5]
SHL1                    Macro                [Def: 972a]
SHR1                    Macro                [Def: 983a]
SIMANASEQ               REG $F6              [Def: 1835a] [Ref: 1836a 1837a 1838a 1839a 1840a 1841a]
SIMANASEQ_C             REG $F6 BITS $0003   [Def: 1841a]
SIMANASEQ_CHN           REG $F6 BITS $1800   [Def: 1837a]
SIMANASEQ_CVI           REG $F6 BITS $2000   [Def: 1836a]
SIMANASEQ_J             REG $F6 BITS $003C   [Def: 1840a]
SIMANASEQ_JHIGH         REG $F6 BITS $0040   [Def: 1839a]
SIMANASEQ_S             REG $F6 BITS $0780   [Def: 1838a]
SIMARG                  REG $FA              [Def: 1830a]
SIMCTL                  REG $FB              [Def: 1831a] [Ref: 1850a 1851a 1852a 1854a 1855a 1856a 1857a 1858a
                         1862a]
SIMCTL_CMD              REG $FB BITS $F000   [Def: 1862a] [Ref: 1864a 1865a 1866a 1867a 1868a 1869a]
SIMCTL_CMD_COUNTBGCLK   $9000                [Def: 1868a]
SIMCTL_CMD_COUNTCLKIN   $7000                [Def: 1867a]
SIMCTL_CMD_COUNTCLKOUT  $6000                [Def: 1866a]
SIMCTL_CMD_COUNTTIME    $5000                [Def: 1865a]
SIMCTL_CMD_NONE         $0000                [Def: 1864a]
SIMCTL_CMD_SPIMON       $A000                [Def: 1869a]
SIMCTL_DELAYPDIR0       REG $FB BITS $0020   [Def: 1855a]
SIMCTL_DELAYPOUT0       REG $FB BITS $0010   [Def: 1854a]
SIMCTL_EXTWDIR          REG $FB BITS $0080   [Def: 1857a]
SIMCTL_EXTWOUT          REG $FB BITS $0040   [Def: 1856a]
SIMCTL_FASTTEST         REG $FB BITS $0100   [Def: 1858a]
SIMCTL_FASTTIMERS       REG $FB BITS $0001   [Def: 1850a]
SIMCTL_NOTRACE          REG $FB BITS $0004   [Def: 1852a]
SIMCTL_NOXTAL           REG $FB BITS $0002   [Def: 1851a]
SIMEXTPDIR              REG $F2              [Def: 1827a]
SIMEXTPOUT              REG $F3              [Def: 1828a]
SIMMAP                  REG $F7              [Def: 1829a]
SINCE_T1004B            $0001                [Def: 62a] [Ref: 71a 72a]
SINCE_T1004C            $0001                [Def: 63a] [Ref: 706a 716a]
SINCE_T1005             $0001                [Def: 64a] [Ref: 70a 73a 536a 571a 677a 682a 687a]
SINCE_T1005A4           $0000                [Def: 65a]
SINCE_T1006             $0000                [Def: 66a] [Ref: 73a 74a 75a]
SINCE_T1006A4           $0000                [Def: 67a]
SINCE_T1006B            $0000                [Def: 68a] [Ref: 75a 76a 709a 711a 719a 721a]
SKPAEQI                 "IFCLR A_EQ_I"       [Def: 882a.4]
SKPAEQIL                "IFCLR A_EQ_IL"      [Def: 892a.4]
SKPAEQR                 "IFCLR A_EQ_R"       [Def: 880a.4]
SKPAEQRL                "IFCLR A_EQ_RL"      [Def: 890a.4]
SKPAGEI                 "IFCLR A_GE_I"       [Def: 902a.4]
SKPAGEIB                "SKPCB"              [Def: 922a.3]
SKPAGEIL                "IFCLR A_GE_IL"      [Def: 912a.4]
SKPAGER                 "IFCLR A_GE_R"       [Def: 935a.4]
SKPAGERB                "SKPNCNZB"           [Def: 945a.3]
SKPAGTI                 "IFCLR A_GT_I"       [Def: 932a.4]
SKPAGTIB                "SKPCNZB"            [Def: 942a.3]
SKPAGTR                 "IFCLR A_GT_R"       [Def: 905a.4]
SKPAGTRB                "SKPNCB"             [Def: 925a.3]
SKPAGTRL                "IFCLR A_GT_RL"      [Def: 915a.4]
SKPALEI                 "IFCLR A_LE_I"       [Def: 937a.4]
SKPALEIB                "SKPNCNZB"           [Def: 947a.3]
SKPALER                 "IFCLR A_LE_R"       [Def: 900a.4]
SKPALERB                "SKPCB"              [Def: 920a.3]
SKPALERL                "IFCLR A_LE_RL"      [Def: 910a.4]
SKPALTI                 "IFCLR A_LT_I"       [Def: 907a.4]
SKPALTIB                "SKPNCB"             [Def: 927a.3]
SKPALTIL                "IFCLR A_LT_IL"      [Def: 917a.4]
SKPALTR                 "IFCLR A_LT_R"       [Def: 930a.4]

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 58

Symbol table (alphabetical and cross-ref)


SKPALTRB                "SKPCNZB"            [Def: 940a.3]
SKPANEI                 "IFCLR A_NE_I"       [Def: 887a.4]
SKPANEIL                "IFCLR A_NE_IL"      [Def: 897a.4]
SKPANER                 "IFCLR A_NE_R"       [Def: 885a.4]
SKPANERL                "IFCLR A_NE_RL"      [Def: 895a.4]
SKPBW                   "IFCLR BW"           [Def: 872a.4]
SKPBWB                  "SKPNCB"             [Def: 877a.3]
SKPBWL                  "IFCLR BWL"          [Def: 874a.4]
SKPC                    "IFCLR C"            [Def: 470a.4]
SKPCB                   "IFNCB"              [Def: 950a]
SKPCL                   "IFCLR CL"           [Def: 471a.4]
SKPCNZ                  "IFCLR CNZ"          [Def: 472a.4]
SKPCNZB                 "IFNCNZB"            [Def: 952a]
SKPIEQA                 "IFCLR I_EQ_A"       [Def: 883a.4]
SKPIEQAL                "IFCLR I_EQ_AL"      [Def: 893a.4]
SKPIGEA                 "IFCLR I_GE_A"       [Def: 938a.4]
SKPIGEAB                "SKPNCNZB"           [Def: 948a.3]
SKPIGTA                 "IFCLR I_GT_A"       [Def: 908a.4]
SKPIGTAB                "SKPNCB"             [Def: 928a.3]
SKPIGTAL                "IFCLR I_GT_AL"      [Def: 918a.4]
SKPILEA                 "IFCLR I_LE_A"       [Def: 903a.4]
SKPILEAB                "SKPCB"              [Def: 923a.3]
SKPILEAL                "IFCLR I_LE_AL"      [Def: 913a.4]
SKPILTA                 "IFCLR I_LT_A"       [Def: 933a.4]
SKPILTAB                "SKPCNZB"            [Def: 943a.3]
SKPINEA                 "IFCLR I_NE_A"       [Def: 888a.4]
SKPINEAL                "IFCLR I_NE_AL"      [Def: 898a.4]
SKPNBW                  "IFCLR NBW"          [Def: 873a.4]
SKPNBWB                 "SKPCB"              [Def: 878a.3]
SKPNBWL                 "IFCLR NBWL"         [Def: 875a.4]
SKPNC                   "IFCLR NC"           [Def: 868a.4]
SKPNCB                  "IFCB"               [Def: 951a]
SKPNCL                  "IFCLR NCL"          [Def: 869a.4]
SKPNCNZ                 "IFCLR NCNZ"         [Def: 870a.4]
SKPNCNZB                "IFCNZB"             [Def: 953a]
SKPNZ                   "IFCLR NZ"           [Def: 866a.4]
SKPNZL                  "IFCLR NZL"          [Def: 867a.4]
SKPREQA                 "IFCLR R_EQ_A"       [Def: 881a.4]
SKPREQAL                "IFCLR R_EQ_AL"      [Def: 891a.4]
SKPRGEA                 "IFCLR R_GE_A"       [Def: 901a.4]
SKPRGEAB                "SKPCB"              [Def: 921a.3]
SKPRGEAL                "IFCLR R_GE_AL"      [Def: 911a.4]
SKPRGTA                 "IFCLR R_GT_A"       [Def: 931a.4]
SKPRGTAB                "SKPCNZB"            [Def: 941a.3]
SKPRLEA                 "IFCLR R_LE_A"       [Def: 936a.4]
SKPRLEAB                "SKPNCNZB"           [Def: 946a.3]
SKPRLTA                 "IFCLR R_LT_A"       [Def: 906a.4]
SKPRLTAB                "SKPNCB"             [Def: 926a.3]
SKPRLTAL                "IFCLR R_LT_AL"      [Def: 916a.4]
SKPRNEA                 "IFCLR R_NE_A"       [Def: 886a.4]
SKPRNEAL                "IFCLR R_NE_AL"      [Def: 896a.4]
SKPUNAME                Undefined            [Def*: 349a* 360a*]
SKPZ                    "IFCLR Z"            [Def: 468a.4]
SKPZL                   "IFCLR ZL"           [Def: 469a.4]
SP32                    Undefined            [Def*: 858a*]
SPIRX                   REG $EE              [Def: 435a] [Ref: 79d 109d]
SPITX                   REG $0B              [Def: 412a] [Ref: 129d 205d]
SPI_BUFFER              REG $40              [Def: 202] [Ref: 204 45b 305b 54d 193d]
SPI_SCLK_PIN            $000A                [Def: 753a]
SPI_SDIN_PIN            $0007                [Def: 752a]
SPI_SDOUT_PIN           $000B                [Def: 754a]
SPI_SSB_PIN             $0006                [Def: 751a]
SRUN                    Undefined            [Def*: 857a*]
SSB                     REG $08 BITS $0040   [Def: 224] [Ref: 228 254 260 61d 71d 73d 75d 98d 100d]
START                   Undefined            [Def*: 1617a*] [Ref*: 1585a* 1638a* 1639a* 1646a* 1650a*]
STATUS                  REG $00 BITS $FF00   [Def: 464a]
STATX                   REG $00              [Def: 400a] [Ref: 464a 465a 468a.1 469a.1 470a.1 471a.1 472a.1
                         1624a* 291b 303b 191d 203d 208d 233d 239d]
STATX_RESERVED          $C100                [Def: 476a]
SUBR                    Undefined            [Def*: 133a*]
SUBR0                   Undefined            [Def*: 93a* 105a* 119a*] [Ref*: 133a*]
SUBR1                   Undefined            [Def*: 97a* 109a* 123a*]
SWPE                    Undefined            [Def*: 855a*]

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 59

Symbol table (alphabetical and cross-ref)


SWPS                    Undefined            [Def*: 856a*]
T1_BEGIN                LADDR $0002          [Seg: ORG:0] [Def: 20b] [Ref: 8b]
T1_BLUE_DATA            REG $18              [Def: 160] [Ref: 90b 99b 109b 118b 128b 138b 148b 158b 168b 178b
                         187b 197b 207b 217b 227b 237b 390b 108c]
T1_CURRENTDATA          REG $0F              [Def: 135] [Ref: 298b 326b 327b 347b 355b 363b 371b]
T1_DATAREADY            REG $0C BITS $0001   [Def: 150] [Ref: 247b 379b 392b 98c 114c]
T1_GREEN_DATA           REG $17              [Def: 159] [Ref: 88b 97b 107b 116b 126b 136b 146b 156b 166b 176b
                         185b 195b 205b 215b 225b 235b 388b 105c]
T1_HAVEADDRESS          REG $0C BITS $0002   [Def: 154] [Ref: 69b 54c 64c 85d]
T1_MAIN                 LADDR $00AB          [Seg: ORG:0] [Def: 278b] [Ref: 293b 343b 352b 360b 368b 394b]
T1_RECEIVEPWMSTATE      REG $10              [Def: 138] [Ref: 139 140 141 351b 359b 367b 374b]
T1_RECEIVING_BLUE       REG $14              [Def: 147] [Ref: 373b 389b]
T1_RECEIVING_GREEN      REG $13              [Def: 146] [Ref: 365b 387b]
T1_RECEIVING_RED        REG $12              [Def: 145] [Ref: 357b 385b]
T1_RECEIVING_TIME       REG $11              [Def: 144] [Ref: 349b 383b]
T1_RED_DATA             REG $16              [Def: 158] [Ref: 86b 95b 105b 114b 124b 134b 144b 154b 164b 174b
                         183b 193b 203b 213b 223b 233b 386b 102c]
T1_TIME_DATA            REG $15              [Def: 157] [Ref: 244b 245b 384b 111c]
T1_WAITFORBUFFEREMPTY   LADDR $00DF          [Seg: ORG:0] [Def: 377b] [Ref: 380b]
T2_BLUE_DATA            REG $23              [Def: 171] [Ref: 109c 143c]
T2_BLUE_ROTATE          REG $26              [Def: 177] [Ref: 144c 246c]
T2_GREEN_DATA           REG $22              [Def: 170] [Ref: 106c 140c]
T2_GREEN_ROTATE         REG $25              [Def: 176] [Ref: 141c 242c]
T2_INITIALIZEPORTS      LADDR $011C          [Seg: SUBR0] [Def: 274c] [Ref: 211c]
T2_MAIN                 LADDR $014A          [Seg: CODE0] [Def: 72c] [Ref: 55c 65c 225c]
T2_OFFWAITINGLOOP       LADDR $0145          [Seg: CODE0] [Def: 63c] [Ref: 68c]
T2_ONWAITINGLOOP        LADDR $013D          [Seg: CODE0] [Def: 53c] [Ref: 58c]
T2_RED_DATA             REG $21              [Def: 169] [Ref: 103c 137c]
T2_RED_ROTATE           REG $24              [Def: 175] [Ref: 138c 238c]
T2_START                LADDR $0138          [Seg: CODE0] [Def: 41c] [Ref: 56b]
T2_TIME_DATA            REG $20              [Def: 168] [Ref: 43c 83c 87c 112c]
T2_TOGGLELIGHTS         LADDR $0139          [Seg: CODE0] [Def: 48c] [Ref: 70c]
T2_UPDATELEDS           LADDR $0101          [Seg: SUBR0] [Def: 233c] [Ref: 147c 150c 159c 166c 173c 180c 187c
                         194c 201c 208c]
T2_WAIT_10A_AND_4       LADDR $010F          [Seg: SUBR0] [Def: 259c] [Ref: 162c 169c 176c 183c 190c 197c 204c
                         214c 269c]
T3_CURRENTDATA          REG $31              [Def: 187] [Ref: 80d 110d 158d 185d 202d 215d 222d 229d]
T3_INITIALIZEPORTS      LADDR $012A          [Seg: SUBR0] [Def: 248d] [Ref: 55d]
T3_MAIN                 LADDR $01B5          [Seg: CODE0] [Def: 93d] [Ref: 120d 170d 172d 179d 180d 198d 210d
                         218d 225d 241d]
T3_READREGISTER         LADDR $01E5          [Seg: CODE0] [Def: 201d] [Ref: 171d]
T3_SENDDATATOTHR1       LADDR $01DB          [Seg: CODE0] [Def: 184d] [Ref: 165d 166d 167d 168d 173d 174d 175d
                         176d]
T3_START                LADDR $019E          [Seg: CODE0] [Def: 46d] [Ref: 61b]
T3_WRITEDATAHIGH        LADDR $01F2          [Seg: CODE0] [Def: 227d] [Ref: 178d]
T3_WRITEDATALOW         LADDR $01EF          [Seg: CODE0] [Def: 220d] [Ref: 177d]
T3_WRITEREGISTER        LADDR $01EC          [Seg: CODE0] [Def: 213d] [Ref: 169d]
T3_WRITEREGISTERADDRESS REG $33              [Def: 190] [Ref: 49d 216d 232d]
T3_WRITEREGISTERDATA    REG $34              [Def: 192] [Ref: 223d 230d 235d]
TALT                    REG $09 BITS $0040   [Def: 512a] [Ref: 52b]
TCTL                    REG $F5              [Def: 456a] [Ref: 578a 579a 580a 581a 582a 583a 416b]
TCTL_RESERVED           $FC00                [Def: 586a]
TEN2                    REG $09 BITS $0800   [Def: 507a] [Ref: 59b]
TEN3                    REG $09 BITS $1000   [Def: 506a] [Ref: 64b]
TEXTEQUDEF              Macro                [Def: 324a]
TGL                     REG $09 BITS $0200   [Def: 509a]
THEVALUE                Undefined            [Def*: 189a*] [Ref*: 184a* 191a*]
THEVAR                  Undefined            [Def*: 188a*] [Ref*: 184a* 191a* 192a* 192a* 193a* 193a*]
THR                     REG $09 BITS $0003   [Def: 532a] [Ref: 541a 542a 543a 280b 281b 77c 95d]
THR_1                   $0000                [Def: 541a]
THR_2                   $0001                [Def: 542a]
THR_3                   $0002                [Def: 543a]
TOVAL                   Undefined            [Def*: 1614a*] [Ref*: 1585a* 1622a* 1629a* 1635a* 1651a*]
TO_X                    Undefined            [Def*: 1609a* 1612a*] [Ref*: 1585a* 1622a* 1622a* 1622a* 1629a*
                         1629a* 1629a* 1635a* 1635a* 1635a*]
TPC1                    REG $E2              [Def: 429a]
TPC2                    REG $E3              [Def: 430a] [Ref: 57b]
TPC3                    REG $E6              [Def: 431a] [Ref: 62b]
TPRI                    REG $09 BITS $0080   [Def: 511a] [Ref: 53b]
TRDY1                   REG $09 BITS $2000   [Def: 505a]
TRDY2                   REG $09 BITS $0400   [Def: 508a] [Ref: 58b]
TRDY3                   REG $0A BITS $8000   [Def: 499a] [Ref: 63b]
UNAME                   Undefined            [Def*: 347a* 358a*] [Ref*: 345a* 357a*]

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 60

Symbol table (alphabetical and cross-ref)


UNAME__N1               "Z"                  [Def: 468a.2] [Ref: 468a.3 468a.4 468a.5 468a.6 468a.7 468a.10
                         468a.10]
UNAME__N10              "NCNZ"               [Def: 870a.2] [Ref: 870a.3 870a.4 870a.5 870a.6 870a.7 870a.10
                         870a.10]
UNAME__N11              "BW"                 [Def: 872a.2] [Ref: 872a.3 872a.4 872a.5 872a.6 872a.7 872a.10
                         872a.10]
UNAME__N12              "NBW"                [Def: 873a.2] [Ref: 873a.3 873a.4 873a.5 873a.6 873a.7 873a.10
                         873a.10]
UNAME__N13              "BWL"                [Def: 874a.2] [Ref: 874a.3 874a.4 874a.5 874a.6 874a.7 874a.10
                         874a.10]
UNAME__N14              "NBWL"               [Def: 875a.2] [Ref: 875a.3 875a.4 875a.5 875a.6 875a.7 875a.10
                         875a.10]
UNAME__N15              "BWB"                [Def: 877a.1] [Ref: 877a.2 877a.3 877a.4 877a.7 877a.7]
UNAME__N16              "NBWB"               [Def: 878a.1] [Ref: 878a.2 878a.3 878a.4 878a.7 878a.7]
UNAME__N17              "AEQR"               [Def: 880a.2] [Ref: 880a.3 880a.4 880a.5 880a.6 880a.7 880a.10
                         880a.10]
UNAME__N18              "REQA"               [Def: 881a.2] [Ref: 881a.3 881a.4 881a.5 881a.6 881a.7 881a.10
                         881a.10]
UNAME__N19              "AEQI"               [Def: 882a.2] [Ref: 882a.3 882a.4 882a.5 882a.6 882a.7 882a.10
                         882a.10]
UNAME__N2               "ZL"                 [Def: 469a.2] [Ref: 469a.3 469a.4 469a.5 469a.6 469a.7 469a.10
                         469a.10]
UNAME__N20              "IEQA"               [Def: 883a.2] [Ref: 883a.3 883a.4 883a.5 883a.6 883a.7 883a.10
                         883a.10]
UNAME__N21              "ANER"               [Def: 885a.2] [Ref: 885a.3 885a.4 885a.5 885a.6 885a.7 885a.10
                         885a.10]
UNAME__N22              "RNEA"               [Def: 886a.2] [Ref: 886a.3 886a.4 886a.5 886a.6 886a.7 886a.10
                         886a.10]
UNAME__N23              "ANEI"               [Def: 887a.2] [Ref: 887a.3 887a.4 887a.5 887a.6 887a.7 887a.10
                         887a.10]
UNAME__N24              "INEA"               [Def: 888a.2] [Ref: 888a.3 888a.4 888a.5 888a.6 888a.7 888a.10
                         888a.10]
UNAME__N25              "AEQRL"              [Def: 890a.2] [Ref: 890a.3 890a.4 890a.5 890a.6 890a.7 890a.10
                         890a.10]
UNAME__N26              "REQAL"              [Def: 891a.2] [Ref: 891a.3 891a.4 891a.5 891a.6 891a.7 891a.10
                         891a.10]
UNAME__N27              "AEQIL"              [Def: 892a.2] [Ref: 892a.3 892a.4 892a.5 892a.6 892a.7 892a.10
                         892a.10]
UNAME__N28              "IEQAL"              [Def: 893a.2] [Ref: 893a.3 893a.4 893a.5 893a.6 893a.7 893a.10
                         893a.10]
UNAME__N29              "ANERL"              [Def: 895a.2] [Ref: 895a.3 895a.4 895a.5 895a.6 895a.7 895a.10
                         895a.10]
UNAME__N3               "C"                  [Def: 470a.2] [Ref: 470a.3 470a.4 470a.5 470a.6 470a.7 470a.10
                         470a.10]
UNAME__N30              "RNEAL"              [Def: 896a.2] [Ref: 896a.3 896a.4 896a.5 896a.6 896a.7 896a.10
                         896a.10]
UNAME__N31              "ANEIL"              [Def: 897a.2] [Ref: 897a.3 897a.4 897a.5 897a.6 897a.7 897a.10
                         897a.10]
UNAME__N32              "INEAL"              [Def: 898a.2] [Ref: 898a.3 898a.4 898a.5 898a.6 898a.7 898a.10
                         898a.10]
UNAME__N33              "ALER"               [Def: 900a.2] [Ref: 900a.3 900a.4 900a.5 900a.6 900a.7 900a.10
                         900a.10]
UNAME__N34              "RGEA"               [Def: 901a.2] [Ref: 901a.3 901a.4 901a.5 901a.6 901a.7 901a.10
                         901a.10]
UNAME__N35              "AGEI"               [Def: 902a.2] [Ref: 902a.3 902a.4 902a.5 902a.6 902a.7 902a.10
                         902a.10]
UNAME__N36              "ILEA"               [Def: 903a.2] [Ref: 903a.3 903a.4 903a.5 903a.6 903a.7 903a.10
                         903a.10]
UNAME__N37              "AGTR"               [Def: 905a.2] [Ref: 905a.3 905a.4 905a.5 905a.6 905a.7 905a.10
                         905a.10]
UNAME__N38              "RLTA"               [Def: 906a.2] [Ref: 906a.3 906a.4 906a.5 906a.6 906a.7 906a.10
                         906a.10]
UNAME__N39              "ALTI"               [Def: 907a.2] [Ref: 907a.3 907a.4 907a.5 907a.6 907a.7 907a.10
                         907a.10]
UNAME__N4               "CL"                 [Def: 471a.2] [Ref: 471a.3 471a.4 471a.5 471a.6 471a.7 471a.10
                         471a.10]
UNAME__N40              "IGTA"               [Def: 908a.2] [Ref: 908a.3 908a.4 908a.5 908a.6 908a.7 908a.10
                         908a.10]
UNAME__N41              "ALERL"              [Def: 910a.2] [Ref: 910a.3 910a.4 910a.5 910a.6 910a.7 910a.10
                         910a.10]
UNAME__N42              "RGEAL"              [Def: 911a.2] [Ref: 911a.3 911a.4 911a.5 911a.6 911a.7 911a.10
                         911a.10]
UNAME__N43              "AGEIL"              [Def: 912a.2] [Ref: 912a.3 912a.4 912a.5 912a.6 912a.7 912a.10

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 61

Symbol table (alphabetical and cross-ref)


                         912a.10]
UNAME__N44              "ILEAL"              [Def: 913a.2] [Ref: 913a.3 913a.4 913a.5 913a.6 913a.7 913a.10
                         913a.10]
UNAME__N45              "AGTRL"              [Def: 915a.2] [Ref: 915a.3 915a.4 915a.5 915a.6 915a.7 915a.10
                         915a.10]
UNAME__N46              "RLTAL"              [Def: 916a.2] [Ref: 916a.3 916a.4 916a.5 916a.6 916a.7 916a.10
                         916a.10]
UNAME__N47              "ALTIL"              [Def: 917a.2] [Ref: 917a.3 917a.4 917a.5 917a.6 917a.7 917a.10
                         917a.10]
UNAME__N48              "IGTAL"              [Def: 918a.2] [Ref: 918a.3 918a.4 918a.5 918a.6 918a.7 918a.10
                         918a.10]
UNAME__N49              "ALERB"              [Def: 920a.1] [Ref: 920a.2 920a.3 920a.4 920a.7 920a.7]
UNAME__N5               "CNZ"                [Def: 472a.2] [Ref: 472a.3 472a.4 472a.5 472a.6 472a.7 472a.10
                         472a.10]
UNAME__N50              "RGEAB"              [Def: 921a.1] [Ref: 921a.2 921a.3 921a.4 921a.7 921a.7]
UNAME__N51              "AGEIB"              [Def: 922a.1] [Ref: 922a.2 922a.3 922a.4 922a.7 922a.7]
UNAME__N52              "ILEAB"              [Def: 923a.1] [Ref: 923a.2 923a.3 923a.4 923a.7 923a.7]
UNAME__N53              "AGTRB"              [Def: 925a.1] [Ref: 925a.2 925a.3 925a.4 925a.7 925a.7]
UNAME__N54              "RLTAB"              [Def: 926a.1] [Ref: 926a.2 926a.3 926a.4 926a.7 926a.7]
UNAME__N55              "ALTIB"              [Def: 927a.1] [Ref: 927a.2 927a.3 927a.4 927a.7 927a.7]
UNAME__N56              "IGTAB"              [Def: 928a.1] [Ref: 928a.2 928a.3 928a.4 928a.7 928a.7]
UNAME__N57              "ALTR"               [Def: 930a.2] [Ref: 930a.3 930a.4 930a.5 930a.6 930a.7 930a.10
                         930a.10]
UNAME__N58              "RGTA"               [Def: 931a.2] [Ref: 931a.3 931a.4 931a.5 931a.6 931a.7 931a.10
                         931a.10]
UNAME__N59              "AGTI"               [Def: 932a.2] [Ref: 932a.3 932a.4 932a.5 932a.6 932a.7 932a.10
                         932a.10]
UNAME__N6               "NZ"                 [Def: 866a.2] [Ref: 866a.3 866a.4 866a.5 866a.6 866a.7 866a.10
                         866a.10]
UNAME__N60              "ILTA"               [Def: 933a.2] [Ref: 933a.3 933a.4 933a.5 933a.6 933a.7 933a.10
                         933a.10]
UNAME__N61              "AGER"               [Def: 935a.2] [Ref: 935a.3 935a.4 935a.5 935a.6 935a.7 935a.10
                         935a.10]
UNAME__N62              "RLEA"               [Def: 936a.2] [Ref: 936a.3 936a.4 936a.5 936a.6 936a.7 936a.10
                         936a.10]
UNAME__N63              "ALEI"               [Def: 937a.2] [Ref: 937a.3 937a.4 937a.5 937a.6 937a.7 937a.10
                         937a.10]
UNAME__N64              "IGEA"               [Def: 938a.2] [Ref: 938a.3 938a.4 938a.5 938a.6 938a.7 938a.10
                         938a.10]
UNAME__N65              "ALTRB"              [Def: 940a.1] [Ref: 940a.2 940a.3 940a.4 940a.7 940a.7]
UNAME__N66              "RGTAB"              [Def: 941a.1] [Ref: 941a.2 941a.3 941a.4 941a.7 941a.7]
UNAME__N67              "AGTIB"              [Def: 942a.1] [Ref: 942a.2 942a.3 942a.4 942a.7 942a.7]
UNAME__N68              "ILTAB"              [Def: 943a.1] [Ref: 943a.2 943a.3 943a.4 943a.7 943a.7]
UNAME__N69              "AGERB"              [Def: 945a.1] [Ref: 945a.2 945a.3 945a.4 945a.7 945a.7]
UNAME__N7               "NZL"                [Def: 867a.2] [Ref: 867a.3 867a.4 867a.5 867a.6 867a.7 867a.10
                         867a.10]
UNAME__N70              "RLEAB"              [Def: 946a.1] [Ref: 946a.2 946a.3 946a.4 946a.7 946a.7]
UNAME__N71              "ALEIB"              [Def: 947a.1] [Ref: 947a.2 947a.3 947a.4 947a.7 947a.7]
UNAME__N72              "IGEAB"              [Def: 948a.1] [Ref: 948a.2 948a.3 948a.4 948a.7 948a.7]
UNAME__N8               "NC"                 [Def: 868a.2] [Ref: 868a.3 868a.4 868a.5 868a.6 868a.7 868a.10
                         868a.10]
UNAME__N9               "NCL"                [Def: 869a.2] [Ref: 869a.3 869a.4 869a.5 869a.6 869a.7 869a.10
                         869a.10]
VAR                     Undefined            [Def*: 193a* 212a*] [Ref*: 183a* 188a* 194a* 202a* 206a* 208a*
                         211a* 211a* 212a* 212a* 213a*]
VIOLET                  LADDR $0072          [Seg: ORG:0] [Def: 172b]
WAITFORTHREAD3TORECEIVESPIADDRESS LADDR $0020          [Seg: ORG:0] [Def: 66b] [Ref: 70b]
WDTO                    Undefined            [Def*: 528a*]
WHITE_11                LADDR $0082          [Seg: ORG:0] [Def: 191b]
WHITE_12                LADDR $008A          [Seg: ORG:0] [Def: 201b]
WHITE_13                LADDR $0092          [Seg: ORG:0] [Def: 211b]
WHITE_14                LADDR $009A          [Seg: ORG:0] [Def: 221b]
WHITE_15                LADDR $00A2          [Seg: ORG:0] [Def: 231b]
WR                      Undefined            [Def*: 1586a* 1588a* 1615a*] [Ref*: 1585a* 1588a* 1592a* 1592a*
                         1598a* 1600a* 1600a* 1605a* 1605a* 1608a* 1609a* 1611a* 1611a* 1612a* 1615a* 1618a*
                         1624a* 1635a* 1651a*]
X                       REG $00 BITS $00FF   [Def: 465a] [Ref: 38b 287b 301b 307b 189d 195d]
XADCEN                  REG $F8 BITS $0080   [Def: 667a.2] [Ref: 667a.3 667a.4 280]
XCH                     REG $E0              [Def: 445a.2] [Ref: 445a.3 445a.4]
XCH0                    REG $E0              [Def: 446a.2] [Ref: 446a.3 446a.4 267]
XCH12                   REG $EC              [Def: 449a.2] [Ref: 449a.3 449a.4]
XCH16                   REG $F0              [Def: 450a.2] [Ref: 450a.3 450a.4]
XCH4                    REG $E4              [Def: 447a.2] [Ref: 447a.3 447a.4]

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 62

Symbol table (alphabetical and cross-ref)


XCH8                    REG $E8              [Def: 448a.2] [Ref: 448a.3 448a.4]
XHCTL                   REG $FC              [Def: 452a.2] [Ref: 452a.3 452a.4 674a.2 688a 689a 690a 692a* 693a*
                         694a* 695a* 419b]
XHCTL_RESERVED          $FC00                [Def: 727a]
XLCTL                   REG $F8              [Def: 451a.2] [Ref: 451a.3 451a.4 665a.2 666a.2 667a.2 671a.2 678a
                         422b]
XLCTL_RESERVED          $FC00                [Def: 725a]
XMASK                   Undefined            [Def*: 1598a* 1600a* 1602a* 1605a*] [Ref*: 1585a* 1605a* 1608a*
                         1609a* 1611a* 1612a*]
XREFEN                  REG $F8 BITS $0100   [Def: 666a.2] [Ref: 666a.3 666a.4 279]
XREFHI                  REG $FC BITS $003F   [Def: 674a.2] [Ref: 674a.3 674a.4]
XREFLO                  REG $F8 BITS $003F   [Def: 671a.2] [Ref: 671a.3 671a.4]
XREGS                   REG $E0              [Def: 444a.2] [Ref: 444a.3 444a.4]
XRES                    REG $09 BITS $0004   [Def: 520a* 524a]
XSENSE                  REG $F8 BITS $0200   [Def: 665a.2] [Ref: 665a.3 665a.4 278]
XTSLP                   Undefined            [Def*: 527a*]
XYADCEN                 REG ($F8 ALT $F9) BITS $0080 [Def: 667a.4] [Ref: 667a.5]
XYALLOC                 Macro                [Def: 202a* 214a* 227a]
XYBCMP                  Undefined            [Def*: 669a*]
XYCH                    REG ($E0 ALT $E1)    [Def: 445a.4] [Ref: 445a.5]
XYCH0                   REG ($E0 ALT $E1)    [Def: 446a.4] [Ref: 446a.5]
XYCH12                  REG ($EC ALT $ED)    [Def: 449a.4] [Ref: 449a.5]
XYCH16                  REG ($F0 ALT $F1)    [Def: 450a.4] [Ref: 450a.5]
XYCH4                   REG ($E4 ALT $E5)    [Def: 447a.4] [Ref: 447a.5]
XYCH8                   REG ($E8 ALT $E9)    [Def: 448a.4] [Ref: 448a.5]
XYEQU                   Macro                [Def: 183a* 195a* 218a] [Ref: 444a 445a 446a 447a 448a 449a 450a
                         451a 452a 665a 666a 667a 671a 674a]
XYHCTL                  REG ($FC ALT $FD)    [Def: 452a.4] [Ref: 452a.5 674a.1]
XYLCTL                  REG ($F8 ALT $F9)    [Def: 451a.4] [Ref: 451a.5 665a.1 666a.1 667a.1 669a* 671a.1]
XYREFEN                 REG ($F8 ALT $F9) BITS $0100 [Def: 666a.4] [Ref: 666a.5]
XYREFHI                 REG ($FC ALT $FD) BITS $003F [Def: 674a.4] [Ref: 674a.5]
XYREFLO                 REG ($F8 ALT $F9) BITS $003F [Def: 671a.4] [Ref: 671a.5]
XYREGS                  REG ($E0 ALT $E1)    [Def: 444a.4] [Ref: 444a.5]
XYSENSE                 REG ($F8 ALT $F9) BITS $0200 [Def: 665a.4] [Ref: 665a.5]
YADCEN                  REG $F9 BITS $0080   [Def: 667a.3] [Ref: 667a.4]
YCH                     REG $E1              [Def: 445a.3] [Ref: 445a.4]
YCH0                    REG $E1              [Def: 446a.3] [Ref: 446a.4]
YCH12                   REG $ED              [Def: 449a.3] [Ref: 449a.4]
YCH16                   REG $F1              [Def: 450a.3] [Ref: 450a.4 454a]
YCH4                    REG $E5              [Def: 447a.3] [Ref: 447a.4]
YCH8                    REG $E9              [Def: 448a.3] [Ref: 448a.4]
YELLOW                  LADDR $0042          [Seg: ORG:0] [Def: 112b]
YHCTL                   REG $FD              [Def: 452a.3] [Ref: 452a.4 699a 700a 425b]
YHCTL_RESERVED          $FC00                [Def: 728a]
YLCTL                   REG $F9              [Def: 451a.3] [Ref: 451a.4 683a 428b]
YLCTL_RESERVED          $FC00                [Def: 726a]
YREFEN                  REG $F9 BITS $0100   [Def: 666a.3] [Ref: 666a.4]
YREFHI                  REG $FD BITS $003F   [Def: 674a.3] [Ref: 674a.4]
YREFLO                  REG $F9 BITS $003F   [Def: 671a.3] [Ref: 671a.4]
YREGS                   REG $E1              [Def: 444a.3] [Ref: 444a.4]
YSENSE                  REG $F9 BITS $0200   [Def: 665a.3] [Ref: 665a.4]
Z                       REG $00 BITS $2000   [Def: 468a.1] [Ref: 866a.1 880a.1 881a.1 882a.1 883a.1 84c]
ZERO                    Undefined            [Def*: 91a* 103a* 117a*]
ZL                      REG $00 BITS $1000   [Def: 469a.1] [Ref: 867a.1 890a.1 891a.1 892a.1 893a.1 292b 304b
                         192d]
_ADD_OK                 "((((X) + $0080) AND $FF00) == $0000)" [Def: 1097a]
_ADJACENT_BITS          "((((X) + _LOW_BIT((X))) AND (X)) == 0)" [Def: 1123a]
_ADJ_LOW_BITS           "((((X) + 1) AND (X)) == 0)" [Def: 1126a]
_ASM_ASMDIR             "/toolbox/release/all-arch/include/asmt4" [Def: (built-in)]
_ASM_ASMVER             "/toolbox/release/all-arch/bin/asmt4.pl, version of Thu May 19 16:40:29 2005, Perl 5.8.0
                         for linux" [Def: (built-in)]
_ASM_CHASM              Undefined            [Ref: 2a 14a 82a 178a 309a 339a 439a 1576a 1658a]
_ASM_CMDLINE            "/toolbox/release/all-arch/bin/asmt4.pl -opdr.666 pwm_main.asm" [Def: (built-in)]
_ASM_DATE               "6/17/05 18:29:50"   [Def: (built-in)]
_ASM_DAY                $0011                [Def: (built-in)]
_ASM_ERRORS             $0000                [Def: (built-in)]
_ASM_HEXDIR             "/home/jjacobi/firmware/pwm/" [Def: (built-in)]
_ASM_HEXNAME            "/home/jjacobi/firmware/pwm/pdr.666" [Def: (built-in)] [Ref: 25]
_ASM_HOST               "cobra.synaptics.com" [Def: (built-in)]
_ASM_HOUR               $0012                [Def: (built-in)]
_ASM_INSTRUCTION_COUNT  $01FE               
_ASM_LSTDIR             "/home/jjacobi/firmware/pwm/" [Def: (built-in)]
_ASM_LSTNAME            "/home/jjacobi/firmware/pwm/pdr.666.lst" [Def: (built-in)] [Ref: 25]

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 63

Symbol table (alphabetical and cross-ref)


_ASM_MAXVERSION         1.003                [Def: (built-in)]
_ASM_MINUTE             $001D                [Def: (built-in)]
_ASM_MONTH              $0006                [Def: (built-in)]
_ASM_PROCESSOR          $0011                [Def: (built-in)] [Ref: 62a 63a 64a 65a 66a 67a 68a]
_ASM_SECOND             $0032                [Def: (built-in)]
_ASM_SRCDIR             "/home/jjacobi/firmware/pwm/" [Def: (built-in)]
_ASM_SRCNAME            "/home/jjacobi/firmware/pwm/pwm_main.asm" [Def: (built-in)]
_ASM_USER               "jjacobi"            [Def: (built-in)]
_ASM_VERSION            1.000                [Def: (built-in)]
_ASM_WARNINGS           $0000                [Def: (built-in)]
_ASM_YEAR               $07D5                [Def: (built-in)]
_BW_OK                  "(((X) == $FFFF) || ((X) == $00FF) || ((X) == $FF00))" [Def: 1100a]
_BYTE_FILL              "((IF (((X) AND $FF00) != 0) THEN $FF00 ELSE $0000) OR (IF (((X) AND $00FF) != 0) THEN
                         $00FF ELSE $0000))" [Def: 1104a] [Ref*: 1600a*]
_HIGH_BIT               "(1 SHL LOG2((X)))"  [Def: 1117a]
_LOW_BIT                "((X) AND -(X))"     [Def: 1111a]
_MOV_FILL               "((MUST) OR (_BYTE_FILL((MUST)) AND (MAY)))" [Def: 1108a]
_MOV_OK                 "((((X) AND $FF00) == $0000) || (((X) AND $FF00) == $FF00) || (((X) AND $00FF) == $0000)
                         || (((X) AND $00FF) == $00FF))" [Def: 1091a]
_MUTATE_A               Macro                [Def: 1131a]
_MUTATE_R               Macro                [Def: 1352a]
_MUTATE_R_COM           Macro                [Def: 1326a]
_MUTATE_R_GEN           Macro                [Def: 1280a]
_MUTATE_X               Macro                [Def: 1508a]
_OR_OK                  "((((X) AND $FF00) == $0000) || (((X) AND $00FF) == $0000))" [Def: 1094a]
_OTHER_BITS             "((X) AND ((X)-1))"  [Def: 1114a]
_PROC_BANKSIZE          $0040                [Def: 785a]
_PROC_CODESIZE          $00010000            [Def: 781a]
_PROC_DATASIZE          $0100                [Def: 786a]
_PROC_FIRSTRAM          REG $0C              [Def: 783a]
_PROC_IS_CHIMERA        FALSE                [Def: 791a]
_PROC_IS_T1004          $0000                [Def: 787a]
_PROC_IS_T1005          $0001                [Def: 788a]
_PROC_IS_T1006          $0000                [Def: 789a]
_PROC_IS_T100X          TRUE                 [Def: 790a] [Ref: 792a]
_PROC_LASTRAM           REG $DF              [Def: 784a]
_PROC_OR_INDEX          TRUE                 [Def: 792a]
_PROC_RAMWIDTH          $0010                [Def: 782a]
_PROC_ROMBLANK          $FFFF                [Def: 768a 772a*]
_PROC_ROMOFFSET         $A000                [Def: 780a]
_PROC_ROMSIZE           $1000                [Def: 769a 774a* 776a*]
_PROC_ROMWIDTH          $0010                [Def: 767a 771a*]
_SEG_SIZE_CODE0         $00C5               
_SEG_SIZE_ORG_0         $00ED               
_SEG_SIZE_ORG_3071      $0001               
_SEG_SIZE_SUBR0         $004B               
_SEG_START_CODE0        LADDR $0138         
_SEG_START_ORG_0        LADDR $0000         
_SEG_START_ORG_3071     LADDR $0BFF         
_SEG_START_SUBR0        LADDR $00ED         
_THR_1                  $0001                [Def: 801a] [Ref: 804a]
_THR_2                  $0002                [Def: 802a] [Ref: 804a]
_THR_3                  $0004                [Def: 803a] [Ref: 804a]
_THR_ANY                $0007                [Def: 804a]
_TWO_BITS               "PO2(_OTHER_BITS((X)))" [Def: 1120a]

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 64

Symbol table (numerical)


$0000                           BASEPAUXMASK
$0000                           BASEYHCTLMASK
$0000                           COLOR_BLUEVIOLET_AMOUNT_GREEN
$0000                           COLOR_BLUE_AMOUNT_GREEN
$0000                           COLOR_BLUE_AMOUNT_RED
$0000                           COLOR_CYAN_AMOUNT_RED
$0000                           COLOR_GREEN_AMOUNT_BLUE
$0000                           COLOR_GREEN_AMOUNT_RED
$0000                           COLOR_MAGENTA_AMOUNT_GREEN
$0000                           COLOR_ORANGE_AMOUNT_BLUE
$0000                           COLOR_RED_AMOUNT_BLUE
$0000                           COLOR_RED_AMOUNT_GREEN
$0000                           COLOR_VIOLET_AMOUNT_GREEN
$0000                           COLOR_YELLOW_AMOUNT_BLUE
$0000                           GS_1_000
$0000                           IS_T1004
$0000                           IS_T1004A
$0000                           IS_T1004B
$0000                           IS_T1004_6
$0000                           IS_T1006
$0000                           IS_T1006A
$0000                           IS_T1006B
$0000                           MASKREV_T1004A
$0000                           OCTL_GUARD_VAL
$0000                           PSEL_DSHIELDH
$0000                           PSEL_SHIELDH
$0000                           SETADDRESSIN_PIN
$0000                           SIMCTL_CMD_NONE
$0000                           SINCE_T1005A4
$0000                           SINCE_T1006
$0000                           SINCE_T1006A4
$0000                           SINCE_T1006B
$0000                           THR_1
$0000                           _ASM_ERRORS
$0000                           _ASM_WARNINGS
$0000                           _PROC_IS_T1004
$0000                           _PROC_IS_T1006
$0001                           HASPACKRAT
$0001                           IS_T1005
$0001                           IS_T1005_6
$0001                           MASKREV_T1004AA
$0001                           PSEL_SAMPLE
$0001                           PWM_RED_PIN
$0001                           SETBIGREF
$0001                           SINCE_T1004B
$0001                           SINCE_T1004C
$0001                           SINCE_T1005
$0001                           THR_2
$0001                           _PROC_IS_T1005
$0001                           _SEG_SIZE_ORG_3071
$0001                           _THR_1
$00010000                       _PROC_CODESIZE
$0002                           MASKREV_T1004AB
$0002                           PSEL_XIREFLO
$0002                           PWM_GREEN_PIN
$0002                           THR_3
$0002                           _THR_2
$0003                           MASKREV_T1004AC
$0003                           PSEL_YIREFLO
$0003                           PWM_BLUE_PIN
$0004                           PSEL_XCHGVG
$0004                           _THR_3
$0005                           PSEL_YCHGVG
$0006                           PSEL_XREFHI
$0006                           SPI_SSB_PIN
$0006                           _ASM_MONTH
$0007                           PSEL_YREFHI
$0007                           SPI_SDIN_PIN
$0007                           _THR_ANY
$0008                           MASKREV_T1004B
$0008                           PSEL_XREFLO
$0009                           MASKREV_T1004BA
$0009                           PSEL_YREFLO

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 65

Symbol table (numerical)


$000A                           MASKREV_T1004BB
$000A                           MASKREV_T1004BC
$000A                           PSEL_XMINREF
$000A                           SPI_SCLK_PIN
$000B                           MASKREV_T1004BD
$000B                           PSEL_YMINREF
$000B                           SPI_SDOUT_PIN
$000C                           MASKREV_T1004BE
$000C                           PSEL_ASHIELDL
$000C                           PSEL_SHIELDL
$000C                           SETADDRESSOUT_PIN
$000D                           PSEL_BGCLOCK
$000D                           PSEL_LSO
$000E                           BASEPDIRMASK
$000E                           BITMASK_PWMS
$000E                           PSEL_GROUND
$000F                           MASKREV_T1004C
$000F                           PSEL_VDD
$0010                           BESTGUESSXREFLO
$0010                           MASKREV_T1005A1
$0010                           PSEL_HICAP
$0010                           _PROC_RAMWIDTH
$0010                           _PROC_ROMWIDTH
$0011                           MASKREV_T1005
$0011                           MASKREV_T1005A2
$0011                           PSEL_OSCTRIP
$0011                           _ASM_DAY
$0011                           _ASM_PROCESSOR
$0012                           MASKREV_T1005A3
$0012                           PSEL_LOCAP
$0012                           _ASM_HOUR
$0013                           MASKREV_T1005A4
$0013                           PSEL_IPB
$001D                           _ASM_MINUTE
$001F                           PSEL_FLOAT
$0020                           MASKREV_T1006
$0020                           MASKREV_T1006A0
$0021                           MASKREV_T1006A2
$0022                           MASKREV_T1006A3
$0023                           MASKREV_T1006A4
$0028                           MASKREV_T1006B
$0028                           MASKREV_T1006B0
$0028                           MASKREV_T1006B1
$0030                           BESTGUESSXREFHI
$0030                           MASKREV_T1007
$0032                           _ASM_SECOND
$0040                           BASEPIEMASK
$0040                           BASEYLCTLMASK
$0040                           RAM_BANK_SIZE
$0040                           _PROC_BANKSIZE
$004B                           _SEG_SIZE_SUBR0
$004E                           PRESERVEPINS_POUT
$0071                           RCOND_RESERVED
$0080                           COLOR_AQUA_AMOUNT_RED
$0080                           COLOR_BLUEVIOLET_AMOUNT_RED
$0080                           COLOR_PINK_AMOUNT_GREEN
$0080                           GS_1_006
$00C5                           _SEG_SIZE_CODE0
$00ED                           _SEG_SIZE_ORG_0
$0100                           GS_1_200
$0100                           _PROC_DATASIZE
$0130                           BASEXHCTLMASK
$0180                           COLOR_ORANGE_AMOUNT_GREEN
$0180                           COLOR_PINK_AMOUNT_BLUE
$0180                           COLOR_VIOLET_AMOUNT_RED
$0180                           GS_1_012
$01FE                           _ASM_INSTRUCTION_COUNT
$0200                           COLOR_AQUA_AMOUNT_BLUE
$0200                           GS_1_100
$0220                           BASEOCTLMASK
$0280                           GS_1_106
$0300                           COLOR_MAGENTA_AMOUNT_BLUE
$0300                           GS_1_300

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 66

Symbol table (numerical)


$0380                           GS_1_112
$0390                           BASEXLCTLMASK
$03FF                           COLOR_AQUA_AMOUNT_GREEN
$03FF                           COLOR_BLUEVIOLET_AMOUNT_BLUE
$03FF                           COLOR_BLUE_AMOUNT_BLUE
$03FF                           COLOR_CYAN_AMOUNT_BLUE
$03FF                           COLOR_CYAN_AMOUNT_GREEN
$03FF                           COLOR_GREEN_AMOUNT_GREEN
$03FF                           COLOR_MAGENTA_AMOUNT_RED
$03FF                           COLOR_ORANGE_AMOUNT_RED
$03FF                           COLOR_PINK_AMOUNT_RED
$03FF                           COLOR_RED_AMOUNT_RED
$03FF                           COLOR_VIOLET_AMOUNT_BLUE
$03FF                           COLOR_WHITE_AMOUNT_BLUE
$03FF                           COLOR_WHITE_AMOUNT_GREEN
$03FF                           COLOR_WHITE_AMOUNT_RED
$03FF                           COLOR_YELLOW_AMOUNT_GREEN
$03FF                           COLOR_YELLOW_AMOUNT_RED
$04C0                           BITMASK_SPI_IN
$07D5                           _ASM_YEAR
$0800                           BASEPOUTMASK
$0800                           BITMASK_SPI_OUT
$0CC0                           BITMASK_SPI
$1000                           PRESERVEPINS_PDIR
$1000                           _PROC_ROMSIZE
$5000                           SIMCTL_CMD_COUNTTIME
$6000                           SIMCTL_CMD_COUNTCLKOUT
$7000                           SIMCTL_CMD_COUNTCLKIN
$8000                           CCTL_GUARD_VAL
$9000                           SIMCTL_CMD_COUNTBGCLK
$A000                           PC_GUARD_VAL
$A000                           SIMCTL_CMD_SPIMON
$A000                           _PROC_ROMOFFSET
$C000                           CCTL_RESERVED
$C100                           STATX_RESERVED
$E330                           BITMASK_UNUSEDIOS
$F000                           PC_RESERVED
$F331                           BASEPCTLMASK
$FC00                           ANACTL_RESERVED
$FC00                           OCTL_RESERVED
$FC00                           TCTL_RESERVED
$FC00                           XHCTL_RESERVED
$FC00                           XLCTL_RESERVED
$FC00                           YHCTL_RESERVED
$FC00                           YLCTL_RESERVED
$FFFF                           _PROC_ROMBLANK

LADDR $0000                     RESETVECTOR
LADDR $0000                     _SEG_START_ORG_0
LADDR $0001                     MFGOSCVECTORADDR
LADDR $0001                     OSCVECTOR
LADDR $0002                     T1_BEGIN
LADDR $000C                     CLEARLOOP
LADDR $0020                     WAITFORTHREAD3TORECEIVESPIADDRESS
LADDR $002A                     COLORJUMPTABLE
LADDR $002A                     PINK
LADDR $0032                     RED
LADDR $003A                     ORANGE
LADDR $0042                     YELLOW
LADDR $004A                     GREEN
LADDR $0052                     AQUA
LADDR $005A                     CYAN
LADDR $0062                     BLUE
LADDR $006A                     BLUEVIOLET
LADDR $0072                     VIOLET
LADDR $007A                     MAGENTA
LADDR $0082                     WHITE_11
LADDR $008A                     WHITE_12
LADDR $0092                     WHITE_13
LADDR $009A                     WHITE_14
LADDR $00A2                     WHITE_15
LADDR $00A8                     COLORSET
LADDR $00AB                     T1_MAIN

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 67

Symbol table (numerical)


LADDR $00C2                     NOTHEADER
LADDR $00C9                     PWMSEQUENCEHEADER
LADDR $00CF                     RECEIVEPWM_RED
LADDR $00D5                     RECEIVEPWM_GREEN
LADDR $00DB                     RECEIVEPWM_BLUE
LADDR $00DF                     T1_WAITFORBUFFEREMPTY
LADDR $00ED                     INITANALOG
LADDR $00ED                     _SEG_START_SUBR0
LADDR $00F3                     OSCVECTORINITIALIZED
LADDR $0101                     T2_UPDATELEDS
LADDR $010F                     T2_WAIT_10A_AND_4
LADDR $011C                     T2_INITIALIZEPORTS
LADDR $012A                     T3_INITIALIZEPORTS
LADDR $0138                     T2_START
LADDR $0138                     _SEG_START_CODE0
LADDR $0139                     T2_TOGGLELIGHTS
LADDR $013D                     T2_ONWAITINGLOOP
LADDR $0145                     T2_OFFWAITINGLOOP
LADDR $014A                     T2_MAIN
LADDR $0152                     COUNTERPEGGED
LADDR $0155                     CHECKFORNEWDATA
LADDR $0161                     NOCOUNTERTIMEOUT
LADDR $0164                     NONEWDATA
LADDR $016E                     DO_PWM
LADDR $019E                     T3_START
LADDR $01A4                     INITIALIZEADDRESS
LADDR $01B5                     T3_MAIN
LADDR $01C4                     DATAFORUS
LADDR $01CB                     COMMANDJUMPTABLE
LADDR $01DB                     T3_SENDDATATOTHR1
LADDR $01E5                     T3_READREGISTER
LADDR $01EC                     T3_WRITEREGISTER
LADDR $01EF                     T3_WRITEDATALOW
LADDR $01F2                     T3_WRITEDATAHIGH
LADDR $01FC                     HAPPY
LADDR $0BFF                     _SEG_START_ORG_3071

REG $00                         STATX
REG $00 BITS $00FF              X
REG $00 BITS $0200              A_GT_I
REG $00 BITS $0200              A_LT_R
REG $00 BITS $0200              CNZ
REG $00 BITS $0200              I_LT_A
REG $00 BITS $0200              R_GT_A
REG $00 BITS $0200 [BITNOT]     A_GE_R
REG $00 BITS $0200 [BITNOT]     A_LE_I
REG $00 BITS $0200 [BITNOT]     I_GE_A
REG $00 BITS $0200 [BITNOT]     NCNZ
REG $00 BITS $0200 [BITNOT]     R_LE_A
REG $00 BITS $0400              A_GE_IL
REG $00 BITS $0400              A_LE_RL
REG $00 BITS $0400              CL
REG $00 BITS $0400              I_LE_AL
REG $00 BITS $0400              NBWL
REG $00 BITS $0400              R_GE_AL
REG $00 BITS $0400 [BITNOT]     A_GT_RL
REG $00 BITS $0400 [BITNOT]     A_LT_IL
REG $00 BITS $0400 [BITNOT]     BWL
REG $00 BITS $0400 [BITNOT]     I_GT_AL
REG $00 BITS $0400 [BITNOT]     NCL
REG $00 BITS $0400 [BITNOT]     R_LT_AL
REG $00 BITS $0800              A_GE_I
REG $00 BITS $0800              A_LE_R
REG $00 BITS $0800              C
REG $00 BITS $0800              I_LE_A
REG $00 BITS $0800              NBW
REG $00 BITS $0800              R_GE_A
REG $00 BITS $0800 [BITNOT]     A_GT_R
REG $00 BITS $0800 [BITNOT]     A_LT_I
REG $00 BITS $0800 [BITNOT]     BW
REG $00 BITS $0800 [BITNOT]     I_GT_A
REG $00 BITS $0800 [BITNOT]     NC
REG $00 BITS $0800 [BITNOT]     R_LT_A

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 68

Symbol table (numerical)


REG $00 BITS $1000              A_EQ_IL
REG $00 BITS $1000              A_EQ_RL
REG $00 BITS $1000              I_EQ_AL
REG $00 BITS $1000              R_EQ_AL
REG $00 BITS $1000              ZL
REG $00 BITS $1000 [BITNOT]     A_NE_IL
REG $00 BITS $1000 [BITNOT]     A_NE_RL
REG $00 BITS $1000 [BITNOT]     I_NE_AL
REG $00 BITS $1000 [BITNOT]     NZL
REG $00 BITS $1000 [BITNOT]     R_NE_AL
REG $00 BITS $2000              A_EQ_I
REG $00 BITS $2000              A_EQ_R
REG $00 BITS $2000              I_EQ_A
REG $00 BITS $2000              R_EQ_A
REG $00 BITS $2000              Z
REG $00 BITS $2000 [BITNOT]     A_NE_I
REG $00 BITS $2000 [BITNOT]     A_NE_R
REG $00 BITS $2000 [BITNOT]     I_NE_A
REG $00 BITS $2000 [BITNOT]     NZ
REG $00 BITS $2000 [BITNOT]     R_NE_A
REG $00 BITS $FF00              STATUS
REG $01                         A
REG $02                         PC
REG $02 BITS $0800              PC_PAGE
REG $02 BITS $F000              PC_GUARD
REG $03                         LINK
REG $04                         PCTL
REG $05                         PIE
REG $06                         PDIR
REG $06 BITS $1000              SETADDRESSOUT
REG $07                         POUT
REG $07 BITS $0002              PWM_RED
REG $07 BITS $0004              PWM_GREEN
REG $07 BITS $0008              PWM_BLUE
REG $07 BITS $0800              SDOUT
REG $08                         PIN
REG $08 BITS $0001              SETADDRESSIN
REG $08 BITS $0040              SSB
REG $08 BITS $0080              SDIN
REG $08 BITS $0400              SCLK
REG $09                         CCTL
REG $09 BITS $0003              THR
REG $09 BITS $0004              XRES
REG $09 BITS $0008              CDIV
REG $09 BITS $0030              CCLK
REG $09 BITS $0040              TALT
REG $09 BITS $0080              TPRI
REG $09 BITS $0100              SCHECK
REG $09 BITS $0200              TGL
REG $09 BITS $0400              TRDY2
REG $09 BITS $0800              TEN2
REG $09 BITS $1000              TEN3
REG $09 BITS $2000              TRDY1
REG $09 BITS $C000              CCTL_GUARD
REG $0A                         CTIME
REG $0A BITS $7FFF              CTIME_COUNT
REG $0A BITS $8000              TRDY3
REG $0B                         SPITX
REG $0C                         FIRST_RAM
REG $0C                         FLAGWORD
REG $0C                         _PROC_FIRSTRAM
REG $0C BITS $0001              T1_DATAREADY
REG $0C BITS $0002              T1_HAVEADDRESS
REG $0D                         Q_HEAD
REG $0E                         Q_TAIL
REG $0F                         T1_CURRENTDATA
REG $10                         T1_RECEIVEPWMSTATE
REG $10 BITS $0001              READYFORRED
REG $10 BITS $0002              READYFORGREEN
REG $10 BITS $0004              READYFORBLUE
REG $10C                        PINEXT
REG $10D                        ANASEQ
REG $10D BITS $000F             ANASEQ_C

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 69

Symbol table (numerical)


REG $10D BITS $03F0             ANASEQ_JG
REG $10D BITS $0C00             ANASEQ_J
REG $10D BITS $F000             ANASEQ_S
REG $11                         T1_RECEIVING_TIME
REG $12                         T1_RECEIVING_RED
REG $13                         T1_RECEIVING_GREEN
REG $14                         T1_RECEIVING_BLUE
REG $15                         T1_TIME_DATA
REG $16                         T1_RED_DATA
REG $17                         T1_GREEN_DATA
REG $18                         T1_BLUE_DATA
REG $1E                         PACKRATIDLOW
REG $1F                         PACKRATIDHIGH
REG $20                         T2_TIME_DATA
REG $21                         T2_RED_DATA
REG $22                         T2_GREEN_DATA
REG $23                         T2_BLUE_DATA
REG $24                         T2_RED_ROTATE
REG $25                         T2_GREEN_ROTATE
REG $26                         T2_BLUE_ROTATE
REG $30                         MYADDRESS
REG $31                         T3_CURRENTDATA
REG $33                         T3_WRITEREGISTERADDRESS
REG $34                         T3_WRITEREGISTERDATA
REG $40                         SPI_BUFFER
REG $DF                         LAST_RAM
REG $DF                         _PROC_LASTRAM
REG $E0                         SENSORDATA
REG $E0                         XCH
REG $E0                         XCH0
REG $E0                         XREGS
REG $E1                         YCH
REG $E1                         YCH0
REG $E1                         YREGS
REG ($E0 ALT $E1)               XYCH
REG ($E0 ALT $E1)               XYCH0
REG ($E0 ALT $E1)               XYREGS
REG $E2                         TPC1
REG $E3                         TPC2
REG $E4                         XCH4
REG $E5                         YCH4
REG ($E4 ALT $E5)               XYCH4
REG $E6                         TPC3
REG $E8                         XCH8
REG $E9                         YCH8
REG ($E8 ALT $E9)               XYCH8
REG $EA                         PORTB
REG $EB                         PORTC
REG $EC                         XCH12
REG $ED                         YCH12
REG ($EC ALT $ED)               XYCH12
REG $EE                         SPIRX
REG $EF                         PAUX
REG $F0                         XCH16
REG $F1                         DDAC
REG $F1                         YCH16
REG ($F0 ALT $F1)               XYCH16
REG $F2                         SIMEXTPDIR
REG $F3                         SIMEXTPOUT
REG $F4                         OCTL
REG $F4 BITS $003F              OSC
REG $F4 BITS $01C0              BGCAL
REG $F4 BITS $0200              AEN
REG $F5                         TCTL
REG $F5 BITS $0001              PAXIS
REG $F5 BITS $001F              PSEL
REG $F5 BITS $0020              PSTR
REG $F5 BITS $0040              DDRV
REG $F5 BITS $0080              DCMP
REG $F5 BITS $0300              CHN
REG $F6                         SIMANASEQ
REG $F6 BITS $0003              SIMANASEQ_C
REG $F6 BITS $003C              SIMANASEQ_J

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 70

Symbol table (numerical)


REG $F6 BITS $0040              SIMANASEQ_JHIGH
REG $F6 BITS $0780              SIMANASEQ_S
REG $F6 BITS $1800              SIMANASEQ_CHN
REG $F6 BITS $2000              SIMANASEQ_CVI
REG $F7                         SIMMAP
REG $F8                         XLCTL
REG $F8 BITS $003F              XREFLO
REG $F8 BITS $0040              ENBL9
REG $F8 BITS $0080              XADCEN
REG $F8 BITS $0100              XREFEN
REG $F8 BITS $0200              XSENSE
REG $F9                         YLCTL
REG $F9 BITS $003F              YREFLO
REG $F9 BITS $0040              BIGREF
REG $F9 BITS $0080              YADCEN
REG $F9 BITS $0100              YREFEN
REG $F9 BITS $0200              YSENSE
REG ($F8 ALT $F9)               XYLCTL
REG ($F8 ALT $F9) BITS $003F    XYREFLO
REG ($F8 ALT $F9) BITS $0080    XYADCEN
REG ($F8 ALT $F9) BITS $0100    XYREFEN
REG ($F8 ALT $F9) BITS $0200    XYSENSE
REG $FA                         SIMARG
REG $FB                         SIMCTL
REG $FB BITS $0001              SIMCTL_FASTTIMERS
REG $FB BITS $0002              SIMCTL_NOXTAL
REG $FB BITS $0004              SIMCTL_NOTRACE
REG $FB BITS $0010              SIMCTL_DELAYPOUT0
REG $FB BITS $0020              SIMCTL_DELAYPDIR0
REG $FB BITS $0040              SIMCTL_EXTWOUT
REG $FB BITS $0080              SIMCTL_EXTWDIR
REG $FB BITS $0100              SIMCTL_FASTTEST
REG $FB BITS $F000              SIMCTL_CMD
REG $FC                         XHCTL
REG $FC BITS $003F              XREFHI
REG $FC BITS $0040              MOIST
REG $FC BITS $0080              OLDF
REG $FC BITS $0300              NCHN
REG $FD                         YHCTL
REG $FD BITS $003F              YREFHI
REG $FD BITS $0040              BIASENB
REG $FD BITS $0040              BOFF
REG $FD BITS $0380              GS
REG ($FC ALT $FD)               XYHCTL
REG ($FC ALT $FD) BITS $003F    XYREFHI
REG $FE                         RCOND
REG $FE BITS $0002              RSW
REG $FE BITS $0004              RCHECK
REG $FE BITS $0008              RESD
REG $FE BITS $0008              RWDT
REG $FE BITS $0080              RPOWER
REG $FE BITS $FF00              MASKREV
REG $FF                         RESET
REG $FF                         RESET_REG

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 71

RAM allocation map


00:  PPPP PPPP PPPP PPPP  PPPP PPPP PPPP PPPP
08:  PPPP PPPP PPPP ----  XXXX XXXX XXXX XXXX
10:  XXXX XXXX XXXX XXXX  XXXX XXXX XXXX XXXX
18:  XXXX ---- ---- ----  ---- ---- XXXX XXXX
20:  XXXX XXXX XXXX XXXX  XXXX XXXX XXXX ----
28:  ---- ---- ---- ----  ---- ---- ---- ----
30:  XXXX XXXX ---- XXXX  XXXX ---- ---- ----
38:  ---- ---- ---- ----  ---- ---- ---- ----

40:  XXXX ---- ---- ----  ---- ---- ---- ----
48:  ---- ---- ---- ----  ---- ---- ---- ----
50:  ---- ---- ---- ----  ---- ---- ---- ----
58:  ---- ---- ---- ----  ---- ---- ---- ----
60:  ---- ---- ---- ----  ---- ---- ---- ----
68:  ---- ---- ---- ----  ---- ---- ---- ----
70:  ---- ---- ---- ----  ---- ---- ---- ----
78:  ---- ---- ---- ----  ---- ---- ---- ----

80:  ---- ---- ---- ----  ---- ---- ---- ----
88:  ---- ---- ---- ----  ---- ---- ---- ----
90:  ---- ---- ---- ----  ---- ---- ---- ----
98:  ---- ---- ---- ----  ---- ---- ---- ----
A0:  ---- ---- ---- ----  ---- ---- ---- ----
A8:  ---- ---- ---- ----  ---- ---- ---- ----
B0:  ---- ---- ---- ----  ---- ---- ---- ----
B8:  ---- ---- ---- ----  ---- ---- ---- ----

C0:  ---- ---- ---- ----  ---- ---- ---- ----
C8:  ---- ---- ---- ----  ---- ---- ---- ----
D0:  ---- ---- ---- ----  ---- ---- ---- ----
D8:  ---- ---- ---- ----  ---- ---- ---- ----

E0:  PPPP PPPP PPPP PPPP  PPPP PPPP PPPP ....
E8:  PPPP PPPP .... ....  PPPP PPPP .... ....
F0:  PPPP PPPP .... ....  PPPP PPPP .... ....
F8:  PPPP PPPP .... ....  PPPP PPPP PPPP PPPP



REG $0B:  -------- --------   WORD        (unused word)
REG $0C:  [XXXXXXX XXXXXXX]   WORD        FLAGWORD
REG $0D:  [XXXXXXX XXXXXXX]   WORD        Q_HEAD
REG $0E:  [XXXXXXX XXXXXXX]   WORD        Q_TAIL
REG $0F:  [XXXXXXX XXXXXXX]   WORD        T1_CURRENTDATA
REG $10:  [XXXXXXX XXXXXXX]   WORD        T1_RECEIVEPWMSTATE
REG $11:  [XXXXXXX XXXXXXX]   WORD        T1_RECEIVING_TIME
REG $12:  [XXXXXXX XXXXXXX]   WORD        T1_RECEIVING_RED
REG $13:  [XXXXXXX XXXXXXX]   WORD        T1_RECEIVING_GREEN
REG $14:  [XXXXXXX XXXXXXX]   WORD        T1_RECEIVING_BLUE
REG $15:  [XXXXXXX XXXXXXX]   WORD        T1_TIME_DATA
REG $16:  [XXXXXXX XXXXXXX]   WORD        T1_RED_DATA
REG $17:  [XXXXXXX XXXXXXX]   WORD        T1_GREEN_DATA
REG $18:  [XXXXXXX XXXXXXX]   WORD        T1_BLUE_DATA
REG $19:  -------- --------   WORD        (unused word)
REG $1A:  -------- --------   WORD        (unused word)
REG $1B:  -------- --------   WORD        (unused word)
REG $1C:  -------- --------   WORD        (unused word)
REG $1D:  -------- --------   WORD        (unused word)
REG $1E:  [XXXXXXX XXXXXXX]   WORD        PACKRATIDLOW
REG $1F:  [XXXXXXX XXXXXXX]   WORD        PACKRATIDHIGH
REG $20:  [XXXXXXX XXXXXXX]   WORD        T2_TIME_DATA
REG $21:  [XXXXXXX XXXXXXX]   WORD        T2_RED_DATA
REG $22:  [XXXXXXX XXXXXXX]   WORD        T2_GREEN_DATA
REG $23:  [XXXXXXX XXXXXXX]   WORD        T2_BLUE_DATA
REG $24:  [XXXXXXX XXXXXXX]   WORD        T2_RED_ROTATE
REG $25:  [XXXXXXX XXXXXXX]   WORD        T2_GREEN_ROTATE
REG $26:  [XXXXXXX XXXXXXX]   WORD        T2_BLUE_ROTATE
REG $27:  -------- --------   WORD        (unused word)
REG $28:  -------- --------   WORD        (unused word)
REG $29:  -------- --------   WORD        (unused word)
REG $2A:  -------- --------   WORD        (unused word)
REG $2B:  -------- --------   WORD        (unused word)
REG $2C:  -------- --------   WORD        (unused word)

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 72

RAM allocation map


REG $2D:  -------- --------   WORD        (unused word)
REG $2E:  -------- --------   WORD        (unused word)
REG $2F:  -------- --------   WORD        (unused word)
REG $30:  [XXXXXXX XXXXXXX]   WORD        MYADDRESS
REG $31:  [XXXXXXX XXXXXXX]   WORD        T3_CURRENTDATA
REG $32:  -------- --------   WORD        (unused word)
REG $33:  [XXXXXXX XXXXXXX]   WORD        T3_WRITEREGISTERADDRESS
REG $34:  [XXXXXXX XXXXXXX]   WORD        T3_WRITEREGISTERDATA
REG $35:  -------- --------   WORD        (unused word)
REG $36:  -------- --------   WORD        (unused word)
REG $37:  -------- --------   WORD        (unused word)
REG $38:  -------- --------   WORD        (unused word)
REG $39:  -------- --------   WORD        (unused word)
REG $3A:  -------- --------   WORD        (unused word)
REG $3B:  -------- --------   WORD        (unused word)
REG $3C:  -------- --------   WORD        (unused word)
REG $3D:  -------- --------   WORD        (unused word)
REG $3E:  -------- --------   WORD        (unused word)
REG $3F:  -------- --------   WORD        (unused word)
REG $40:  [XXXXXXX XXXXXXX]   WORD        SPI_BUFFER
REG $41:  -------- --------   WORD        (unused word)
REG $42:  -------- --------   WORD        (unused word)
REG $43:  -------- --------   WORD        (unused word)
REG $44:  -------- --------   WORD        (unused word)
REG $45:  -------- --------   WORD        (unused word)
REG $46:  -------- --------   WORD        (unused word)
REG $47:  -------- --------   WORD        (unused word)
REG $48:  -------- --------   WORD        (unused word)
REG $49:  -------- --------   WORD        (unused word)
REG $4A:  -------- --------   WORD        (unused word)
REG $4B:  -------- --------   WORD        (unused word)
REG $4C:  -------- --------   WORD        (unused word)
REG $4D:  -------- --------   WORD        (unused word)
REG $4E:  -------- --------   WORD        (unused word)
REG $4F:  -------- --------   WORD        (unused word)
REG $50:  -------- --------   WORD        (unused word)
REG $51:  -------- --------   WORD        (unused word)
REG $52:  -------- --------   WORD        (unused word)
REG $53:  -------- --------   WORD        (unused word)
REG $54:  -------- --------   WORD        (unused word)
REG $55:  -------- --------   WORD        (unused word)
REG $56:  -------- --------   WORD        (unused word)
REG $57:  -------- --------   WORD        (unused word)
REG $58:  -------- --------   WORD        (unused word)
REG $59:  -------- --------   WORD        (unused word)
REG $5A:  -------- --------   WORD        (unused word)
REG $5B:  -------- --------   WORD        (unused word)
REG $5C:  -------- --------   WORD        (unused word)
REG $5D:  -------- --------   WORD        (unused word)
REG $5E:  -------- --------   WORD        (unused word)
REG $5F:  -------- --------   WORD        (unused word)
REG $60:  -------- --------   WORD        (unused word)
REG $61:  -------- --------   WORD        (unused word)
REG $62:  -------- --------   WORD        (unused word)
REG $63:  -------- --------   WORD        (unused word)
REG $64:  -------- --------   WORD        (unused word)
REG $65:  -------- --------   WORD        (unused word)
REG $66:  -------- --------   WORD        (unused word)
REG $67:  -------- --------   WORD        (unused word)
REG $68:  -------- --------   WORD        (unused word)
REG $69:  -------- --------   WORD        (unused word)
REG $6A:  -------- --------   WORD        (unused word)
REG $6B:  -------- --------   WORD        (unused word)
REG $6C:  -------- --------   WORD        (unused word)
REG $6D:  -------- --------   WORD        (unused word)
REG $6E:  -------- --------   WORD        (unused word)
REG $6F:  -------- --------   WORD        (unused word)
REG $70:  -------- --------   WORD        (unused word)
REG $71:  -------- --------   WORD        (unused word)
REG $72:  -------- --------   WORD        (unused word)
REG $73:  -------- --------   WORD        (unused word)
REG $74:  -------- --------   WORD        (unused word)
REG $75:  -------- --------   WORD        (unused word)

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 73

RAM allocation map


REG $76:  -------- --------   WORD        (unused word)
REG $77:  -------- --------   WORD        (unused word)
REG $78:  -------- --------   WORD        (unused word)
REG $79:  -------- --------   WORD        (unused word)
REG $7A:  -------- --------   WORD        (unused word)
REG $7B:  -------- --------   WORD        (unused word)
REG $7C:  -------- --------   WORD        (unused word)
REG $7D:  -------- --------   WORD        (unused word)
REG $7E:  -------- --------   WORD        (unused word)
REG $7F:  -------- --------   WORD        (unused word)
REG $80:  -------- --------   WORD        (unused word)
REG $81:  -------- --------   WORD        (unused word)
REG $82:  -------- --------   WORD        (unused word)
REG $83:  -------- --------   WORD        (unused word)
REG $84:  -------- --------   WORD        (unused word)
REG $85:  -------- --------   WORD        (unused word)
REG $86:  -------- --------   WORD        (unused word)
REG $87:  -------- --------   WORD        (unused word)
REG $88:  -------- --------   WORD        (unused word)
REG $89:  -------- --------   WORD        (unused word)
REG $8A:  -------- --------   WORD        (unused word)
REG $8B:  -------- --------   WORD        (unused word)
REG $8C:  -------- --------   WORD        (unused word)
REG $8D:  -------- --------   WORD        (unused word)
REG $8E:  -------- --------   WORD        (unused word)
REG $8F:  -------- --------   WORD        (unused word)
REG $90:  -------- --------   WORD        (unused word)
REG $91:  -------- --------   WORD        (unused word)
REG $92:  -------- --------   WORD        (unused word)
REG $93:  -------- --------   WORD        (unused word)
REG $94:  -------- --------   WORD        (unused word)
REG $95:  -------- --------   WORD        (unused word)
REG $96:  -------- --------   WORD        (unused word)
REG $97:  -------- --------   WORD        (unused word)
REG $98:  -------- --------   WORD        (unused word)
REG $99:  -------- --------   WORD        (unused word)
REG $9A:  -------- --------   WORD        (unused word)
REG $9B:  -------- --------   WORD        (unused word)
REG $9C:  -------- --------   WORD        (unused word)
REG $9D:  -------- --------   WORD        (unused word)
REG $9E:  -------- --------   WORD        (unused word)
REG $9F:  -------- --------   WORD        (unused word)
REG $A0:  -------- --------   WORD        (unused word)
REG $A1:  -------- --------   WORD        (unused word)
REG $A2:  -------- --------   WORD        (unused word)
REG $A3:  -------- --------   WORD        (unused word)
REG $A4:  -------- --------   WORD        (unused word)
REG $A5:  -------- --------   WORD        (unused word)
REG $A6:  -------- --------   WORD        (unused word)
REG $A7:  -------- --------   WORD        (unused word)
REG $A8:  -------- --------   WORD        (unused word)
REG $A9:  -------- --------   WORD        (unused word)
REG $AA:  -------- --------   WORD        (unused word)
REG $AB:  -------- --------   WORD        (unused word)
REG $AC:  -------- --------   WORD        (unused word)
REG $AD:  -------- --------   WORD        (unused word)
REG $AE:  -------- --------   WORD        (unused word)
REG $AF:  -------- --------   WORD        (unused word)
REG $B0:  -------- --------   WORD        (unused word)
REG $B1:  -------- --------   WORD        (unused word)
REG $B2:  -------- --------   WORD        (unused word)
REG $B3:  -------- --------   WORD        (unused word)
REG $B4:  -------- --------   WORD        (unused word)
REG $B5:  -------- --------   WORD        (unused word)
REG $B6:  -------- --------   WORD        (unused word)
REG $B7:  -------- --------   WORD        (unused word)
REG $B8:  -------- --------   WORD        (unused word)
REG $B9:  -------- --------   WORD        (unused word)
REG $BA:  -------- --------   WORD        (unused word)
REG $BB:  -------- --------   WORD        (unused word)
REG $BC:  -------- --------   WORD        (unused word)
REG $BD:  -------- --------   WORD        (unused word)
REG $BE:  -------- --------   WORD        (unused word)

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 74

RAM allocation map


REG $BF:  -------- --------   WORD        (unused word)
REG $C0:  -------- --------   WORD        (unused word)
REG $C1:  -------- --------   WORD        (unused word)
REG $C2:  -------- --------   WORD        (unused word)
REG $C3:  -------- --------   WORD        (unused word)
REG $C4:  -------- --------   WORD        (unused word)
REG $C5:  -------- --------   WORD        (unused word)
REG $C6:  -------- --------   WORD        (unused word)
REG $C7:  -------- --------   WORD        (unused word)
REG $C8:  -------- --------   WORD        (unused word)
REG $C9:  -------- --------   WORD        (unused word)
REG $CA:  -------- --------   WORD        (unused word)
REG $CB:  -------- --------   WORD        (unused word)
REG $CC:  -------- --------   WORD        (unused word)
REG $CD:  -------- --------   WORD        (unused word)
REG $CE:  -------- --------   WORD        (unused word)
REG $CF:  -------- --------   WORD        (unused word)
REG $D0:  -------- --------   WORD        (unused word)
REG $D1:  -------- --------   WORD        (unused word)
REG $D2:  -------- --------   WORD        (unused word)
REG $D3:  -------- --------   WORD        (unused word)
REG $D4:  -------- --------   WORD        (unused word)
REG $D5:  -------- --------   WORD        (unused word)
REG $D6:  -------- --------   WORD        (unused word)
REG $D7:  -------- --------   WORD        (unused word)
REG $D8:  -------- --------   WORD        (unused word)
REG $D9:  -------- --------   WORD        (unused word)
REG $DA:  -------- --------   WORD        (unused word)
REG $DB:  -------- --------   WORD        (unused word)
REG $DC:  -------- --------   WORD        (unused word)
REG $DD:  -------- --------   WORD        (unused word)
REG $DE:  -------- --------   WORD        (unused word)
REG $DF:  -------- --------   WORD        (unused word)








ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 75

ROM memory map (by segment)


0000: OOOOOOOOOOOOOOOO OOOOOOOOOOOOOOOO OOOOOOOOOOOOOOOO OOOOOOOOOOOOOOOO
0040: OOOOOOOOOOOOOOOO OOOOOOOOOOOOOOOO OOOOOOOOOOOOOOOO OOOOOOOOOOOOOOOO
0080: OOOOOOOOOOOOOOOO OOOOOOOOOOOOOOOO OOOOOOOOOOOOOOOO OOOOOOOOOOOOOOOO
00C0: OOOOOOOOOOOOOOOO OOOOOOOOOOOOOOOO OOOOOOOOOOOOOSSS SSSSSSSSSSSSSSSS
0100: SSSSSSSSSSSSSSSS SSSSSSSSSSSSSSSS SSSSSSSSSSSSSSSS SSSSSSSSCCCCCCCC
0140: CCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCC
0180: CCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCC
01C0: CCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCC CCCCCCCCCCCCC---
0200: ---------------- ---------------- ---------------- ----------------
0240: ---------------- ---------------- ---------------- ----------------
0280: ---------------- ---------------- ---------------- ----------------
02C0: ---------------- ---------------- ---------------- ----------------
0300: ---------------- ---------------- ---------------- ----------------
0340: ---------------- ---------------- ---------------- ----------------
0380: ---------------- ---------------- ---------------- ----------------
03C0: ---------------- ---------------- ---------------- ----------------
0400: ---------------- ---------------- ---------------- ----------------
0440: ---------------- ---------------- ---------------- ----------------
0480: ---------------- ---------------- ---------------- ----------------
04C0: ---------------- ---------------- ---------------- ----------------
0500: ---------------- ---------------- ---------------- ----------------
0540: ---------------- ---------------- ---------------- ----------------
0580: ---------------- ---------------- ---------------- ----------------
05C0: ---------------- ---------------- ---------------- ----------------
0600: ---------------- ---------------- ---------------- ----------------
0640: ---------------- ---------------- ---------------- ----------------
0680: ---------------- ---------------- ---------------- ----------------
06C0: ---------------- ---------------- ---------------- ----------------
0700: ---------------- ---------------- ---------------- ----------------
0740: ---------------- ---------------- ---------------- ----------------
0780: ---------------- ---------------- ---------------- ----------------
07C0: ---------------- ---------------- ---------------- ----------------

0800: ---------------- ---------------- ---------------- ----------------
0840: ---------------- ---------------- ---------------- ----------------
0880: ---------------- ---------------- ---------------- ----------------
08C0: ---------------- ---------------- ---------------- ----------------
0900: ---------------- ---------------- ---------------- ----------------
0940: ---------------- ---------------- ---------------- ----------------
0980: ---------------- ---------------- ---------------- ----------------
09C0: ---------------- ---------------- ---------------- ----------------
0A00: ---------------- ---------------- ---------------- ----------------
0A40: ---------------- ---------------- ---------------- ----------------
0A80: ---------------- ---------------- ---------------- ----------------
0AC0: ---------------- ---------------- ---------------- ----------------
0B00: ---------------- ---------------- ---------------- ----------------
0B40: ---------------- ---------------- ---------------- ----------------
0B80: ---------------- ---------------- ---------------- ----------------
0BC0: ---------------- ---------------- ---------------- ---------------O
0C00: ---------------- ---------------- ---------------- ----------------
0C40: ---------------- ---------------- ---------------- ----------------
0C80: ---------------- ---------------- ---------------- ----------------
0CC0: ---------------- ---------------- ---------------- ----------------
0D00: ---------------- ---------------- ---------------- ----------------
0D40: ---------------- ---------------- ---------------- ----------------
0D80: ---------------- ---------------- ---------------- ----------------
0DC0: ---------------- ---------------- ---------------- ----------------
0E00: ---------------- ---------------- ---------------- ----------------
0E40: ---------------- ---------------- ---------------- ----------------
0E80: ---------------- ---------------- ---------------- ----------------
0EC0: ---------------- ---------------- ---------------- ----------------
0F00: ---------------- ---------------- ---------------- ----------------
0F40: ---------------- ---------------- ---------------- ----------------
0F80: ---------------- ---------------- ---------------- ----------------
0FC0: ---------------- ---------------- ---------------- ----------------

1000: ---------------- ---------------- ---------------- ----------------
1800: ---------------- ---------------- ---------------- ----------------

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 76

ROM memory map (by segment)


     Segment name           Origin    Size   Refs
     ------------           ------    ----   ----
  C  CODE0                   $0138   $00C5   432b 306c 279d
  O  ORG:0                   $0000   $00ED   6b
  O  ORG:3071                $0BFF   $0001   304
  S  SUBR0                   $00ED   $004B   402b 231c 246d






























































ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 77

ROM memory map (by source file)


0000: bbbbbbbbbbbbbbbb bbbbbbbbbbbbbbbb bbbbbbbbbbbbbbbb bbbbbbbbbbbbbbbb
0040: bbbbbbbbbbbbbbbb bbbbbbbbbbbbbbbb bbbbbbbbbbbbbbbb bbbbbbbbbbbbbbbb
0080: bbbbbbbbbbbbbbbb bbbbbbbbbbbbbbbb bbbbbbbbbbbbbbbb bbbbbbbbbbbbbbbb
00C0: bbbbbbbbbbbbbbbb bbbbbbbbbbbbbbbb bbbbbbbbbbbbbbbb bbbbbbbbbbbbbbbb
0100: bccccccccccccccc cccccccccccccccc ccccccccccdddddd ddddddddcccccccc
0140: cccccccccccccccc cccccccccccccccc cccccccccccccccc cccccccccccccccc
0180: cccccccccccccccc ccccccccccccccdd dddddddddddddddd dddddddddddddddd
01C0: dddddddddddddddd dddddddddddddddd dddddddddddddddd dddddddddddd#---
0200: ---------------- ---------------- ---------------- ----------------
0240: ---------------- ---------------- ---------------- ----------------
0280: ---------------- ---------------- ---------------- ----------------
02C0: ---------------- ---------------- ---------------- ----------------
0300: ---------------- ---------------- ---------------- ----------------
0340: ---------------- ---------------- ---------------- ----------------
0380: ---------------- ---------------- ---------------- ----------------
03C0: ---------------- ---------------- ---------------- ----------------
0400: ---------------- ---------------- ---------------- ----------------
0440: ---------------- ---------------- ---------------- ----------------
0480: ---------------- ---------------- ---------------- ----------------
04C0: ---------------- ---------------- ---------------- ----------------
0500: ---------------- ---------------- ---------------- ----------------
0540: ---------------- ---------------- ---------------- ----------------
0580: ---------------- ---------------- ---------------- ----------------
05C0: ---------------- ---------------- ---------------- ----------------
0600: ---------------- ---------------- ---------------- ----------------
0640: ---------------- ---------------- ---------------- ----------------
0680: ---------------- ---------------- ---------------- ----------------
06C0: ---------------- ---------------- ---------------- ----------------
0700: ---------------- ---------------- ---------------- ----------------
0740: ---------------- ---------------- ---------------- ----------------
0780: ---------------- ---------------- ---------------- ----------------
07C0: ---------------- ---------------- ---------------- ----------------

0800: ---------------- ---------------- ---------------- ----------------
0840: ---------------- ---------------- ---------------- ----------------
0880: ---------------- ---------------- ---------------- ----------------
08C0: ---------------- ---------------- ---------------- ----------------
0900: ---------------- ---------------- ---------------- ----------------
0940: ---------------- ---------------- ---------------- ----------------
0980: ---------------- ---------------- ---------------- ----------------
09C0: ---------------- ---------------- ---------------- ----------------
0A00: ---------------- ---------------- ---------------- ----------------
0A40: ---------------- ---------------- ---------------- ----------------
0A80: ---------------- ---------------- ---------------- ----------------
0AC0: ---------------- ---------------- ---------------- ----------------
0B00: ---------------- ---------------- ---------------- ----------------
0B40: ---------------- ---------------- ---------------- ----------------
0B80: ---------------- ---------------- ---------------- ----------------
0BC0: ---------------- ---------------- ---------------- ---------------#
0C00: ---------------- ---------------- ---------------- ----------------
0C40: ---------------- ---------------- ---------------- ----------------
0C80: ---------------- ---------------- ---------------- ----------------
0CC0: ---------------- ---------------- ---------------- ----------------
0D00: ---------------- ---------------- ---------------- ----------------
0D40: ---------------- ---------------- ---------------- ----------------
0D80: ---------------- ---------------- ---------------- ----------------
0DC0: ---------------- ---------------- ---------------- ----------------
0E00: ---------------- ---------------- ---------------- ----------------
0E40: ---------------- ---------------- ---------------- ----------------
0E80: ---------------- ---------------- ---------------- ----------------
0EC0: ---------------- ---------------- ---------------- ----------------
0F00: ---------------- ---------------- ---------------- ----------------
0F40: ---------------- ---------------- ---------------- ----------------
0F80: ---------------- ---------------- ---------------- ----------------
0FC0: ---------------- ---------------- ---------------- ----------------

1000: ---------------- ---------------- ---------------- ----------------
1800: ---------------- ---------------- ---------------- ----------------
510 instrs used, 3586 instrs (87.5%) free

ASMT4 1.003  --  File pwm_main.asm  --  6/17/05 18:29:50  --  Page 78

ROM memory map (by source file)


     File name                                         Lines   Instrs   Errors Warnings
     ---------                                         -----   ------   ------ --------
  #  pwm_main.asm                                        308        2        0        0
  a  /toolbox/release/all-arch/include/asmt4/regs.asm      1883        0        0        0
  b  pwm_t1.asm                                          432      257        0        0
  c  pwm_t2.asm                                          306      143        0        0
  d  pwm_t3.asm                                          279      108        0        0

     Total:                                             3103      510        0        0
